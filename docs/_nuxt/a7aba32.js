(self.webpackChunknuxt_app=self.webpackChunknuxt_app||[]).push([["1"],{1734:function(Wt,dt,L){(function(){"use strict";var p;function ze(h){var N=0;return function(){return N<h.length?{done:!1,value:h[N++]}:{done:!0}}}var Z=typeof Object.defineProperties=="function"?Object.defineProperty:function(h,N,A){return h==Array.prototype||h==Object.prototype||(h[N]=A.value),h};function ie(h){h=[typeof globalThis=="object"&&globalThis,h,typeof window=="object"&&window,typeof self=="object"&&self,typeof L.g=="object"&&L.g];for(var N=0;N<h.length;++N){var A=h[N];if(A&&A.Math==Math)return A}throw Error("Cannot find global object")}var P=ie(this);function W(h,N){if(N)e:{var A=P;h=h.split(".");for(var Q=0;Q<h.length-1;Q++){var ge=h[Q];if(!(ge in A))break e;A=A[ge]}h=h[h.length-1],Q=A[h],N=N(Q),N!=Q&&N!=null&&Z(A,h,{configurable:!0,writable:!0,value:N})}}W("Symbol",function(h){function N(ke){if(this instanceof N)throw new TypeError("Symbol is not a constructor");return new A(Q+(ke||"")+"_"+ge++,ke)}function A(ke,Ie){this.h=ke,Z(this,"description",{configurable:!0,writable:!0,value:Ie})}if(h)return h;A.prototype.toString=function(){return this.h};var Q="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",ge=0;return N}),W("Symbol.iterator",function(h){if(h)return h;h=Symbol("Symbol.iterator");for(var N="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),A=0;A<N.length;A++){var Q=P[N[A]];typeof Q=="function"&&typeof Q.prototype[h]!="function"&&Z(Q.prototype,h,{configurable:!0,writable:!0,value:function(){return pe(ze(this))}})}return h});function pe(h){return h={next:h},h[Symbol.iterator]=function(){return this},h}function ee(h){var N=typeof Symbol<"u"&&Symbol.iterator&&h[Symbol.iterator];return N?N.call(h):{next:ze(h)}}function we(h){if(!(h instanceof Array)){h=ee(h);for(var N,A=[];!(N=h.next()).done;)A.push(N.value);h=A}return h}var xe=typeof Object.assign=="function"?Object.assign:function(h,N){for(var A=1;A<arguments.length;A++){var Q=arguments[A];if(Q)for(var ge in Q)Object.prototype.hasOwnProperty.call(Q,ge)&&(h[ge]=Q[ge])}return h};W("Object.assign",function(h){return h||xe});var K=typeof Object.create=="function"?Object.create:function(h){function N(){}return N.prototype=h,new N},_;if(typeof Object.setPrototypeOf=="function")_=Object.setPrototypeOf;else{var De;e:{var Fe={a:!0},Ke={};try{Ke.__proto__=Fe,De=Ke.a;break e}catch{}De=!1}_=De?function(h,N){if(h.__proto__=N,h.__proto__!==N)throw new TypeError(h+" is not extensible");return h}:null}var rt=_;function ht(h,N){if(h.prototype=K(N.prototype),h.prototype.constructor=h,rt)rt(h,N);else for(var A in N)if(A!="prototype")if(Object.defineProperties){var Q=Object.getOwnPropertyDescriptor(N,A);Q&&Object.defineProperty(h,A,Q)}else h[A]=N[A];h.za=N.prototype}function Vt(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function on(h){if(h.m)throw new TypeError("Generator is already running");h.m=!0}Vt.prototype.u=function(h){this.i=h};function $t(h,N){h.l={ma:N,na:!0},h.h=h.s||h.v}Vt.prototype.return=function(h){this.l={return:h},this.h=this.v};function ve(h,N,A){return h.h=A,{value:N}}function y(h){this.h=new Vt,this.i=h}function Qe(h,N){on(h.h);var A=h.h.j;return A?V(h,"return"in A?A.return:function(Q){return{value:Q,done:!0}},N,h.h.return):(h.h.return(N),re(h))}function V(h,N,A,Q){try{var ge=N.call(h.h.j,A);if(!(ge instanceof Object))throw new TypeError("Iterator result "+ge+" is not an object");if(!ge.done)return h.h.m=!1,ge;var ke=ge.value}catch(Ie){return h.h.j=null,$t(h.h,Ie),re(h)}return h.h.j=null,Q.call(h.h,ke),re(h)}function re(h){for(;h.h.h;)try{var N=h.i(h.h);if(N)return h.h.m=!1,{value:N.value,done:!1}}catch(A){h.h.i=void 0,$t(h.h,A)}if(h.h.m=!1,h.h.l){if(N=h.h.l,h.h.l=null,N.na)throw N.ma;return{value:N.return,done:!0}}return{value:void 0,done:!0}}function G(h){this.next=function(N){return on(h.h),h.h.j?N=V(h,h.h.j.next,N,h.h.u):(h.h.u(N),N=re(h)),N},this.throw=function(N){return on(h.h),h.h.j?N=V(h,h.h.j.throw,N,h.h.u):($t(h.h,N),N=re(h)),N},this.return=function(N){return Qe(h,N)},this[Symbol.iterator]=function(){return this}}function Re(h){function N(Q){return h.next(Q)}function A(Q){return h.throw(Q)}return new Promise(function(Q,ge){function ke(Ie){Ie.done?Q(Ie.value):Promise.resolve(Ie.value).then(N,A).then(ke,ge)}ke(h.next())})}function Be(h){return Re(new G(new y(h)))}W("Promise",function(h){function N(Ie){this.i=0,this.j=void 0,this.h=[],this.u=!1;var He=this.l();try{Ie(He.resolve,He.reject)}catch(lt){He.reject(lt)}}function A(){this.h=null}function Q(Ie){return Ie instanceof N?Ie:new N(function(He){He(Ie)})}if(h)return h;A.prototype.i=function(Ie){if(this.h==null){this.h=[];var He=this;this.j(function(){He.m()})}this.h.push(Ie)};var ge=P.setTimeout;A.prototype.j=function(Ie){ge(Ie,0)},A.prototype.m=function(){for(;this.h&&this.h.length;){var Ie=this.h;this.h=[];for(var He=0;He<Ie.length;++He){var lt=Ie[He];Ie[He]=null;try{lt()}catch(Rt){this.l(Rt)}}}this.h=null},A.prototype.l=function(Ie){this.j(function(){throw Ie})},N.prototype.l=function(){function Ie(Rt){return function(zt){lt||(lt=!0,Rt.call(He,zt))}}var He=this,lt=!1;return{resolve:Ie(this.I),reject:Ie(this.m)}},N.prototype.I=function(Ie){if(Ie===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(Ie instanceof N)this.L(Ie);else{e:switch(typeof Ie){case"object":var He=Ie!=null;break e;case"function":He=!0;break e;default:He=!1}He?this.F(Ie):this.s(Ie)}},N.prototype.F=function(Ie){var He=void 0;try{He=Ie.then}catch(lt){this.m(lt);return}typeof He=="function"?this.M(He,Ie):this.s(Ie)},N.prototype.m=function(Ie){this.v(2,Ie)},N.prototype.s=function(Ie){this.v(1,Ie)},N.prototype.v=function(Ie,He){if(this.i!=0)throw Error("Cannot settle("+Ie+", "+He+"): Promise already settled in state"+this.i);this.i=Ie,this.j=He,this.i===2&&this.K(),this.H()},N.prototype.K=function(){var Ie=this;ge(function(){if(Ie.D()){var He=P.console;typeof He<"u"&&He.error(Ie.j)}},1)},N.prototype.D=function(){if(this.u)return!1;var Ie=P.CustomEvent,He=P.Event,lt=P.dispatchEvent;return typeof lt>"u"?!0:(typeof Ie=="function"?Ie=new Ie("unhandledrejection",{cancelable:!0}):typeof He=="function"?Ie=new He("unhandledrejection",{cancelable:!0}):(Ie=P.document.createEvent("CustomEvent"),Ie.initCustomEvent("unhandledrejection",!1,!0,Ie)),Ie.promise=this,Ie.reason=this.j,lt(Ie))},N.prototype.H=function(){if(this.h!=null){for(var Ie=0;Ie<this.h.length;++Ie)ke.i(this.h[Ie]);this.h=null}};var ke=new A;return N.prototype.L=function(Ie){var He=this.l();Ie.T(He.resolve,He.reject)},N.prototype.M=function(Ie,He){var lt=this.l();try{Ie.call(He,lt.resolve,lt.reject)}catch(Rt){lt.reject(Rt)}},N.prototype.then=function(Ie,He){function lt(an,Xt){return typeof an=="function"?function(xn){try{Rt(an(xn))}catch(Tn){zt(Tn)}}:Xt}var Rt,zt,yn=new N(function(an,Xt){Rt=an,zt=Xt});return this.T(lt(Ie,Rt),lt(He,zt)),yn},N.prototype.catch=function(Ie){return this.then(void 0,Ie)},N.prototype.T=function(Ie,He){function lt(){switch(Rt.i){case 1:Ie(Rt.j);break;case 2:He(Rt.j);break;default:throw Error("Unexpected state: "+Rt.i)}}var Rt=this;this.h==null?ke.i(lt):this.h.push(lt),this.u=!0},N.resolve=Q,N.reject=function(Ie){return new N(function(He,lt){lt(Ie)})},N.race=function(Ie){return new N(function(He,lt){for(var Rt=ee(Ie),zt=Rt.next();!zt.done;zt=Rt.next())Q(zt.value).T(He,lt)})},N.all=function(Ie){var He=ee(Ie),lt=He.next();return lt.done?Q([]):new N(function(Rt,zt){function yn(xn){return function(Tn){an[xn]=Tn,Xt--,Xt==0&&Rt(an)}}var an=[],Xt=0;do an.push(void 0),Xt++,Q(lt.value).T(yn(an.length-1),zt),lt=He.next();while(!lt.done)})},N});function at(h,N){h instanceof String&&(h+="");var A=0,Q=!1,ge={next:function(){if(!Q&&A<h.length){var ke=A++;return{value:N(ke,h[ke]),done:!1}}return Q=!0,{done:!0,value:void 0}}};return ge[Symbol.iterator]=function(){return ge},ge}W("Array.prototype.keys",function(h){return h||function(){return at(this,function(N){return N})}}),W("Array.prototype.fill",function(h){return h||function(N,A,Q){var ge=this.length||0;for(0>A&&(A=Math.max(0,ge+A)),(Q==null||Q>ge)&&(Q=ge),Q=Number(Q),0>Q&&(Q=Math.max(0,ge+Q)),A=Number(A||0);A<Q;A++)this[A]=N;return this}});function S(h){return h||Array.prototype.fill}W("Int8Array.prototype.fill",S),W("Uint8Array.prototype.fill",S),W("Uint8ClampedArray.prototype.fill",S),W("Int16Array.prototype.fill",S),W("Uint16Array.prototype.fill",S),W("Int32Array.prototype.fill",S),W("Uint32Array.prototype.fill",S),W("Float32Array.prototype.fill",S),W("Float64Array.prototype.fill",S),W("Object.is",function(h){return h||function(N,A){return N===A?N!==0||1/N===1/A:N!==N&&A!==A}}),W("Array.prototype.includes",function(h){return h||function(N,A){var Q=this;Q instanceof String&&(Q=String(Q));var ge=Q.length;for(A=A||0,0>A&&(A=Math.max(A+ge,0));A<ge;A++){var ke=Q[A];if(ke===N||Object.is(ke,N))return!0}return!1}}),W("String.prototype.includes",function(h){return h||function(N,A){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(N instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(N,A||0)!==-1}});var nt=this||self;function ne(h,N){h=h.split(".");var A=nt;h[0]in A||typeof A.execScript>"u"||A.execScript("var "+h[0]);for(var Q;h.length&&(Q=h.shift());)h.length||N===void 0?A[Q]&&A[Q]!==Object.prototype[Q]?A=A[Q]:A=A[Q]={}:A[Q]=N}function Ne(h){var N;e:{if((N=nt.navigator)&&(N=N.userAgent))break e;N=""}return N.indexOf(h)!=-1}var Ve=Array.prototype.map?function(h,N){return Array.prototype.map.call(h,N,void 0)}:function(h,N){for(var A=h.length,Q=Array(A),ge=typeof h=="string"?h.split(""):h,ke=0;ke<A;ke++)ke in ge&&(Q[ke]=N.call(void 0,ge[ke],ke,h));return Q},ce={},me=null;function pt(h){var N=h.length,A=3*N/4;A%3?A=Math.floor(A):"=.".indexOf(h[N-1])!=-1&&(A="=.".indexOf(h[N-2])!=-1?A-2:A-1);var Q=new Uint8Array(A),ge=0;return ct(h,function(ke){Q[ge++]=ke}),ge!==A?Q.subarray(0,ge):Q}function ct(h,N){function A(lt){for(;Q<h.length;){var Rt=h.charAt(Q++),zt=me[Rt];if(zt!=null)return zt;if(!/^[\s\xa0]*$/.test(Rt))throw Error("Unknown base64 encoding at char: "+Rt)}return lt}Lt();for(var Q=0;;){var ge=A(-1),ke=A(0),Ie=A(64),He=A(64);if(He===64&&ge===-1)break;N(ge<<2|ke>>4),Ie!=64&&(N(ke<<4&240|Ie>>2),He!=64&&N(Ie<<6&192|He))}}function Lt(){if(!me){me={};for(var h="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),N=["+/=","+/","-_=","-_.","-_"],A=0;5>A;A++){var Q=h.concat(N[A].split(""));ce[A]=Q;for(var ge=0;ge<Q.length;ge++){var ke=Q[ge];me[ke]===void 0&&(me[ke]=ge)}}}}var Nt=typeof Uint8Array<"u",ln=!(Ne("Trident")||Ne("MSIE"))&&typeof nt.btoa=="function";function Sn(h){if(!ln){var N;N===void 0&&(N=0),Lt(),N=ce[N];for(var A=Array(Math.floor(h.length/3)),Q=N[64]||"",ge=0,ke=0;ge<h.length-2;ge+=3){var Ie=h[ge],He=h[ge+1],lt=h[ge+2],Rt=N[Ie>>2];Ie=N[(Ie&3)<<4|He>>4],He=N[(He&15)<<2|lt>>6],lt=N[lt&63],A[ke++]=Rt+Ie+He+lt}switch(Rt=0,lt=Q,h.length-ge){case 2:Rt=h[ge+1],lt=N[(Rt&15)<<2]||Q;case 1:h=h[ge],A[ke]=N[h>>2]+N[(h&3)<<4|Rt>>4]+lt+Q}return A.join("")}for(N="";10240<h.length;)N+=String.fromCharCode.apply(null,h.subarray(0,10240)),h=h.subarray(10240);return N+=String.fromCharCode.apply(null,h),btoa(N)}var tn=RegExp("[-_.]","g");function kn(h){switch(h){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function bn(h){if(!ln)return pt(h);tn.test(h)&&(h=h.replace(tn,kn)),h=atob(h);for(var N=new Uint8Array(h.length),A=0;A<h.length;A++)N[A]=h.charCodeAt(A);return N}var nn;function ps(){return nn||(nn=new Uint8Array(0))}var Xn={},Te=typeof Uint8Array.prototype.slice=="function",Je=0,ft=0;function Ot(h){var N=0>h;h=Math.abs(h);var A=h>>>0;h=Math.floor((h-A)/4294967296),N&&(A=ee(Rn(A,h)),N=A.next().value,h=A.next().value,A=N),Je=A>>>0,ft=h>>>0}var cn=typeof BigInt=="function";function Rn(h,N){return N=~N,h?h=~h+1:N+=1,[h,N]}function Un(h,N){this.i=h>>>0,this.h=N>>>0}function Kn(h){if(!h)return Us||(Us=new Un(0,0));if(!/^-?\d+$/.test(h))return null;if(16>h.length)Ot(Number(h));else if(cn)h=BigInt(h),Je=Number(h&BigInt(4294967295))>>>0,ft=Number(h>>BigInt(32)&BigInt(4294967295));else{var N=+(h[0]==="-");ft=Je=0;for(var A=h.length,Q=N,ge=(A-N)%6+N;ge<=A;Q=ge,ge+=6)Q=Number(h.slice(Q,ge)),ft*=1e6,Je=1e6*Je+Q,4294967296<=Je&&(ft+=Je/4294967296|0,Je%=4294967296);N&&(N=ee(Rn(Je,ft)),h=N.next().value,N=N.next().value,Je=h,ft=N)}return new Un(Je,ft)}var Us;function As(h,N){return Error("Invalid wire type: "+h+" (at position "+N+")")}function _r(){return Error("Failed to read varint, encoding is invalid.")}function Ar(h,N){return Error("Tried to read past the end of the data "+N+" > "+h)}function Ns(){throw Error("Invalid UTF8")}function Jr(h,N){return N=String.fromCharCode.apply(null,N),h==null?N:h+N}var Ys=void 0,eo,bo=typeof TextDecoder<"u",to,ks=typeof TextEncoder<"u",Gr;function hr(h){if(h!==Xn)throw Error("illegal external caller")}function br(h,N){if(hr(N),this.V=h,h!=null&&h.length===0)throw Error("ByteString should be constructed with non-empty values")}function wr(){return Gr||(Gr=new br(null,Xn))}function Ps(h){hr(Xn);var N=h.V;return N=N==null||Nt&&N!=null&&N instanceof Uint8Array?N:typeof N=="string"?bn(N):null,N==null?N:h.V=N}function pr(h){if(typeof h=="string")return{buffer:bn(h),C:!1};if(Array.isArray(h))return{buffer:new Uint8Array(h),C:!1};if(h.constructor===Uint8Array)return{buffer:h,C:!1};if(h.constructor===ArrayBuffer)return{buffer:new Uint8Array(h),C:!1};if(h.constructor===br)return{buffer:Ps(h)||ps(),C:!0};if(h instanceof Uint8Array)return{buffer:new Uint8Array(h.buffer,h.byteOffset,h.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function mn(h,N){this.i=null,this.m=!1,this.h=this.j=this.l=0,le(this,h,N)}function le(h,N,A){A=A===void 0?{}:A,h.S=A.S===void 0?!1:A.S,N&&(N=pr(N),h.i=N.buffer,h.m=N.C,h.l=0,h.j=h.i.length,h.h=h.l)}mn.prototype.reset=function(){this.h=this.l};function Dn(h,N){if(h.h=N,N>h.j)throw Ar(h.j,N)}function wn(h){var N=h.i,A=h.h,Q=N[A++],ge=Q&127;if(Q&128&&(Q=N[A++],ge|=(Q&127)<<7,Q&128&&(Q=N[A++],ge|=(Q&127)<<14,Q&128&&(Q=N[A++],ge|=(Q&127)<<21,Q&128&&(Q=N[A++],ge|=Q<<28,Q&128&&N[A++]&128&&N[A++]&128&&N[A++]&128&&N[A++]&128&&N[A++]&128)))))throw _r();return Dn(h,A),ge}function qs(h,N){if(0>N)throw Error("Tried to read a negative byte length: "+N);var A=h.h,Q=A+N;if(Q>h.j)throw Ar(N,h.j-A);return h.h=Q,A}var ws=[];function ns(){this.h=[]}ns.prototype.length=function(){return this.h.length},ns.prototype.end=function(){var h=this.h;return this.h=[],h};function Pr(h,N,A){for(;0<A||127<N;)h.h.push(N&127|128),N=(N>>>7|A<<25)>>>0,A>>>=7;h.h.push(N)}function ls(h,N){for(;127<N;)h.h.push(N&127|128),N>>>=7;h.h.push(N)}function vr(h,N){if(ws.length){var A=ws.pop();le(A,h,N),h=A}else h=new mn(h,N);this.h=h,this.j=this.h.h,this.i=this.l=-1,this.setOptions(N)}vr.prototype.setOptions=function(h){h=h===void 0?{}:h,this.ca=h.ca===void 0?!1:h.ca},vr.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function Or(h){var N=h.h;if(N.h==N.j)return!1;h.j=h.h.h;var A=wn(h.h)>>>0;if(N=A>>>3,A&=7,!(0<=A&&5>=A))throw As(A,h.j);if(1>N)throw Error("Invalid field number: "+N+" (at position "+h.j+")");return h.l=N,h.i=A,!0}function Os(h){switch(h.i){case 0:if(h.i!=0)Os(h);else e:{h=h.h;for(var N=h.h,A=N+10,Q=h.i;N<A;)if((Q[N++]&128)===0){Dn(h,N);break e}throw _r()}break;case 1:h=h.h,Dn(h,h.h+8);break;case 2:h.i!=2?Os(h):(N=wn(h.h)>>>0,h=h.h,Dn(h,h.h+N));break;case 5:h=h.h,Dn(h,h.h+4);break;case 3:N=h.l;do{if(!Or(h))throw Error("Unmatched start-group tag: stream EOF");if(h.i==4){if(h.l!=N)throw Error("Unmatched end-group tag");break}Os(h)}while(!0);break;default:throw As(h.i,h.j)}}var Qs=[];function Jo(){this.j=[],this.i=0,this.h=new ns}function Zs(h,N){N.length!==0&&(h.j.push(N),h.i+=N.length)}function Ms(h,N){if(N=N.R){Zs(h,h.h.end());for(var A=0;A<N.length;A++)Zs(h,Ps(N[A])||ps())}}var Js=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function Fr(h,N){return Js?h[Js]|=N:h.A!==void 0?h.A|=N:(Object.defineProperties(h,{A:{value:N,configurable:!0,writable:!0,enumerable:!1}}),N)}function Hr(h,N){Js?h[Js]&&(h[Js]&=~N):h.A!==void 0&&(h.A&=~N)}function Zn(h){var N;return Js?N=h[Js]:N=h.A,N??0}function vs(h,N){Js?h[Js]=N:h.A!==void 0?h.A=N:Object.defineProperties(h,{A:{value:N,configurable:!0,writable:!0,enumerable:!1}})}function no(h){return Fr(h,1),h}function Ro(h,N){vs(N,(h|0)&-51)}function Cr(h,N){vs(N,(h|18)&-41)}var Cs={};function fr(h){return h!==null&&typeof h=="object"&&!Array.isArray(h)&&h.constructor===Object}var Sr,so=[];vs(so,23),Sr=Object.freeze(so);function ro(h){if(Zn(h.o)&2)throw Error("Cannot mutate an immutable Message")}function wo(h){var N=h.length;(N=N?h[N-1]:void 0)&&fr(N)?N.g=1:(N={},h.push((N.g=1,N)))}function oo(h){var N=h.i+h.G;return h.B||(h.B=h.o[N]={})}function js(h,N){return N===-1?null:N>=h.i?h.B?h.B[N]:void 0:h.o[N+h.G]}function er(h,N,A,Q){ro(h),Br(h,N,A,Q)}function Br(h,N,A,Q){h.j&&(h.j=void 0),N>=h.i||Q?oo(h)[N]=A:(h.o[N+h.G]=A,(h=h.B)&&N in h&&delete h[N])}function tr(h,N,A,Q){var ge=js(h,N);Array.isArray(ge)||(ge=Sr);var ke=Zn(ge);if(ke&1||no(ge),Q)ke&2||Fr(ge,2),A&1||Object.freeze(ge);else{Q=!(A&2);var Ie=ke&2;A&1||!Ie?Q&&ke&16&&!Ie&&Hr(ge,16):(ge=no(Array.prototype.slice.call(ge)),Br(h,N,ge))}return ge}function Do(h,N){var A=js(h,N),Q=A==null?A:typeof A=="number"||A==="NaN"||A==="Infinity"||A==="-Infinity"?Number(A):void 0;return Q!=null&&Q!==A&&Br(h,N,Q),Q}function _o(h,N,A,Q,ge){h.h||(h.h={});var ke=h.h[A],Ie=tr(h,A,3,ge);if(!ke){var He=Ie;ke=[];var lt=!!(Zn(h.o)&16);Ie=!!(Zn(He)&2);var Rt=He;!ge&&Ie&&(He=Array.prototype.slice.call(He));for(var zt=Ie,yn=0;yn<He.length;yn++){var an=He[yn],Xt=N,xn=!1;if(xn=xn===void 0?!1:xn,an=Array.isArray(an)?new Xt(an):xn?new Xt:void 0,an!==void 0){Xt=an.o;var Tn=xn=Zn(Xt);Ie&&(Tn|=2),lt&&(Tn|=16),Tn!=xn&&vs(Xt,Tn),Xt=Tn,zt=zt||!!(2&Xt),ke.push(an)}}return h.h[A]=ke,lt=Zn(He),N=lt|33,N=zt?N&-9:N|8,lt!=N&&(zt=He,Object.isFrozen(zt)&&(zt=Array.prototype.slice.call(zt)),vs(zt,N),He=zt),Rt!==He&&Br(h,A,He),(ge||Q&&Ie)&&Fr(ke,2),Q&&Object.freeze(ke),ke}return ge||(ge=Object.isFrozen(ke),Q&&!ge?Object.freeze(ke):!Q&&ge&&(ke=Array.prototype.slice.call(ke),h.h[A]=ke)),ke}function ao(h,N,A){var Q=!!(Zn(h.o)&2);if(N=_o(h,N,A,Q,Q),h=tr(h,A,3,Q),!(Q||Zn(h)&8)){for(Q=0;Q<N.length;Q++){if(A=N[Q],Zn(A.o)&2){var ge=Ss(A,!1);ge.j=A}else ge=A;A!==ge&&(N[Q]=ge,h[Q]=ge.o)}Fr(h,8)}return N}function ms(h,N,A){if(A!=null&&typeof A!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof A+": "+A);er(h,N,A)}function Ao(h,N,A,Q,ge){ro(h);var ke=_o(h,A,N,!1,!1);return A=Q??new A,h=tr(h,N,2,!1),ge!=null?(ke.splice(ge,0,A),h.splice(ge,0,A.o)):(ke.push(A),h.push(A.o)),A.C()&&Hr(h,8),A}function jr(h,N){return h??N}function Ws(h,N,A){return A=A===void 0?0:A,jr(Do(h,N),A)}var Kr;function zo(h){switch(typeof h){case"number":return isFinite(h)?h:String(h);case"object":if(h)if(Array.isArray(h)){if((Zn(h)&128)!==0)return h=Array.prototype.slice.call(h),wo(h),h}else{if(Nt&&h!=null&&h instanceof Uint8Array)return Sn(h);if(h instanceof br){var N=h.V;return N==null?"":typeof N=="string"?N:h.V=Sn(N)}}}return h}function vo(h,N,A,Q){if(h!=null){if(Array.isArray(h))h=Po(h,N,A,Q!==void 0);else if(fr(h)){var ge={},ke;for(ke in h)ge[ke]=vo(h[ke],N,A,Q);h=ge}else h=N(h,Q);return h}}function Po(h,N,A,Q){var ge=Zn(h);Q=Q?!!(ge&16):void 0,h=Array.prototype.slice.call(h);for(var ke=0;ke<h.length;ke++)h[ke]=vo(h[ke],N,A,Q);return A(ge,h),h}function cs(h){return h.ja===Cs?h.toJSON():zo(h)}function as(h,N){h&128&&wo(N)}function Oo(h,N,A){if(A=A===void 0?Cr:A,h!=null){if(Nt&&h instanceof Uint8Array)return h.length?new br(new Uint8Array(h),Xn):wr();if(Array.isArray(h)){var Q=Zn(h);return Q&2?h:N&&!(Q&32)&&(Q&16||Q===0)?(vs(h,Q|2),h):(h=Po(h,Oo,Q&4?Cr:A,!0),N=Zn(h),N&4&&N&2&&Object.freeze(h),h)}return h.ja===Cs?Co(h):h}}function Lr(h,N,A,Q,ge,ke,Ie){if(h=h.h&&h.h[A]){if(Q=Zn(h),Q&2?Q=h:(ke=Ve(h,Co),Cr(Q,ke),Object.freeze(ke),Q=ke),ro(N),Ie=Q==null?Sr:no([]),Q!=null){for(ke=!!Q.length,h=0;h<Q.length;h++){var He=Q[h];ke=ke&&!(Zn(He.o)&2),Ie[h]=He.o}ke=(ke?8:0)|1,h=Zn(Ie),(h&ke)!==ke&&(Object.isFrozen(Ie)&&(Ie=Array.prototype.slice.call(Ie)),vs(Ie,h|ke)),N.h||(N.h={}),N.h[A]=Q}else N.h&&(N.h[A]=void 0);Br(N,A,Ie,ge)}else er(N,A,Oo(Q,ke,Ie),ge)}function Co(h){return Zn(h.o)&2||(h=Ss(h,!0),Fr(h.o,2)),h}function Ss(h,N){var A=h.o,Q=[];Fr(Q,16);var ge=h.constructor.h;if(ge&&Q.push(ge),ge=h.B,ge){Q.length=A.length,Q.fill(void 0,Q.length,A.length);var ke={};Q[Q.length-1]=ke}(Zn(A)&128)!==0&&wo(Q),N=N||h.C()?Cr:Ro,ke=h.constructor,Kr=Q,Q=new ke(Q),Kr=void 0,h.R&&(Q.R=h.R.slice()),ke=!!(Zn(A)&16);for(var Ie=ge?A.length-1:A.length,He=0;He<Ie;He++)Lr(h,Q,He-h.G,A[He],!1,ke,N);if(ge)for(var lt in ge)Lr(h,Q,+lt,ge[lt],!0,ke,N);return Q}function fs(h,N,A){h==null&&(h=Kr),Kr=void 0;var Q=this.constructor.i||0,ge=0<Q,ke=this.constructor.h,Ie=!1;if(h==null){h=ke?[ke]:[];var He=48,lt=!0;ge&&(Q=0,He|=128),vs(h,He)}else{if(!Array.isArray(h)||ke&&ke!==h[0])throw Error();var Rt=He=Fr(h,0);if((lt=(16&Rt)!==0)&&((Ie=(32&Rt)!==0)||(Rt|=32)),ge){if(128&Rt)Q=0;else if(0<h.length){var zt=h[h.length-1];if(fr(zt)&&"g"in zt){Q=0,Rt|=128,delete zt.g;var yn=!0,an;for(an in zt){yn=!1;break}yn&&h.pop()}}}else if(128&Rt)throw Error();He!==Rt&&vs(h,Rt)}this.G=(ke?0:-1)-Q,this.h=void 0,this.o=h;e:{if(ke=this.o.length,Q=ke-1,ke&&(ke=this.o[Q],fr(ke))){this.B=ke,this.i=Q-this.G;break e}N!==void 0&&-1<N?(this.i=Math.max(N,Q+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!ge&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(A){N=lt&&!Ie&&!0,ge=this.i;var Xt;for(lt=0;lt<A.length;lt++)Ie=A[lt],Ie<ge?(Ie+=this.G,(Q=h[Ie])?uo(Q,N):h[Ie]=Sr):(Xt||(Xt=oo(this)),(Q=Xt[Ie])?uo(Q,N):Xt[Ie]=Sr)}}fs.prototype.toJSON=function(){return Po(this.o,cs,as)},fs.prototype.C=function(){return!!(Zn(this.o)&2)};function uo(h,N){if(Array.isArray(h)){var A=Zn(h),Q=1;!N||A&2||(Q|=16),(A&Q)!==Q&&vs(h,A|Q)}}fs.prototype.ja=Cs,fs.prototype.toString=function(){return this.o.toString()};function An(h,N,A){if(A){var Q={},ge;for(ge in A){var ke=A[ge],Ie=ke.ra;Ie||(Q.J=ke.xa||ke.oa.W,ke.ia?(Q.aa=Jn(ke.ia),Ie=function(He){return function(lt,Rt,zt){return He.J(lt,Rt,zt,He.aa)}}(Q)):ke.ka?(Q.Z=Er(ke.da.P,ke.ka),Ie=function(He){return function(lt,Rt,zt){return He.J(lt,Rt,zt,He.Z)}}(Q)):Ie=Q.J,ke.ra=Ie),Ie(N,h,ke.da),Q={J:Q.J,aa:Q.aa,Z:Q.Z}}}Ms(N,h)}var Ur=Symbol();function ar(h,N,A){return h[Ur]||(h[Ur]=function(Q,ge){return N(Q,ge,A)})}function nr(h){var N=h[Ur];if(!N){var A=Oe(h);N=function(Q,ge){return st(Q,ge,A)},h[Ur]=N}return N}function ir(h){var N=h.ia;if(N)return nr(N);if(N=h.wa)return ar(h.da.P,N,h.ka)}function So(h){var N=ir(h),A=h.da,Q=h.oa.U;return N?function(ge,ke){return Q(ge,ke,A,N)}:function(ge,ke){return Q(ge,ke,A)}}function Mr(h,N){var A=h[N];return typeof A=="function"&&A.length===0&&(A=A(),h[N]=A),Array.isArray(A)&&(Ee in A||Wr in A||0<A.length&&typeof A[0]=="function")?A:void 0}function Ye(h,N,A,Q,ge,ke){N.P=h[0];var Ie=1;if(h.length>Ie&&typeof h[Ie]!="number"){var He=h[Ie++];A(N,He)}for(;Ie<h.length;){A=h[Ie++];for(var lt=Ie+1;lt<h.length&&typeof h[lt]!="number";)lt++;switch(He=h[Ie++],lt-=Ie,lt){case 0:Q(N,A,He);break;case 1:(lt=Mr(h,Ie))?(Ie++,ge(N,A,He,lt)):Q(N,A,He,h[Ie++]);break;case 2:lt=Ie++,lt=Mr(h,lt),ge(N,A,He,lt,h[Ie++]);break;case 3:ke(N,A,He,h[Ie++],h[Ie++],h[Ie++]);break;case 4:ke(N,A,He,h[Ie++],h[Ie++],h[Ie++],h[Ie++]);break;default:throw Error("unexpected number of binary field arguments: "+lt)}}return N}var Ir=Symbol();function Jn(h){var N=h[Ir];if(!N){var A=de(h);N=function(Q,ge){return ut(Q,ge,A)},h[Ir]=N}return N}function Er(h,N){var A=h[Ir];return A||(A=function(Q,ge){return An(Q,ge,N)},h[Ir]=A),A}var Wr=Symbol();function Fs(h,N){h.push(N)}function ur(h,N,A){h.push(N,A.W)}function Se(h,N,A,Q){var ge=Jn(Q),ke=de(Q).P,Ie=A.W;h.push(N,function(He,lt,Rt){return Ie(He,lt,Rt,ke,ge)})}function fe(h,N,A,Q,ge,ke){var Ie=Er(Q,ke),He=A.W;h.push(N,function(lt,Rt,zt){return He(lt,Rt,zt,Q,Ie)})}function de(h){var N=h[Wr];return N||(N=Ye(h,h[Wr]=[],Fs,ur,Se,fe),Ee in h&&Wr in h&&(h.length=0),N)}var Ee=Symbol();function Ae(h,N){h[0]=N}function Pe(h,N,A,Q){var ge=A.U;h[N]=Q?function(ke,Ie,He){return ge(ke,Ie,He,Q)}:ge}function We(h,N,A,Q,ge){var ke=A.U,Ie=nr(Q),He=Oe(Q).P;h[N]=function(lt,Rt,zt){return ke(lt,Rt,zt,He,Ie,ge)}}function je(h,N,A,Q,ge,ke,Ie){var He=A.U,lt=ar(Q,ge,ke);h[N]=function(Rt,zt,yn){return He(Rt,zt,yn,Q,lt,Ie)}}function Oe(h){var N=h[Ee];return N||(N=Ye(h,h[Ee]={},Ae,Pe,We,je),Ee in h&&Wr in h&&(h.length=0),N)}function st(h,N,A){for(;Or(N)&&N.i!=4;){var Q=N.l,ge=A[Q];if(!ge){var ke=A[0];ke&&(ke=ke[Q])&&(ge=A[Q]=So(ke))}if(!ge||!ge(N,h,Q)){ge=N,Q=h,ke=ge.j,Os(ge);var Ie=ge;if(!Ie.ca){if(ge=Ie.h.h-ke,Ie.h.h=ke,Ie=Ie.h,ge==0)ge=wr();else{if(ke=qs(Ie,ge),Ie.S&&Ie.m)ge=Ie.i.subarray(ke,ke+ge);else{Ie=Ie.i;var He=ke;ge=ke+ge,ge=He===ge?ps():Te?Ie.slice(He,ge):new Uint8Array(Ie.subarray(He,ge))}ge=ge.length==0?wr():new br(ge,Xn)}(ke=Q.R)?ke.push(ge):Q.R=[ge]}}}return h}function ut(h,N,A){for(var Q=A.length,ge=Q%2==1,ke=ge?1:0;ke<Q;ke+=2)(0,A[ke+1])(N,h,A[ke]);An(h,N,ge?A[0]:void 0)}function tt(h,N){return{U:h,W:N}}var yt=tt(function(h,N,A){if(h.i!==5)return!1;h=h.h;var Q=h.i,ge=h.h,ke=Q[ge],Ie=Q[ge+1],He=Q[ge+2];return Q=Q[ge+3],Dn(h,h.h+4),Ie=(ke<<0|Ie<<8|He<<16|Q<<24)>>>0,h=2*(Ie>>31)+1,ke=Ie>>>23&255,Ie&=8388607,er(N,A,ke==255?Ie?NaN:1/0*h:ke==0?h*Math.pow(2,-149)*Ie:h*Math.pow(2,ke-150)*(Ie+Math.pow(2,23))),!0},function(h,N,A){if(N=Do(N,A),N!=null){ls(h.h,8*A+5),h=h.h;var Q=+N;Q===0?0<1/Q?Je=ft=0:(ft=0,Je=2147483648):isNaN(Q)?(ft=0,Je=2147483647):(Q=(A=0>Q?-2147483648:0)?-Q:Q,34028234663852886e22<Q?(ft=0,Je=(A|2139095040)>>>0):11754943508222875e-54>Q?(Q=Math.round(Q/Math.pow(2,-149)),ft=0,Je=(A|Q)>>>0):(N=Math.floor(Math.log(Q)/Math.LN2),Q*=Math.pow(2,-N),Q=Math.round(8388608*Q),16777216<=Q&&++N,ft=0,Je=(A|N+127<<23|Q&8388607)>>>0)),A=Je,h.h.push(A>>>0&255),h.h.push(A>>>8&255),h.h.push(A>>>16&255),h.h.push(A>>>24&255)}}),At=tt(function(h,N,A){if(h.i!==0)return!1;var Q=h.h,ge=0,ke=h=0,Ie=Q.i,He=Q.h;do{var lt=Ie[He++];ge|=(lt&127)<<ke,ke+=7}while(32>ke&&lt&128);for(32<ke&&(h|=(lt&127)>>4),ke=3;32>ke&&lt&128;ke+=7)lt=Ie[He++],h|=(lt&127)<<ke;if(Dn(Q,He),128>lt)Q=ge>>>0,lt=h>>>0,(h=lt&2147483648)&&(Q=~Q+1>>>0,lt=~lt>>>0,Q==0&&(lt=lt+1>>>0)),Q=4294967296*lt+(Q>>>0);else throw _r();return er(N,A,h?-Q:Q),!0},function(h,N,A){N=js(N,A),N!=null&&(typeof N=="string"&&Kn(N),N!=null&&(ls(h.h,8*A),typeof N=="number"?(h=h.h,Ot(N),Pr(h,Je,ft)):(A=Kn(N),Pr(h.h,A.i,A.h))))}),xt=tt(function(h,N,A){return h.i!==0?!1:(er(N,A,wn(h.h)),!0)},function(h,N,A){if(N=js(N,A),N!=null&&N!=null)if(ls(h.h,8*A),h=h.h,A=N,0<=A)ls(h,A);else{for(N=0;9>N;N++)h.h.push(A&127|128),A>>=7;h.h.push(1)}}),Qt=tt(function(h,N,A){if(h.i!==2)return!1;var Q=wn(h.h)>>>0;h=h.h;var ge=qs(h,Q);if(h=h.i,bo){var ke=h,Ie;(Ie=eo)||(Ie=eo=new TextDecoder("utf-8",{fatal:!0})),h=ge+Q,ke=ge===0&&h===ke.length?ke:ke.subarray(ge,h);try{var He=Ie.decode(ke)}catch(yn){if(Ys===void 0){try{Ie.decode(new Uint8Array([128]))}catch{}try{Ie.decode(new Uint8Array([97])),Ys=!0}catch{Ys=!1}}throw!Ys&&(eo=void 0),yn}}else{He=ge,Q=He+Q,ge=[];for(var lt=null,Rt,zt;He<Q;)Rt=h[He++],128>Rt?ge.push(Rt):224>Rt?He>=Q?Ns():(zt=h[He++],194>Rt||(zt&192)!==128?(He--,Ns()):ge.push((Rt&31)<<6|zt&63)):240>Rt?He>=Q-1?Ns():(zt=h[He++],(zt&192)!==128||Rt===224&&160>zt||Rt===237&&160<=zt||((ke=h[He++])&192)!==128?(He--,Ns()):ge.push((Rt&15)<<12|(zt&63)<<6|ke&63)):244>=Rt?He>=Q-2?Ns():(zt=h[He++],(zt&192)!==128||(Rt<<28)+(zt-144)>>30!==0||((ke=h[He++])&192)!==128||((Ie=h[He++])&192)!==128?(He--,Ns()):(Rt=(Rt&7)<<18|(zt&63)<<12|(ke&63)<<6|Ie&63,Rt-=65536,ge.push((Rt>>10&1023)+55296,(Rt&1023)+56320))):Ns(),8192<=ge.length&&(lt=Jr(lt,ge),ge.length=0);He=Jr(lt,ge)}return er(N,A,He),!0},function(h,N,A){if(N=js(N,A),N!=null){var Q=!1;if(Q=Q===void 0?!1:Q,ks){if(Q&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(N))throw Error("Found an unpaired surrogate");N=(to||(to=new TextEncoder)).encode(N)}else{for(var ge=0,ke=new Uint8Array(3*N.length),Ie=0;Ie<N.length;Ie++){var He=N.charCodeAt(Ie);if(128>He)ke[ge++]=He;else{if(2048>He)ke[ge++]=He>>6|192;else{if(55296<=He&&57343>=He){if(56319>=He&&Ie<N.length){var lt=N.charCodeAt(++Ie);if(56320<=lt&&57343>=lt){He=1024*(He-55296)+lt-56320+65536,ke[ge++]=He>>18|240,ke[ge++]=He>>12&63|128,ke[ge++]=He>>6&63|128,ke[ge++]=He&63|128;continue}else Ie--}if(Q)throw Error("Found an unpaired surrogate");He=65533}ke[ge++]=He>>12|224,ke[ge++]=He>>6&63|128}ke[ge++]=He&63|128}}N=ge===ke.length?ke:ke.subarray(0,ge)}ls(h.h,8*A+2),ls(h.h,N.length),Zs(h,h.h.end()),Zs(h,N)}}),gt=tt(function(h,N,A,Q,ge){if(h.i!==2)return!1;N=Ao(N,A,Q),A=h.h.j,Q=wn(h.h)>>>0;var ke=h.h.h+Q,Ie=ke-A;if(0>=Ie&&(h.h.j=ke,ge(N,h,void 0,void 0,void 0),Ie=ke-h.h.h),Ie)throw Error("Message parsing ended unexpectedly. Expected to read "+(Q+" bytes, instead read "+(Q-Ie)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return h.h.h=ke,h.h.j=A,!0},function(h,N,A,Q,ge){if(N=ao(N,Q,A),N!=null)for(Q=0;Q<N.length;Q++){var ke=h;ls(ke.h,8*A+2);var Ie=ke.h.end();Zs(ke,Ie),Ie.push(ke.i),ke=Ie,ge(N[Q],h),Ie=h;var He=ke.pop();for(He=Ie.i+Ie.h.length()-He;127<He;)ke.push(He&127|128),He>>>=7,Ie.i++;ke.push(He),Ie.i++}});function Ct(h){return function(N,A){e:{if(Qs.length){var Q=Qs.pop();Q.setOptions(A),le(Q.h,N,A),N=Q}else N=new vr(N,A);try{var ge=Oe(h),ke=st(new ge.P,N,ge);break e}finally{ge=N.h,ge.i=null,ge.m=!1,ge.l=0,ge.j=0,ge.h=0,ge.S=!1,N.l=-1,N.i=-1,100>Qs.length&&Qs.push(N)}ke=void 0}return ke}}function Pt(h){return function(){var N=new Jo;ut(this,N,de(h)),Zs(N,N.h.end());for(var A=new Uint8Array(N.i),Q=N.j,ge=Q.length,ke=0,Ie=0;Ie<ge;Ie++){var He=Q[Ie];A.set(He,ke),ke+=He.length}return N.j=[A],A}}function fn(h){fs.call(this,h)}ht(fn,fs);var pn=[fn,1,xt,2,yt,3,Qt,4,Qt];fn.prototype.l=Pt(pn);function Pn(h){fs.call(this,h,-1,Jt)}ht(Pn,fs),Pn.prototype.addClassification=function(h,N){return Ao(this,1,fn,h,N),this};var Jt=[1],Cn=Ct([Pn,1,gt,pn]);function Hn(h){fs.call(this,h)}ht(Hn,fs);var kt=[Hn,1,yt,2,yt,3,yt,4,yt,5,yt];Hn.prototype.l=Pt(kt);function Tr(h){fs.call(this,h,-1,Vr)}ht(Tr,fs);var Vr=[1],lo=Ct([Tr,1,gt,kt]);function Xr(h){fs.call(this,h)}ht(Xr,fs);var Io=[Xr,1,yt,2,yt,3,yt,4,yt,5,yt,6,At],co=Ct(Io);Xr.prototype.l=Pt(Io);function zr(h,N,A){if(A=h.createShader(A===0?h.VERTEX_SHADER:h.FRAGMENT_SHADER),h.shaderSource(A,N),h.compileShader(A),!h.getShaderParameter(A,h.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+h.getShaderInfoLog(A));return A}function Wn(h){return ao(h,fn,1).map(function(N){var A=js(N,1);return{index:A??0,qa:Ws(N,2),label:js(N,3)!=null?jr(js(N,3),""):void 0,displayName:js(N,4)!=null?jr(js(N,4),""):void 0}})}function ea(h){return{x:Ws(h,1),y:Ws(h,2),z:Ws(h,3),visibility:Do(h,4)!=null?Ws(h,4):void 0}}function Fo(h){return ao(lo(h),Hn,1).map(ea)}function lr(h,N){this.i=h,this.h=N,this.m=0}function Go(h,N,A){return Ho(h,N),typeof h.h.canvas.transferToImageBitmap=="function"?Promise.resolve(h.h.canvas.transferToImageBitmap()):A?Promise.resolve(h.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(h.h.canvas):(h.j===void 0&&(h.j=document.createElement("canvas")),new Promise(function(Q){h.j.height=h.h.canvas.height,h.j.width=h.h.canvas.width,h.j.getContext("2d",{}).drawImage(h.h.canvas,0,0,h.h.canvas.width,h.h.canvas.height),Q(h.j)}))}function Ho(h,N){var A=h.h;if(h.s===void 0){var Q=zr(A,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),ge=zr(A,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),ke=A.createProgram();if(A.attachShader(ke,Q),A.attachShader(ke,ge),A.linkProgram(ke),!A.getProgramParameter(ke,A.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+A.getProgramInfoLog(ke));Q=h.s=ke,A.useProgram(Q),ge=A.getUniformLocation(Q,"sampler0"),h.l={O:A.getAttribLocation(Q,"aVertex"),N:A.getAttribLocation(Q,"aTex"),ya:ge},h.v=A.createBuffer(),A.bindBuffer(A.ARRAY_BUFFER,h.v),A.enableVertexAttribArray(h.l.O),A.vertexAttribPointer(h.l.O,2,A.FLOAT,!1,0,0),A.bufferData(A.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),A.STATIC_DRAW),A.bindBuffer(A.ARRAY_BUFFER,null),h.u=A.createBuffer(),A.bindBuffer(A.ARRAY_BUFFER,h.u),A.enableVertexAttribArray(h.l.N),A.vertexAttribPointer(h.l.N,2,A.FLOAT,!1,0,0),A.bufferData(A.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),A.STATIC_DRAW),A.bindBuffer(A.ARRAY_BUFFER,null),A.uniform1i(ge,0)}Q=h.l,A.useProgram(h.s),A.canvas.width=N.width,A.canvas.height=N.height,A.viewport(0,0,N.width,N.height),A.activeTexture(A.TEXTURE0),h.i.bindTexture2d(N.glName),A.enableVertexAttribArray(Q.O),A.bindBuffer(A.ARRAY_BUFFER,h.v),A.vertexAttribPointer(Q.O,2,A.FLOAT,!1,0,0),A.enableVertexAttribArray(Q.N),A.bindBuffer(A.ARRAY_BUFFER,h.u),A.vertexAttribPointer(Q.N,2,A.FLOAT,!1,0,0),A.bindFramebuffer(A.DRAW_FRAMEBUFFER?A.DRAW_FRAMEBUFFER:A.FRAMEBUFFER,null),A.clearColor(0,0,0,0),A.clear(A.COLOR_BUFFER_BIT),A.colorMask(!0,!0,!0,!0),A.drawArrays(A.TRIANGLE_FAN,0,4),A.disableVertexAttribArray(Q.O),A.disableVertexAttribArray(Q.N),A.bindBuffer(A.ARRAY_BUFFER,null),h.i.bindTexture2d(0)}function Rs(h){this.h=h}var Eo=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function $r(h,N){return N+h}function Bo(h,N){window[h]=N}function ho(h){var N=document.createElement("script");return N.setAttribute("src",h),N.setAttribute("crossorigin","anonymous"),new Promise(function(A){N.addEventListener("load",function(){A()},!1),N.addEventListener("error",function(){A()},!1),document.body.appendChild(N)})}function Ha(){return Be(function(h){switch(h.h){case 1:return h.s=2,ve(h,WebAssembly.instantiate(Eo),4);case 4:h.h=3,h.s=0;break;case 2:return h.s=0,h.l=null,h.return(!1);case 3:return h.return(!0)}})}function Ut(h){if(this.h=h,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=h&&h.locateFile||$r,typeof window=="object")var N=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")N=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=N,h.options){N=ee(Object.keys(h.options));for(var A=N.next();!A.done;A=N.next()){A=A.value;var Q=h.options[A].default;Q!==void 0&&(this.l[A]=typeof Q=="function"?Q():Q)}}}p=Ut.prototype,p.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function ta(h){var N,A,Q,ge,ke,Ie,He,lt,Rt,zt,yn;return Be(function(an){switch(an.h){case 1:return h.ga?(N=h.h.files===void 0?[]:typeof h.h.files=="function"?h.h.files(h.l):h.h.files,ve(an,Ha(),2)):an.return();case 2:if(A=an.i,typeof window=="object")return Bo("createMediapipeSolutionsWasm",{locateFile:h.locateFile}),Bo("createMediapipeSolutionsPackedAssets",{locateFile:h.locateFile}),Ie=N.filter(function(Xt){return Xt.data!==void 0}),He=N.filter(function(Xt){return Xt.data===void 0}),lt=Promise.all(Ie.map(function(Xt){var xn=Gt(h,Xt.url);if(Xt.path!==void 0){var Tn=Xt.path;xn=xn.then(function(ss){return h.overrideFile(Tn,ss),Promise.resolve(ss)})}return xn})),Rt=Promise.all(He.map(function(Xt){return Xt.simd===void 0||Xt.simd&&A||!Xt.simd&&!A?ho(h.locateFile(Xt.url,h.ha)):Promise.resolve()})).then(function(){var Xt,xn,Tn;return Be(function(ss){if(ss.h==1)return Xt=window.createMediapipeSolutionsWasm,xn=window.createMediapipeSolutionsPackedAssets,Tn=h,ve(ss,Xt(xn),2);Tn.i=ss.i,ss.h=0})}),zt=function(){return Be(function(Xt){return h.h.graph&&h.h.graph.url?Xt=ve(Xt,Gt(h,h.h.graph.url),0):(Xt.h=0,Xt=void 0),Xt})}(),ve(an,Promise.all([Rt,lt,zt]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return Q=N.filter(function(Xt){return Xt.simd===void 0||Xt.simd&&A||!Xt.simd&&!A}).map(function(Xt){return h.locateFile(Xt.url,h.ha)}),importScripts.apply(null,we(Q)),ge=h,ve(an,createMediapipeSolutionsWasm(Module),6);case 6:ge.i=an.i,h.m=new OffscreenCanvas(1,1),h.i.canvas=h.m,ke=h.i.GL.createContext(h.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),h.i.GL.makeContextCurrent(ke),an.h=4;break;case 7:if(h.m=document.createElement("canvas"),yn=h.m.getContext("webgl2",{}),!yn&&(yn=h.m.getContext("webgl",{}),!yn))return alert("Failed to create WebGL canvas context when passing video frame."),an.return();h.K=yn,h.i.canvas=h.m,h.i.createContext(h.m,!0,!0,{});case 4:h.j=new h.i.SolutionWasm,h.ga=!1,an.h=0}})}function To(h){var N,A,Q,ge,ke,Ie,He,lt;return Be(function(Rt){if(Rt.h==1){if(h.h.graph&&h.h.graph.url&&h.fa===h.h.graph.url)return Rt.return();if(h.u=!0,!h.h.graph||!h.h.graph.url){Rt.h=2;return}return h.fa=h.h.graph.url,ve(Rt,Gt(h,h.h.graph.url),3)}for(Rt.h!=2&&(N=Rt.i,h.j.loadGraph(N)),A=ee(Object.keys(h.D)),Q=A.next();!Q.done;Q=A.next())ge=Q.value,h.j.overrideFile(ge,h.D[ge]);if(h.D={},h.h.listeners)for(ke=ee(h.h.listeners),Ie=ke.next();!Ie.done;Ie=ke.next())He=Ie.value,mr(h,He);lt=h.l,h.l={},h.setOptions(lt),Rt.h=0})}p.reset=function(){var h=this;return Be(function(N){h.j&&(h.j.reset(),h.s={},h.v={}),N.h=0})},p.setOptions=function(h,N){var A=this;if(N=N||this.h.options){for(var Q=[],ge=[],ke={},Ie=ee(Object.keys(h)),He=Ie.next();!He.done;ke={X:ke.X,Y:ke.Y},He=Ie.next())if(He=He.value,!(He in this.l&&this.l[He]===h[He])){this.l[He]=h[He];var lt=N[He];lt!==void 0&&(lt.onChange&&(ke.X=lt.onChange,ke.Y=h[He],Q.push(function(Rt){return function(){var zt;return Be(function(yn){if(yn.h==1)return ve(yn,Rt.X(Rt.Y),2);zt=yn.i,zt===!0&&(A.u=!0),yn.h=0})}}(ke))),lt.graphOptionXref&&(He=Object.assign({},{calculatorName:"",calculatorIndex:0},lt.graphOptionXref,{valueNumber:lt.type===1?h[He]:0,valueBoolean:lt.type===0?h[He]:!1,valueString:lt.type===2?h[He]:""}),ge.push(He)))}(Q.length!==0||ge.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(ge),this.F=(this.F===void 0?[]:this.F).concat(Q))}};function ma(h){var N,A,Q,ge,ke,Ie,He;return Be(function(lt){switch(lt.h){case 1:if(!h.u)return lt.return();if(!h.F){lt.h=2;break}N=ee(h.F),A=N.next();case 3:if(A.done){lt.h=5;break}return Q=A.value,ve(lt,Q(),4);case 4:A=N.next(),lt.h=3;break;case 5:h.F=void 0;case 2:if(h.H){for(ge=new h.i.GraphOptionChangeRequestList,ke=ee(h.H),Ie=ke.next();!Ie.done;Ie=ke.next())He=Ie.value,ge.push_back(He);h.j.changeOptions(ge),ge.delete(),h.H=void 0}h.u=!1,lt.h=0}})}p.initialize=function(){var h=this;return Be(function(N){return N.h==1?ve(N,ta(h),2):N.h!=3?ve(N,To(h),3):ve(N,ma(h),0)})};function Gt(h,N){var A,Q;return Be(function(ge){return N in h.L?ge.return(h.L[N]):(A=h.locateFile(N,""),Q=fetch(A).then(function(ke){return ke.arrayBuffer()}),h.L[N]=Q,ge.return(Q))})}p.overrideFile=function(h,N){this.j?this.j.overrideFile(h,N):this.D[h]=N},p.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},p.send=function(h,N){var A=this,Q,ge,ke,Ie,He,lt,Rt,zt,yn;return Be(function(an){switch(an.h){case 1:return A.h.inputs?(Q=1e3*(N??performance.now()),ve(an,A.I,2)):an.return();case 2:return ve(an,A.initialize(),3);case 3:for(ge=new A.i.PacketDataList,ke=ee(Object.keys(h)),Ie=ke.next();!Ie.done;Ie=ke.next())if(He=Ie.value,lt=A.h.inputs[He]){e:{var Xt=h[He];switch(lt.type){case"video":var xn=A.s[lt.stream];if(xn||(xn=new lr(A.i,A.K),A.s[lt.stream]=xn),xn.m===0&&(xn.m=xn.i.createTexture()),typeof HTMLVideoElement<"u"&&Xt instanceof HTMLVideoElement)var Tn=Xt.videoWidth,ss=Xt.videoHeight;else typeof HTMLImageElement<"u"&&Xt instanceof HTMLImageElement?(Tn=Xt.naturalWidth,ss=Xt.naturalHeight):(Tn=Xt.width,ss=Xt.height);ss={glName:xn.m,width:Tn,height:ss},Tn=xn.h,Tn.canvas.width=ss.width,Tn.canvas.height=ss.height,Tn.activeTexture(Tn.TEXTURE0),xn.i.bindTexture2d(xn.m),Tn.texImage2D(Tn.TEXTURE_2D,0,Tn.RGBA,Tn.RGBA,Tn.UNSIGNED_BYTE,Xt),xn.i.bindTexture2d(0),xn=ss;break e;case"detections":for(xn=A.s[lt.stream],xn||(xn=new Rs(A.i),A.s[lt.stream]=xn),xn.data||(xn.data=new xn.h.DetectionListData),xn.data.reset(Xt.length),ss=0;ss<Xt.length;++ss){Tn=Xt[ss];var Yn=xn.data,gs=Yn.setBoundingBox,cr=ss,Is=Tn.la,Fn=new Xr;if(ms(Fn,1,Is.sa),ms(Fn,2,Is.ta),ms(Fn,3,Is.height),ms(Fn,4,Is.width),ms(Fn,5,Is.rotation),er(Fn,6,Is.pa),Is=Fn.l(),gs.call(Yn,cr,Is),Tn.ea)for(Yn=0;Yn<Tn.ea.length;++Yn){Fn=Tn.ea[Yn],gs=xn.data,cr=gs.addNormalizedLandmark,Is=ss,Fn=Object.assign({},Fn,{visibility:Fn.visibility?Fn.visibility:0});var Es=new Hn;ms(Es,1,Fn.x),ms(Es,2,Fn.y),ms(Es,3,Fn.z),Fn.visibility&&ms(Es,4,Fn.visibility),Fn=Es.l(),cr.call(gs,Is,Fn)}if(Tn.ba)for(Yn=0;Yn<Tn.ba.length;++Yn)gs=xn.data,cr=gs.addClassification,Is=ss,Fn=Tn.ba[Yn],Es=new fn,ms(Es,2,Fn.qa),Fn.index&&er(Es,1,Fn.index),Fn.label&&er(Es,3,Fn.label),Fn.displayName&&er(Es,4,Fn.displayName),Fn=Es.l(),cr.call(gs,Is,Fn)}xn=xn.data;break e;default:xn={}}}switch(Rt=xn,zt=lt.stream,lt.type){case"video":ge.pushTexture2d(Object.assign({},Rt,{stream:zt,timestamp:Q}));break;case"detections":yn=Rt,yn.stream=zt,yn.timestamp=Q,ge.pushDetectionList(yn);break;default:throw Error("Unknown input config type: '"+lt.type+"'")}}return A.j.send(ge),ve(an,A.I,4);case 4:ge.delete(),an.h=0}})};function Nr(h,N,A){var Q,ge,ke,Ie,He,lt,Rt,zt,yn,an,Xt,xn,Tn,ss;return Be(function(Yn){switch(Yn.h){case 1:if(!A)return Yn.return(N);for(Q={},ge=0,ke=ee(Object.keys(A)),Ie=ke.next();!Ie.done;Ie=ke.next())He=Ie.value,lt=A[He],typeof lt!="string"&&lt.type==="texture"&&N[lt.stream]!==void 0&&++ge;1<ge&&(h.M=!1),Rt=ee(Object.keys(A)),Ie=Rt.next();case 2:if(Ie.done){Yn.h=4;break}if(zt=Ie.value,yn=A[zt],typeof yn=="string")return Tn=Q,ss=zt,ve(Yn,ga(h,zt,N[yn]),14);if(an=N[yn.stream],yn.type==="detection_list"){if(an){for(var gs=an.getRectList(),cr=an.getLandmarksList(),Is=an.getClassificationsList(),Fn=[],Es=0;Es<gs.size();++Es){var os=co(gs.get(Es)),Ta=Ws(os,1),$a=Ws(os,2),ya=Ws(os,3),jo=Ws(os,4),$o=Ws(os,5,0),kr=void 0;kr=kr===void 0?0:kr,os={la:{sa:Ta,ta:$a,height:ya,width:jo,rotation:$o,pa:jr(js(os,6),kr)},ea:Fo(cr.get(Es)),ba:Wn(Cn(Is.get(Es)))},Fn.push(os)}gs=Fn}else gs=[];Q[zt]=gs,Yn.h=7;break}if(yn.type==="proto_list"){if(an){for(gs=Array(an.size()),cr=0;cr<an.size();cr++)gs[cr]=an.get(cr);an.delete()}else gs=[];Q[zt]=gs,Yn.h=7;break}if(an===void 0){Yn.h=3;break}if(yn.type==="float_list"){Q[zt]=an,Yn.h=7;break}if(yn.type==="proto"){Q[zt]=an,Yn.h=7;break}if(yn.type!=="texture")throw Error("Unknown output config type: '"+yn.type+"'");return Xt=h.v[zt],Xt||(Xt=new lr(h.i,h.K),h.v[zt]=Xt),ve(Yn,Go(Xt,an,h.M),13);case 13:xn=Yn.i,Q[zt]=xn;case 7:yn.transform&&Q[zt]&&(Q[zt]=yn.transform(Q[zt])),Yn.h=3;break;case 14:Tn[ss]=Yn.i;case 3:Ie=Rt.next(),Yn.h=2;break;case 4:return Yn.return(Q)}})}function ga(h,N,A){var Q;return Be(function(ge){return typeof A=="number"||A instanceof Uint8Array||A instanceof h.i.Uint8BlobList?ge.return(A):A instanceof h.i.Texture2dDataOut?(Q=h.v[N],Q||(Q=new lr(h.i,h.K),h.v[N]=Q),ge.return(Go(Q,A,h.M))):ge.return(void 0)})}function mr(h,N){for(var A=N.name||"$",Q=[].concat(we(N.wants)),ge=new h.i.StringList,ke=ee(N.wants),Ie=ke.next();!Ie.done;Ie=ke.next())ge.push_back(Ie.value);ke=h.i.PacketListener.implement({onResults:function(He){for(var lt={},Rt=0;Rt<N.wants.length;++Rt)lt[Q[Rt]]=He.get(Rt);var zt=h.listeners[A];zt&&(h.I=Nr(h,lt,N.outs).then(function(yn){yn=zt(yn);for(var an=0;an<N.wants.length;++an){var Xt=lt[Q[an]];typeof Xt=="object"&&Xt.hasOwnProperty&&Xt.hasOwnProperty("delete")&&Xt.delete()}yn&&(h.I=yn)}))}}),h.j.attachMultiListener(ge,ke),ge.delete()}p.onResults=function(h,N){this.listeners[N||"$"]=h},ne("Solution",Ut),ne("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"});function gr(h){switch(h===void 0&&(h=0),h){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function na(h){var N=this;h=h||{},this.h=new Ut({locateFile:h.locateFile,files:function(A){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:gr(A.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:Fo},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:Fo},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(A){var Q,ge,ke;return Be(function(Ie){return Ie.h==1?(Q=gr(A),ge="third_party/mediapipe/modules/pose_landmark/"+Q,ve(Ie,Gt(N.h,Q),2)):(ke=Ie.i,N.h.overrideFile(ge,ke),Ie.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}p=na.prototype,p.reset=function(){this.h.reset()},p.close=function(){return this.h.close(),Promise.resolve()},p.onResults=function(h){this.h.onResults(h)},p.initialize=function(){var h=this;return Be(function(N){return ve(N,h.h.initialize(),0)})},p.send=function(h,N){var A=this;return Be(function(Q){return ve(Q,A.h.send(h,N),0)})},p.setOptions=function(h){this.h.setOptions(h)},ne("Pose",na),ne("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),ne("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),ne("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),ne("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),ne("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),ne("VERSION","0.5.1675469404")}).call(this)},1172:function(Wt,dt,L){"use strict";L.r(dt),L.d(dt,{transposeImpl:()=>Fs,lessEqualImpl:()=>Ns,maximumImpl:()=>hr,scatterImpl:()=>Br,sparseFillEmptyRowsImpl:()=>jr,uniqueImpl:()=>ur,stridedSliceImpl:()=>fs,gatherNdImpl:()=>Je,equalImpl:()=>ce,bincountReduceImpl:()=>V,lessImpl:()=>As,notEqualImpl:()=>ls,squaredDifferenceImpl:()=>cs,simpleAbsImpl:()=>ze,stringToHashBucketFastImpl:()=>nr,bincountImpl:()=>Qe,rangeImpl:()=>wo,stringSplitImpl:()=>ar,addImpl:()=>on,raggedTensorToTensorImpl:()=>ro,floorImpl:()=>kn,prodImpl:()=>Os,raggedRangeImpl:()=>Cr,staticRegexReplaceImpl:()=>Lr,sigmoidImpl:()=>tr,tileImpl:()=>Ir,maxImpl:()=>Gr,castImpl:()=>Fe,expImpl:()=>ct,expm1Impl:()=>ln,sliceImpl:()=>ao,bitwiseAndImpl:()=>re,floorDivImpl:()=>ps,sparseSegmentReductionImpl:()=>Kr,rsqrtImpl:()=>oo,ceilImpl:()=>nt,sqrtImpl:()=>zo,stringNGramsImpl:()=>An,negImpl:()=>ws,logImpl:()=>bo,greaterEqualImpl:()=>Un,concatImpl:()=>Ve,greaterImpl:()=>Ot,multiplyImpl:()=>le,minimumImpl:()=>Ps,raggedGatherImpl:()=>no,gatherV2Impl:()=>ft,sparseReshapeImpl:()=>Ws,subImpl:()=>ir,topKImpl:()=>Wr,linSpaceImpl:()=>eo});var p=L(9677);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ze(Se){const fe=new Float32Array(Se.length);for(let de=0;de<Se.length;++de)fe[de]=Math.abs(Se[de]);return fe}const Z=Se=>{const{x:fe}=Se.inputs,de=Se.backend;assertNotComplex(fe,"abs");let Ee=new Float32Array(util.sizeFromShape(fe.shape));const Ae=de.data.get(fe.dataId).values;return Ee=ze(Ae),de.makeOutput(Ee,fe.shape,fe.dtype)},ie=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P(Se){return(fe,de,Ee,Ae,Pe)=>{const We=p.Wap.assertAndGetBroadcastShape(fe,de),je=We.length,Oe=p.D5U.computeStrides(We),st=p.D5U.sizeFromShape(We),ut=p.D5U.getTypedArrayFromDType(Pe,st),tt=fe.length,yt=de.length,At=p.D5U.computeStrides(fe),xt=p.D5U.computeStrides(de),Qt=p.Wap.getBroadcastDims(fe,We),gt=p.Wap.getBroadcastDims(de,We);if(Qt.length+gt.length===0)for(let Ct=0;Ct<ut.length;++Ct)ut[Ct]=Se(Ee[Ct%Ee.length],Ae[Ct%Ae.length]);else for(let Ct=0;Ct<ut.length;++Ct){const Pt=p.D5U.indexToLoc(Ct,je,Oe),fn=Pt.slice(-tt);Qt.forEach(Cn=>fn[Cn]=0);const pn=p.D5U.locToIndex(fn,tt,At),Pn=Pt.slice(-yt);gt.forEach(Cn=>Pn[Cn]=0);const Jt=p.D5U.locToIndex(Pn,yt,xt);ut[Ct]=Se(Ee[pn],Ae[Jt])}return[ut,We]}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W(Se,fe){Array.isArray(Se)||(Se=[Se]),Se.forEach(de=>{de!=null&&p.D5U.assert(de.dtype!=="complex64",()=>`${fe} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pe(Se){const{inputs:fe,backend:de}=Se,{real:Ee,imag:Ae}=fe,Pe=de.data.get(Ee.dataId).values,We=de.data.get(Ae.dataId).values,je=de.makeTensorInfo(Ee.shape,"complex64"),Oe=de.data.get(je.dataId);return Oe.complexTensorInfos={real:de.makeTensorInfo(Ee.shape,"float32",Pe),imag:de.makeTensorInfo(Ae.shape,"float32",We)},je}const ee=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function we(Se,fe,de="float32"){if(de==="complex64"){const Ae=we(Se,fe,"float32"),Pe=we(Se,fe,"float32");return pe({inputs:{real:Ae,imag:Pe},backend:Se})}const Ee=p.D5U.makeZerosTypedArray(p.D5U.sizeFromShape(fe),de);return Se.makeTensorInfo(fe,de,Ee)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xe(Se){const{inputs:fe,backend:de}=Se,{x:Ee}=fe;return de.incRef(Ee.dataId),{dataId:Ee.dataId,shape:Ee.shape,dtype:Ee.dtype}}const K=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _(Se){const{inputs:fe,backend:de}=Se,{input:Ee}=fe,Ae=de.data.get(Ee.dataId).complexTensorInfos.real,Pe=de.data.get(Ae.dataId).values;return de.makeTensorInfo(Ae.shape,Ae.dtype,Pe)}const De=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fe(Se,fe,de,Ee){if(Ee==="int32"){const Ae=Int32Array.from(Se);return[fe,"int32",Ae]}if(Ee==="bool"){const Ae=p.D5U.toTypedArray([0],de),[Pe,We]=P((je,Oe)=>je!==Oe?1:0)(fe,[],Se,Ae,"bool");return[We,"bool",Pe]}throw new Error(`Error in Cast: failed to cast ${de} to ${Ee}`)}function Ke(Se){const{inputs:fe,backend:de,attrs:Ee}=Se,{x:Ae}=fe,{dtype:Pe}=Ee;if(Pe==="complex64"){if(Ae.dtype==="complex64")return xe({inputs:{x:Ae},backend:de});const ut=we(de,Ae.shape,Ae.dtype),tt=Ke({inputs:{x:Ae},backend:de,attrs:{dtype:"float32"}}),yt=pe({inputs:{real:tt,imag:ut},backend:de});return de.disposeIntermediateTensorInfo(ut),de.disposeIntermediateTensorInfo(tt),yt}if(Ae.dtype==="complex64"){const ut=_({inputs:{input:Ae},backend:de}),tt=Ke({inputs:{x:ut},backend:de,attrs:{dtype:Pe}});return de.disposeIntermediateTensorInfo(ut),tt}if(!p.D5U.hasEncodingLoss(Ae.dtype,Pe)){const ut=xe({inputs:{x:Ae},backend:de});return{dataId:ut.dataId,shape:ut.shape,dtype:Pe}}const We=de.data.get(Ae.dataId).values,[je,Oe,st]=Fe(We,Ae.shape,Ae.dtype,Pe);return de.makeTensorInfo(je,Oe,st)}const rt=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ht(Se,fe,de,Ee){return de==null?({inputs:Ae,backend:Pe})=>{const{a:We,b:je}=Ae,Oe=Pe;W([We,je],Se);const st=Oe.data.get(We.dataId).values,ut=Oe.data.get(je.dataId).values,tt=We.dtype==="string"?p.Wap.fromUint8ToStringArray(st):st,yt=We.dtype==="string"?p.Wap.fromUint8ToStringArray(ut):ut,At=Ee||We.dtype,[xt,Qt]=fe(We.shape,je.shape,tt,yt,At);return Oe.makeTensorInfo(Qt,At,xt)}:({inputs:Ae,backend:Pe})=>{const{a:We,b:je}=Ae,Oe=Pe;if(We.dtype==="complex64"||je.dtype==="complex64"){const st=Ke({inputs:{x:We},backend:Oe,attrs:{dtype:"complex64"}}),ut=Oe.data.get(st.dataId),tt=ut.complexTensorInfos.real,yt=ut.complexTensorInfos.imag,At=Oe.data.get(tt.dataId).values,xt=Oe.data.get(yt.dataId).values,Qt=Ke({inputs:{x:je},backend:Oe,attrs:{dtype:"complex64"}}),gt=Oe.data.get(Qt.dataId),Ct=gt.complexTensorInfos.real,Pt=gt.complexTensorInfos.imag,fn=Oe.data.get(Ct.dataId).values,pn=Oe.data.get(Pt.dataId).values,[Pn,Jt,Cn]=de(We.shape,je.shape,At,xt,fn,pn),Hn=Oe.makeTensorInfo(Cn,"float32",Pn),kt=Oe.makeTensorInfo(Cn,"float32",Jt),Tr=pe({inputs:{real:Hn,imag:kt},backend:Oe});return Oe.disposeIntermediateTensorInfo(st),Oe.disposeIntermediateTensorInfo(Qt),Oe.disposeIntermediateTensorInfo(Hn),Oe.disposeIntermediateTensorInfo(kt),Tr}else{const st=Oe.data.get(We.dataId).values,ut=Oe.data.get(je.dataId).values,tt=Ee||We.dtype,[yt,At]=fe(We.shape,je.shape,st,ut,tt);return Oe.makeTensorInfo(At,tt,yt)}}}function Vt(Se){return(fe,de,Ee,Ae,Pe,We)=>{const je=p.Wap.assertAndGetBroadcastShape(fe,de),Oe=p.D5U.sizeFromShape(je),st=je.length,ut=p.D5U.computeStrides(je),tt=p.D5U.getTypedArrayFromDType("float32",Oe),yt=p.D5U.getTypedArrayFromDType("float32",Oe),At=p.Wap.getBroadcastDims(fe,je),xt=p.Wap.getBroadcastDims(de,je),Qt=p.Wap.mergeRealAndImagArrays(Ee,Ae),gt=p.Wap.mergeRealAndImagArrays(Pe,We),Ct=fe.length,Pt=p.D5U.computeStrides(fe),fn=de.length,pn=p.D5U.computeStrides(de);if(At.length+xt.length===0)for(let Pn=0;Pn<tt.length;Pn++){const Jt=Pn%Qt.length,Cn=Pn%gt.length,Hn=Se(Qt[Jt*2],Qt[Jt*2+1],gt[Cn*2],gt[Cn*2+1]);tt[Pn]=Hn.real,yt[Pn]=Hn.imag}else for(let Pn=0;Pn<tt.length;Pn++){const Jt=p.D5U.indexToLoc(Pn,st,ut),Cn=Jt.slice(-Ct);At.forEach(lo=>Cn[lo]=0);const Hn=p.D5U.locToIndex(Cn,Ct,Pt),kt=Jt.slice(-fn);xt.forEach(lo=>kt[lo]=0);const Tr=p.D5U.locToIndex(kt,fn,pn),Vr=Se(Qt[Hn*2],Qt[Hn*2+1],gt[Tr*2],gt[Tr*2+1]);tt[Pn]=Vr.real,yt[Pn]=Vr.imag}return[tt,yt,je]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const on=P((Se,fe)=>Se+fe),$t=Vt((Se,fe,de,Ee)=>({real:Se+de,imag:fe+Ee})),ve=ht(p.mm_,on,$t),y=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qe(Se,fe,de,Ee,Ae){const Pe=p.D5U.sizeFromShape(Ee),We=p.D5U.makeZerosTypedArray(Ae,de);for(let je=0;je<Se.length;je++){const Oe=Se[je];if(Oe<0)throw new Error("Input x must be non-negative!");Oe>=Ae||(Pe>0?We[Oe]+=fe[je]:We[Oe]+=1)}return We}function V(Se,fe,de,Ee=!1){const Ae=Se.shape[0],Pe=Se.shape[1],We=(0,p.f3b)([Ae,de],fe.dtype);for(let je=0;je<Ae;je++)for(let Oe=0;Oe<Pe;Oe++){const st=Se.get(je,Oe);if(st<0)throw new Error("Input x must be non-negative!");st>=de||(Ee?We.set(1,je,st):fe.size>0?We.set(We.get(je,st)+fe.get(je,Oe),je,st):We.set(We.get(je,st)+1,je,st))}return We}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const re=P((Se,fe)=>Se&fe),G=ht(p.hCO,re),Re=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Be(Se){return(fe,de,Ee)=>{const Ae=p.D5U.getArrayFromDType(de,fe.length);for(let Pe=0;Pe<fe.length;++Pe)Ae[Pe]=Se(fe[Pe],Ee);return Ae}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function at(Se,fe,de){const Ee=Be(fe);return S(Se,Ee,de)}function S(Se,fe,de){return({inputs:Ee,attrs:Ae,backend:Pe})=>{const{x:We}=Ee;W(We,Se);const je=Pe,Oe=je.data.get(We.dataId).values;let st;if(We.dtype==="string"){if(!Array.isArray(Oe))throw new Error("String tensor's value was not an instance of Array");st=p.Wap.fromUint8ToStringArray(Oe)}else st=Oe;const ut=de||We.dtype,tt=fe(st,ut,Ae);return je.makeTensorInfo(We.shape,ut,tt)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nt=Be(Se=>Math.ceil(Se)),ne=S(p.gJX,nt),Ne=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ve(Se,fe,de,Ee){const Ae=p.D5U.getArrayFromDType(de,p.D5U.sizeFromShape(fe));if(Ee&&de!=="string"){let Pe=0;Se.forEach(We=>{const je=p.D5U.sizeFromShape(We.shape);Ae.set(We.vals,Pe),Pe+=je})}else{let Pe=0;Se.forEach(We=>{const je=de==="string"?p.Wap.fromUint8ToStringArray(We.vals):We.vals;let Oe=0;for(let st=0;st<We.shape[0];++st){const ut=st*fe[1]+Pe;for(let tt=0;tt<We.shape[1];++tt)Ae[ut+tt]=je[Oe++]}Pe+=We.shape[1]})}return Ae}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ce=P((Se,fe)=>Se===fe?1:0),me=ht(p.hdR,ce,null,"bool"),pt=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ct=Be(Se=>Math.exp(Se)),Lt=S(p.NEP,ct,"float32"),Nt=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ln=Be(Se=>Math.expm1(Se)),Sn=S(p.Y0y,ln),tn=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kn=Be(Se=>Math.floor(Se)),bn=S(p.OR,kn),nn=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ps=P((Se,fe)=>Math.floor(Se/fe)),Xn=ht(p.jeX,ps,null,"int32"),Te=null;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Je(Se,fe,de,Ee,Ae,Pe,We,je,Oe){const st=(0,p.f3b)([Ee,Pe],de);for(let ut=0;ut<Ee;ut++){const tt=[];let yt=0;for(let At=0;At<Ae;At++){const xt=Se[ut*Ae+At];yt+=xt*We[At],tt.push(xt)}if(yt<0||yt>=Oe/Pe)throw new Error(`Invalid indices: ${tt} does not index into ${je}`);for(let At=0;At<Pe;At++)st.values[ut*Pe+At]=fe.get(...fe.indexToLoc(yt*Pe+At))}return st}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ft(Se,fe,de){const Ee=(0,p.f3b)(de,Se.dtype);for(let Ae=0;Ae<Ee.size;++Ae){const We=Ee.indexToLoc(Ae).slice(),je=We[0],Oe=We[2],st=fe.locToIndex([je,Oe]);We[2]=fe.values[st];const ut=Se.locToIndex(We);0<=ut&&ut<Se.values.length&&(Ee.values[Ae]=Se.values[ut])}return Ee}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ot=P((Se,fe)=>Se>fe?1:0),cn=ht(p.iZT,Ot,null,"bool"),Rn=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Un=P((Se,fe)=>Se>=fe?1:0),Kn=ht(p.Acj,Un,null,"bool"),Us=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const As=P((Se,fe)=>Se<fe?1:0),_r=ht(p.vtC,As,null,"bool"),Ar=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ns=P((Se,fe)=>Se<=fe?1:0),Jr=ht(p.CAk,Ns,null,"bool"),Ys=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eo(Se,fe,de){const Ee=(fe-Se)/(de-1),Ae=p.D5U.makeZerosTypedArray(de,"float32");Ae[0]=Se;for(let Pe=1;Pe<Ae.length;Pe++)Ae[Pe]=Ae[Pe-1]+Ee;return Ae}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bo=Be(Se=>Math.log(Se)),to=S(p.ZbH,bo),ks=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gr(Se,fe,de,Ee){const Ae=p.D5U.getTypedArrayFromDType(Ee,p.D5U.sizeFromShape(de));for(let Pe=0;Pe<Ae.length;++Pe){const We=Pe*fe;let je=Se[We];for(let Oe=0;Oe<fe;++Oe){const st=Se[We+Oe];(Number.isNaN(st)||st>je)&&(je=st)}Ae[Pe]=je}return Ae}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hr=P((Se,fe)=>Math.max(Se,fe)),br=ht(p.BMI,hr),wr=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ps=P((Se,fe)=>Math.min(Se,fe)),pr=ht(p.q8u,Ps),mn=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const le=P((Se,fe)=>Se*fe),Dn=Vt((Se,fe,de,Ee)=>({real:Se*de-fe*Ee,imag:Se*Ee+fe*de})),wn=ht(p.wYn,le,Dn),qs=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ws(Se,fe,de){const Ee=p.D5U.createScalarValue(-1,de);return le([],fe,Ee,Se,de)}function ns(Se){const{inputs:fe,backend:de}=Se,{x:Ee}=fe;assertNotComplex(Ee,"neg");const Ae=de.data.get(Ee.dataId).values,[Pe,We]=ws(Ae,Ee.shape,Ee.dtype);return de.makeTensorInfo(We,Ee.dtype,Pe)}const Pr=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ls=P((Se,fe)=>Se!==fe?1:0),vr=ht(p.yQU,ls,null,"bool"),Or=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Os(Se,fe,de,Ee){const[Ae,Pe]=p.Wap.computeOutAndReduceShapes(Se,Ee),We=(0,p.x8V)(fe,"int32"),je=p.D5U.makeZerosTypedArray(p.D5U.sizeFromShape(Ae),We),Oe=p.D5U.sizeFromShape(Pe);for(let st=0;st<je.length;++st){const ut=st*Oe;let tt=1;for(let yt=0;yt<Oe;++yt)tt*=de[ut+yt];je[st]=tt}return{outVals:je,outShape:Ae,outDtype:We}}function Qs(Se){const{inputs:fe,backend:de,attrs:Ee}=Se,{x:Ae}=fe,{axis:Pe,keepDims:We}=Ee;assertNotComplex(Ae,"prod");const je=Ae.shape.length,Oe=util.parseAxisParam(Pe,Ae.shape),st=backend_util.getAxesPermutation(Oe,je);let ut=Oe,tt=Ae;const yt=[];st!=null&&(tt=transpose({inputs:{x:Ae},backend:de,attrs:{perm:st}}),yt.push(tt),ut=backend_util.getInnerMostAxes(ut.length,je));const At=de.data.get(tt.dataId).values,{outVals:xt,outShape:Qt,outDtype:gt}=Os(tt.shape,tt.dtype,At,ut);let Ct=Qt;return We&&(Ct=backend_util.expandShapeToKeepDim(Qt,Oe)),yt.forEach(Pt=>de.disposeIntermediateTensorInfo(Pt)),de.makeTensorInfo(Ct,gt,xt)}const Jo=null;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zs(Se,fe,de){Se.forEach((Ee,Ae)=>{if(Ee<0||Ee>=de){const Pe=p.D5U.indexToLoc(Ae,fe.length,p.D5U.computeStrides(fe)).join(",");throw new Error(`indices[${Pe}] = ${Ee} is not in [0, ${de})`)}})}function Ms(Se,fe){for(let de=0;de<Se.length;++de){const Ee=Se[de],Ae=de===Se.length-1?fe:Se[de+1].length;if(Ee.length===0)throw new Error("Ragged splits may not be empty");if(Ee[0]<0)throw new Error("Ragged splits must be non-negative");if(Ee[Ee.length-1]>Ae)throw new Error("Ragged splits must not point past values");for(let Pe=1;Pe<Ee.length;++Pe)if(Ee[Pe-1]>Ee[Pe])throw new Error("Ragged splits must be sorted in ascending order")}}function Js(Se,fe,de,Ee){const Ae=[];let Pe=0;const We=fe.length-1+de.length,je=new Array(We).fill(null).map(()=>[0]);Ms(de,Ee);let Oe=1;for(let st=0;st<fe.length-1;++st){Oe*=fe[st];const ut=fe[st+1];for(let tt=1;tt<Oe+1;++tt)je[st].push(tt*ut)}for(let st=0;st<Se.length;++st){let ut=Se[st],tt=Se[st]+1;for(let yt=0;yt<de.length;++yt){const At=de[yt],xt=yt+fe.length-1;if(xt>=0){const Qt=je[xt],gt=Qt[Qt.length-1]-At[ut];for(let Ct=ut;Ct<tt;++Ct)je[xt].push(At[Ct+1]+gt)}ut=At[ut],tt=At[tt]}tt!==ut&&(Ae.push([ut,tt]),Pe+=tt-ut)}return{outSplits:je,valueSlices:Ae,numValues:Pe}}function Fr(Se){const fe=[];for(let de=0;de<Se.length;++de){const Ee=Se[de].length,Ae=p.D5U.getArrayFromDType("int32",Ee);fe.push(Ae),Se[de].forEach((Pe,We)=>Ae[We]=Pe)}return fe}function Hr(Se,fe){const de=Se.slice(0,fe);for(;de.length<fe;)de.push(1);for(let Ee=fe;Ee<Se.length;Ee++)de[fe-1]*=Se[Ee];return de}function Zn(Se,fe,de,Ee,Ae,Pe){const We=Hr(fe,2)[1],je=Hr(Pe,2)[1];let Oe=0;for(const st of de)for(let ut=st[0];ut<st[1];++ut){for(let tt=0;tt<Ee;++tt)Ae[Oe*je+tt]=Se[ut*We+tt];++Oe}}function vs(Se,fe,de,Ee,Ae){const Pe=fe.slice();Pe[0]=Ae;const We=p.D5U.getArrayFromDType(de,p.D5U.sizeFromShape(Pe)),je=Se.length,Oe=je===0?0:je/fe[0];return Zn(Se,fe,Ee,Oe,We,Pe),[We,Pe]}function no(Se,fe,de,Ee,Ae,Pe,We,je){if(Se.length===0)throw new Error("paramsNestedSplits must be non empty");if(fe[0].length===0)throw new Error("Split tensors must not be scalars");const Oe=fe[0][0]-1;if(Zs(Pe,We,Oe),Ee.length===0)throw new Error("params.rank must be nonzero");const st=Ee[0],{outSplits:ut,valueSlices:tt,numValues:yt}=Js(Pe,We,Se,st),At=Fr(ut),xt=vs(de,Ee,Ae,tt,yt);return[At,xt[0],xt[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ro=2147483647;function Cr(Se,fe,de,Ee,Ae,Pe,We){if(fe.length>1)throw new Error("starts must be a scalar or vector");if(Ae.length>1)throw new Error("limits must be a scalar or vector");if(We.length>1)throw new Error("deltas must be a scalar or vector");const je=fe.length===0,Oe=Ae.length===0,st=We.length===0,ut=[];je||ut.push(fe[0]),Oe||ut.push(Ae[0]),st||ut.push(We[0]);for(let gt=1;gt<ut.length;++gt)if(ut[gt]!==ut[gt-1])throw new Error("starts, limits, and deltas must have the same shape");const tt=ut.length===0?1:ut[0],yt=p.D5U.getArrayFromDType("int32",tt+1);yt[0]=0;for(let gt=0;gt<tt;++gt){const Ct=je?Se[0]:Se[gt],Pt=Oe?Ee[0]:Ee[gt],fn=st?Pe[0]:Pe[gt];if(fn===0)throw new Error("Requires delta != 0");let pn;if(fn>0&&Pt<Ct||fn<0&&Pt>Ct)pn=0;else if(pn=Math.ceil(Math.abs((Pt-Ct)/fn)),pn>Ro)throw new Error(`Requires ((limit - start) / delta) <= ${Ro}`);yt[gt+1]=yt[gt]+pn}const At=yt[tt],xt=p.D5U.getArrayFromDType(de,At);let Qt=0;for(let gt=0;gt<tt;++gt){const Ct=yt[gt+1]-yt[gt];let Pt=je?Se[0]:Se[gt];const fn=st?Pe[0]:Pe[gt];for(let pn=0;pn<Ct;++pn)xt[Qt++]=Pt,Pt+=fn}return[yt,xt]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Cs=p.Wap.RowPartitionType;class fr{constructor(fe,de,Ee,Ae,Pe,We,je,Oe,st,ut){this.shape=fe,this.shapeShape=de,this.values=Ee,this.valuesShape=Ae,this.valuesDType=Pe,this.defaultValue=We,this.defaultValueShape=je,this.rowPartitionValues=Oe,this.rowPartitionValuesShapes=st,this.rowPartitionTypes=p.Wap.getRowPartitionTypesHelper(ut),this.raggedRank=p.Wap.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(fe){return this.rowPartitionTypes[0]===Cs.FIRST_DIM_SIZE?this.rowPartitionTypes[fe+1]:this.rowPartitionTypes[fe]}getRowPartitionTensor(fe){return this.rowPartitionTypes[0]===Cs.FIRST_DIM_SIZE?this.rowPartitionValues[fe+1]:this.rowPartitionValues[fe]}getMaxWidth(fe){const de=this.getRowPartitionTensor(fe-1);switch(this.getRowPartitionTypeByDimension(fe-1)){case Cs.VALUE_ROWIDS:return fr.getMaxWidthValueRowID(de);case Cs.ROW_SPLITS:return fr.getMaxWidthRowSplit(de);default:throw new Error(`Cannot handle partition type ${Cs[this.getRowPartitionTypeByDimension(fe-1)]}`)}}static getMaxWidthRowSplit(fe){const de=fe.length;if(de===0||de===1)return 0;let Ee=0;for(let Ae=0;Ae<de-1;++Ae){const Pe=fe[Ae+1]-fe[Ae];Pe>Ee&&(Ee=Pe)}return Ee}static getMaxWidthValueRowID(fe){const de=fe.length;if(de===0)return 0;let Ee=0,Ae=fe[0],Pe=0;for(let We=1;We<de;++We){const je=fe[We];je!==Ae&&(Ae=je,Pe=Math.max(We-Ee,Pe),Ee=We)}return Math.max(de-Ee,Pe)}tensorShapeFromTensor(fe,de,Ee=!0){if(de.length===0){if(fe[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return so(fe,Ee)}calculateOutputSize(fe){const de=this.valuesShape,Ee=this.defaultValueShape;p.Wap.validateDefaultValueShape(Ee,de);const Ae=this.tensorShapeFromTensor(this.shape,this.shapeShape),We=p.Wap.combineRaggedTensorToTensorShapes(this.raggedRank,Ae,de);We[0]<0&&(We[0]=fe);for(let je=1;je<=this.raggedRank;++je)We[je]<0&&(We[je]=this.getMaxWidth(je));return We}calculateFirstParentOutputIndex(fe,de,Ee){const Ae=Math.min(fe,Ee),Pe=[];let We=0;for(let je=0;je<Ae;++je,We+=de)Pe.push(We);for(let je=Ae;je<fe;++je)Pe.push(-1);return p.D5U.assert(Pe.length===fe,()=>"Final length of result must be equal to firstDimension."),Pe}calculateOutputIndexRowSplit(fe,de,Ee,Ae){const Pe=fe.length,We=[];for(let je=0;je<Pe-1;++je){const Oe=fe[je+1]-fe[je];let st=Math.min(Ae,Oe),ut=de[je];ut===-1&&(st=0);for(let tt=0;tt<st;++tt)We.push(ut),ut+=Ee;for(let tt=0;tt<Oe-st;++tt)We.push(-1)}if(Pe>0&&We.length!==fe[Pe-1])throw new Error("Invalid row split size.");return We}calculateOutputIndexValueRowID(fe,de,Ee,Ae){const Pe=fe.length,We=[];if(Pe===0)return[];let je=0,Oe=fe[0];if(Oe>=de.length)throw new Error(`Got currentValueRowId=${Oe}, which is not less than ${de.length}`);let st=de[Oe];We.push(st);for(let ut=1;ut<Pe;++ut){const tt=fe[ut];if(tt===Oe)st>=0&&(++je,je<Ae?st+=Ee:st=-1);else{if(je=0,Oe=tt,tt>=de.length)throw new Error(`Got nextValueRowId=${tt} which is not less than ${de.length}`);st=de[tt]}We.push(st)}if(We.length!==fe.length)throw new Error("Invalid row ids.");return We}calculateOutputIndex(fe,de,Ee,Ae){const Pe=this.getRowPartitionTensor(fe),We=this.getRowPartitionTypeByDimension(fe);switch(We){case Cs.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(Pe,de,Ee,Ae);case Cs.ROW_SPLITS:if(Pe.length-1>de.length)throw new Error(`Row partition size is greater than output size: ${Pe.length-1} > ${de.length}`);return this.calculateOutputIndexRowSplit(Pe,de,Ee,Ae);default:throw new Error(`Unsupported partition type: ${Cs[We]}`)}}getFirstDimensionSize(){const fe=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const de=this.rowPartitionTypes[0];switch(de){case Cs.FIRST_DIM_SIZE:return fe[0];case Cs.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Cs.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Cs[de]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const de=this.getFirstDimensionSize(),Ee=this.calculateOutputSize(de),Ae=new Array(this.raggedRank+1);Ae[Ae.length-1]=1;for(let Oe=Ae.length-2;Oe>=0;--Oe)Ae[Oe]=Ae[Oe+1]*Ee[Oe+1];const Pe=so(Ee,!1),We=p.D5U.getArrayFromDType(this.valuesDType,p.D5U.sizeFromShape(Pe));if(Ae[0]*Ee[0]>0){let Oe=this.calculateFirstParentOutputIndex(de,Ae[0],Ee[0]);for(let st=1;st<=this.raggedRank;++st)Oe=this.calculateOutputIndex(st-1,Oe,Ae[st],Ee[st]);this.setOutput(this.raggedRank,Oe,We,Pe)}return[Pe,We]}setOutput(fe,de,Ee,Ae){if(Ee.length===0)return;const Pe=this.values,We=Ee;let je=Ae.slice();je=je.slice(fe+1);const Oe=p.D5U.sizeFromShape(je),st=de.length;let ut=this.defaultValue;if(ut.length!==Oe&&ut.length!==1){const xt=this.defaultValueShape;(0,p.lub)(()=>{const Qt=(0,p.XLQ)(ut,xt);ut=(0,p.UFq)(Qt,je).dataSync()})}let tt=0,yt=0,At=0;for(let xt=0;xt<=st;++xt){let Qt=xt<st?de[xt]:-1;if(Qt===At){++At;continue}if(yt<At){const gt=Pe.subarray(tt*Oe),Ct=We.subarray(yt*Oe),Pt=(At-yt)*Oe;Sr(Ct,gt,Pt)}if(xt>=st){const gt=Ee.length;Qt=Math.floor(gt/Oe)}if(Qt>At)if(this.defaultValue.length===1)We.subarray(At*Oe,Qt*Oe).fill(this.defaultValue[0]),At=Qt;else for(;Qt>At;){const gt=We.slice(At*Oe);Sr(gt,ut,Oe),++At}Qt<0?(tt=xt+1,yt=At):(tt=xt,yt=At,At=yt+1)}}}function Sr(Se,fe,de){for(let Ee=0;Ee<de;Ee++)Se[Ee]=fe[Ee]}function so(Se,fe){const de=[];for(let Ee of Se){if(Ee<0){if(!fe)throw new Error(`Dimension ${Ee} must be >= 0`);if(Ee<-1)throw new Error(`Dimension ${Ee} must be >= -1`);Ee=-1}de.push(Ee)}return de}function ro(Se,fe,de,Ee,Ae,Pe,We,je,Oe,st){return new fr(Se,fe,de,Ee,Ae,Pe,We,je,Oe,st).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wo(Se,fe,de,Ee){const Ae=Se===fe,Pe=Se<fe&&de<0,We=fe<Se&&de>1;if(Ae||Pe||We)return p.D5U.makeZerosTypedArray(0,Ee);const je=Math.abs(Math.ceil((fe-Se)/de)),Oe=p.D5U.makeZerosTypedArray(je,Ee);fe<Se&&de===1&&(de=-1),Oe[0]=Se;for(let st=1;st<Oe.length;st++)Oe[st]=Oe[st-1]+de;return Oe}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oo=Be(Se=>1/Math.sqrt(Se)),js=S(p.bV0,oo),er=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Br(Se,fe,de,Ee,Ae,Pe,We,je,Oe,st){const ut=[Ee/Ae,Ae],tt=Se.values,yt=fe.values;if(Ee===0)return(0,p.f3b)(de,fe.dtype);const At=Oe instanceof p.YDk?Oe:(0,p.f3b)(ut,fe.dtype);typeof Oe=="string"||typeof Oe=="number"?At.values.fill(Oe):typeof Oe=="boolean"&&At.values.fill(+Oe);for(let xt=0;xt<Pe;xt++){const Qt=[];let gt=0;for(let Ct=0;Ct<We;Ct++){const Pt=tt[xt*We+Ct];Qt.push(Pt),gt+=Pt*je[Ct]}if(gt<0||gt>=Ee/Ae)throw new Error(`Invalid indices: ${Qt} does not index into ${de}`);for(let Ct=0;Ct<Ae;Ct++)st?At.values[gt*Ae+Ct]+=yt[xt*Ae+Ct]:At.values[gt*Ae+Ct]=fe.rank===0?yt[0]:yt[xt*Ae+Ct]}return At}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tr=Be(Se=>1/(1+Math.exp(-Se))),Do=at(p.a5O,Se=>1/(1+Math.exp(-Se))),_o=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ao(Se,fe,de,Ee,Ae){const Pe=p.kuN.isSliceContinous(Ee,fe,de),We=p.D5U.sizeFromShape(de),je=p.D5U.computeStrides(Ee);if(Pe){const tt=p.kuN.computeFlatOffset(fe,je);return Ae==="string"?Se.slice(tt,tt+We):Se.subarray(tt,tt+We)}const Oe=Ae==="string"?p.Wap.fromUint8ToStringArray(Se):Se,st=(0,p.f3b)(Ee,Ae,Oe),ut=(0,p.f3b)(de,Ae);for(let tt=0;tt<ut.size;++tt){const yt=ut.indexToLoc(tt),At=yt.map((xt,Qt)=>xt+fe[Qt]);ut.set(st.get(...At),...yt)}return Ae==="string"?p.Wap.fromStringArrayToUint8(ut.values):ut.values}function ms(Se){const{inputs:fe,backend:de,attrs:Ee}=Se,{x:Ae}=fe,{begin:Pe,size:We}=Ee;assertNotComplex(Ae,"slice");const[je,Oe]=slice_util.parseSliceParams(Ae,Pe,We);slice_util.assertParamsValid(Ae,je,Oe);const st=de.data.get(Ae.dataId).values,ut=ao(st,je,Oe,Ae.shape,Ae.dtype);return de.makeTensorInfo(Oe,Ae.dtype,ut)}const Ao=null;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jr(Se,fe,de,Ee,Ae,Pe,We){const je=fe[0],Oe=Pe[0],st=new Array(Oe),ut=new Array(je),tt=fe[1];if(Oe===0){if(je!==0)throw new Error(p.Wap.getSparseFillEmptyRowsIndicesDenseShapeMismatch(je));const gt=p.D5U.getArrayFromDType(de,0),Ct=p.D5U.getArrayFromDType(Ae,0);return[gt,[0,tt],Ct,st,ut]}let yt=!0,At=0;const xt=new Array(Oe).fill(0);for(let gt=0;gt<je;++gt){const Ct=Se[gt*tt];if(Ct<0)throw new Error(p.Wap.getSparseFillEmptyRowsNegativeIndexErrorMessage(gt,Ct));if(Ct>=Oe)throw new Error(p.Wap.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(gt,Ct,Oe));++xt[Ct],yt=yt&&Ct>=At,At=Ct}let Qt=!0;for(let gt=0;gt<Oe;++gt){const Ct=xt[gt]===0;st[gt]=Ct,Qt=Qt&&!Ct,xt[gt]=Math.max(xt[gt],1),gt>0&&(xt[gt]+=xt[gt-1])}if(Qt&&yt){const gt=Se,Ct=Ee;for(let Pt=0;Pt<je;++Pt)ut[Pt]=Pt;return[gt,[je,tt],Ct,st,ut]}else{const gt=xt[Oe-1],Ct=p.D5U.getArrayFromDType(de,gt*tt),Pt=p.D5U.getArrayFromDType(Ae,gt),fn=new Array(Oe).fill(0);for(let pn=0;pn<je;++pn){const Pn=Se[pn*tt],Jt=fn[Pn],Cn=(Pn===0?0:xt[Pn-1])+Jt;fn[Pn]++;for(let Hn=0;Hn<tt;++Hn)Ct[Cn*tt+Hn]=Se[pn*tt+Hn];Pt[Cn]=Ee[pn],ut[pn]=Cn}for(let pn=0;pn<Oe;++pn)if(fn[pn]===0){const Jt=pn===0?0:xt[pn-1];Ct[Jt*tt+0]=pn;for(let Cn=1;Cn<tt;++Cn)Ct[Jt*tt+Cn]=0;Pt[Jt]=We}return[Ct,[gt,tt],Pt,st,ut]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ws(Se,fe,de,Ee,Ae){const Pe=p.D5U.sizeFromShape(Ee),We=fe[0],je=Ae.length,Oe=[];let st=1,ut=-1;for(let gt=0;gt<je;++gt){const Ct=Ae[gt];if(Ct===-1){if(ut!==-1)throw new Error(p.Wap.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(ut,gt));ut=gt,Oe.push(1)}else{if(Ct<0)throw new Error(p.Wap.getSparseReshapeNegativeOutputDimErrorMessage(gt,Ct));st*=Ct,Oe.push(Ct)}}if(ut!==-1){if(st<=0)throw new Error(p.Wap.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const gt=Math.trunc(Pe/st);if(st*gt!==Pe)throw new Error(p.Wap.getSparseReshapeInputOutputMultipleErrorMessage(Ee,Oe));Oe[ut]=gt}if(p.D5U.sizeFromShape(Oe)!==Pe)throw new Error(p.Wap.getSparseReshapeInputOutputMismatchErrorMessage(Ee,Oe));const yt=Ee.length,At=[];if(yt>0){At[yt-1]=1;for(let gt=yt-2;gt>=0;--gt)At[gt]=At[gt+1]*Ee[gt+1]}const xt=[];if(je>0){xt[je-1]=1;for(let gt=je-2;gt>=0;--gt)xt[gt]=xt[gt+1]*Oe[gt+1]}const Qt=p.D5U.getArrayFromDType(de,We*je);for(let gt=0;gt<We;++gt){let Ct=0;for(let Pt=0;Pt<yt;++Pt)Ct+=Se[gt*yt+Pt]*At[Pt];for(let Pt=0;Pt<je;++Pt)Qt[gt*je+Pt]=Math.trunc(Ct/xt[Pt]),Ct%=xt[Pt]}return[Qt,[We,je],Oe]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kr(Se,fe,de,Ee,Ae,Pe=!1,We=0){const je=Ee.length,Oe=[fe[0],Se.length/fe[0]],st=Oe[1],tt=je>0?Ae[je-1]+1:0;if(tt<0)throw new Error(p.Wap.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const yt=fe.slice();yt[0]=tt;const At=yt.reduce((fn,pn)=>fn*pn,1),xt=p.D5U.getArrayFromDType(de,At);if(je===0)return tt>0&&xt.fill(We),[xt,yt];if(tt<=0)throw new Error(p.Wap.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let Qt=0,gt=1,Ct=0,Pt=Ae[Qt];for(;;){let fn=0;if(gt<je){if(fn=Ae[gt],Pt===fn){++gt;continue}if(Pt>=fn)throw new Error(p.Wap.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(Pt<0||Pt>=tt)throw new Error(p.Wap.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(Pt,tt));Pt>Ct&&xt.fill(We,Ct*st,Pt*st);for(let pn=Qt;pn<gt;++pn){const Pn=Ee[pn];if(Pn<0||Pn>=Oe[0])throw new Error(p.Wap.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(pn,Ee[pn],Oe[0]));for(let Jt=0;Jt<st;Jt++)xt[Pt*st+Jt]+=Se[Pn*st+Jt]}if(Pe)for(let pn=0;pn<st;pn++)xt[Pt*st+pn]/=gt-Qt;if(Qt=gt,++gt,Ct=Pt+1,Pt=fn,gt>je)break}return Ct<tt&&xt.fill(We,Ct*st,tt*st),[xt,yt]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zo=Be(Se=>Math.sqrt(Se)),vo=at(p.FKq,Se=>Math.sqrt(Se)),Po=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cs=P((Se,fe)=>{const de=Se-fe;return de*de}),as=ht(p._tC,cs),Oo=null;/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lr=Be((Se,fe)=>{const{pattern:de,replaceGlobal:Ee,rewrite:Ae}=fe;return Se.replace(new RegExp(de,Ee?"g":""),Ae)}),Co=S(p.e0R,Lr),Ss=null;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fs(Se,fe,de,Ee){const Ae=(0,p.f3b)(Se,fe.dtype);for(let Pe=0;Pe<Ae.size;Pe++){const We=Ae.indexToLoc(Pe),je=new Array(We.length);for(let Oe=0;Oe<je.length;Oe++)je[Oe]=We[Oe]*de[Oe]+Ee[Oe];Ae.set(fe.get(...je),...We)}return Ae}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uo{constructor(fe,de,Ee,Ae,Pe,We){this.separator=p.D5U.encodeString(fe),this.nGramWidths=de,this.leftPad=p.D5U.encodeString(Ee),this.rightPad=p.D5U.encodeString(Ae),this.padWidth=Pe,this.preserveShort=We}getPadWidth(fe){return Math.min(this.padWidth<0?fe-1:this.padWidth,fe-1)}getNumNGrams(fe,de){const Ee=this.getPadWidth(de);return Math.max(0,fe+2*Ee-de+1)}createNGrams(fe,de,Ee,Ae,Pe,We){for(let je=0;je<Pe;++je){const Oe=this.getPadWidth(We),st=Math.max(0,Oe-je),ut=Math.max(0,Oe-(Pe-(je+1))),tt=We-(st+ut),yt=de+(st>0?0:je-Oe);let At=0;At+=st*this.leftPad.length;for(let Pt=0;Pt<tt;++Pt)At+=fe[yt+Pt].length;At+=ut*this.rightPad.length;const xt=st+ut+tt-1;At+=xt*this.separator.length,Ee[Ae+je]=new Uint8Array(At);const Qt=Ee[Ae+je];let gt=0;const Ct=Pt=>Pt.forEach(fn=>Qt[gt++]=fn);for(let Pt=0;Pt<st;++Pt)Ct(this.leftPad),Ct(this.separator);for(let Pt=0;Pt<tt-1;++Pt)Ct(fe[yt+Pt]),Ct(this.separator);if(tt>0){Ct(fe[yt+tt-1]);for(let Pt=0;Pt<ut;++Pt)Ct(this.separator),Ct(this.rightPad)}else{for(let Pt=0;Pt<ut-1;++Pt)Ct(this.rightPad),Ct(this.separator);Ct(this.rightPad)}}}compute(fe,de){const Ee=fe.length,Ae=de.length;if(Ae>0){let Oe=de[0];if(Oe!==0)throw new Error(`First split value must be 0, got ${Oe}`);for(let st=1;st<Ae;++st){let ut=de[st]>=Oe;if(ut=ut&&de[st]<=Ee,!ut)throw new Error(`Invalid split value ${de[st]}, must be in [${Oe}, ${Ee}]`);Oe=de[st]}if(Oe!==Ee)throw new Error(`Last split value must be data size. Expected ${Ee}, got ${Oe}`)}const Pe=Ae-1,We=p.D5U.getArrayFromDType("int32",Ae);if(Ee===0||Ae===0){const Oe=new Array(Ee);for(let st=0;st<=Pe;++st)We[st]=0;return[Oe,We]}We[0]=0;for(let Oe=1;Oe<=Pe;++Oe){const st=de[Oe]-de[Oe-1];let ut=0;this.nGramWidths.forEach(tt=>{ut+=this.getNumNGrams(st,tt)}),this.preserveShort&&st>0&&ut===0&&(ut=1),We[Oe]=We[Oe-1]+ut}const je=new Array(We[Pe]);for(let Oe=0;Oe<Pe;++Oe){const st=de[Oe];let ut=We[Oe];if(this.nGramWidths.forEach(tt=>{const yt=de[Oe+1]-de[Oe],At=this.getNumNGrams(yt,tt);this.createNGrams(fe,st,je,ut,At,tt),ut+=At}),this.preserveShort&&ut===We[Oe]){const tt=de[Oe+1]-de[Oe];if(tt===0)continue;const yt=tt+2*this.padWidth;this.createNGrams(fe,st,je,ut,1,yt)}}return[je,We]}}function An(Se,fe,de,Ee,Ae,Pe,We,je){return new uo(de,Ee,Ae,Pe,We,je).compute(Se,fe)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ur(Se,fe,de,Ee){if(!Se.length)return;if(fe.length===0){for(let Pe=0;Pe<Se.length;++Pe)Ee.push(Se.subarray(Pe,Pe+1));return}if(fe.length===1){const Pe=fe[0];let We=Se.indexOf(Pe);for(;We!==-1;){const je=Se.subarray(0,We);(!de||je.length!==0)&&Ee.push(je),Se=Se.subarray(We+1),We=Se.indexOf(Pe)}(!de||Se.length!==0)&&Ee.push(Se);return}let Ae=0;for(let Pe=0;Pe<Se.length+1;Pe++)if(Pe===Se.length||fe.indexOf(Se[Pe])!==-1){const We=Se.subarray(Ae,Pe);(!de||We.length!==0)&&Ee.push(We),Ae=Pe+1}}function ar(Se,fe,de){const Ee=Se.length,Ae=[];let Pe=0,We=0;const je=new Array(Ee);for(let yt=0;yt<Ee;++yt){const At=Ae.length;Ur(Se[yt],fe,de,Ae);const xt=Ae.length-At;je[yt]=xt,Pe+=xt,We=Math.max(We,xt)}const Oe=p.D5U.getArrayFromDType("int32",Pe*2),st=new Array(Pe),ut=[Ee,We];let tt=0;for(let yt=0;yt<Ee;++yt)for(let At=0;At<je[yt];++At)Oe[tt*2]=yt,Oe[tt*2+1]=At,st[tt]=Ae[tt],++tt;return[Oe,st,ut]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nr(Se,fe){const de=p.D5U.getArrayFromDType("int32",Se.length);for(let Ee=0;Ee<Se.length;++Ee)de[Ee]=p.D5U.fingerPrint64(Se[Ee]).modulo(fe).getLowBitsUnsigned();return de}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ir=P((Se,fe)=>Se-fe),So=Vt((Se,fe,de,Ee)=>({real:Se-de,imag:fe-Ee})),Mr=ht(p.Tr8,ir,So),Ye=null;/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ir(Se,fe){const de=new Array(Se.rank);for(let Ae=0;Ae<de.length;Ae++)de[Ae]=Se.shape[Ae]*fe[Ae];const Ee=(0,p.f3b)(de,Se.dtype);for(let Ae=0;Ae<Ee.values.length;++Ae){const Pe=Ee.indexToLoc(Ae),We=new Array(Se.rank);for(let Oe=0;Oe<We.length;Oe++)We[Oe]=Pe[Oe]%Se.shape[Oe];const je=Se.locToIndex(We);Ee.values[Ae]=Se.values[je]}return Ee}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jn=(Se,fe)=>{const de=fe.value-Se.value;return de===0?Se.index-fe.index:de};function Er(Se,fe,de=0,Ee=Se.length-1){for(;Ee>de;){if(Ee-de>600){const je=Ee-de+1,Oe=fe-de+1,st=Math.log(je),ut=.5*Math.exp(2*st/3),tt=.5*Math.sqrt(st*ut*(je-ut)/je)*Math.sign(Oe-je/2),yt=Math.max(de,Math.floor(fe-Oe*ut/je+tt)),At=Math.min(Ee,Math.floor(fe+(je-Oe)*ut/je+tt));Er(Se,fe,yt,At)}const Ae=Se[fe];let Pe=de,We=Ee;for(p.D5U.swap(Se,de,fe),Jn(Se[Ee],Ae)>0&&p.D5U.swap(Se,de,Ee);Pe<We;){for(p.D5U.swap(Se,Pe,We),Pe++,We--;Jn(Se[Pe],Ae)<0;)Pe=Pe+1;for(;Jn(Se[We],Ae)>0;)We=We-1}Jn(Se[de],Ae)===0?p.D5U.swap(Se,de,We):(We=We+1,p.D5U.swap(Se,We,Ee)),We<=fe&&(de=We+1),fe<=We&&(Ee=We-1)}}function Wr(Se,fe,de,Ee,Ae){const Pe=fe[fe.length-1],[We,je]=[Se.length/Pe,Pe],Oe=p.D5U.getTypedArrayFromDType(de,We*Ee),st=p.D5U.getTypedArrayFromDType("int32",We*Ee);for(let tt=0;tt<We;tt++){const yt=tt*je,At=Se.subarray(yt,yt+je);let xt=new Array(At.length);At.forEach((Pt,fn)=>xt[fn]={value:Pt,index:fn}),Ee<xt.length&&(Er(xt,Ee),xt=xt.slice(0,Ee)),Ae&&xt.sort(Jn);const Qt=tt*Ee,gt=Oe.subarray(Qt,Qt+Ee),Ct=st.subarray(Qt,Qt+Ee);for(let Pt=0;Pt<Ee;Pt++)gt[Pt]=xt[Pt].value,Ct[Pt]=xt[Pt].index}const ut=fe.slice();return ut[ut.length-1]=Ee,[(0,p.f3b)(ut,de,Oe),(0,p.f3b)(ut,"int32",st)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fs(Se,fe,de,Ee,Ae){const Pe=fe.length,We=p.D5U.sizeFromShape(fe),je=p.D5U.computeStrides(fe),Oe=p.D5U.computeStrides(Ae),st=p.D5U.getTypedArrayFromDType(de,p.D5U.sizeFromShape(Ae));for(let ut=0;ut<We;++ut){const tt=p.D5U.indexToLoc(ut,Pe,je),yt=new Array(tt.length);for(let xt=0;xt<yt.length;xt++)yt[xt]=tt[Ee[xt]];const At=p.D5U.locToIndex(yt,Pe,Oe);st[At]=Se[ut]}return st}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ur(Se,fe,de,Ee){const Ae=p.D5U.parseAxisParam(fe,de)[0],Pe=[1,de[0],1];for(let xt=0;xt<Ae;xt++)Pe[0]*=de[xt];Pe[1]=de[Ae];for(let xt=Ae+1;xt<de.length;xt++)Pe[2]*=de[xt];const We=new Map,je=new Int32Array(de[Ae]),Oe=new p.YDk(Pe,Ee,Se),st=[],ut=Pe[0]===1&&Pe[2]===1;for(let xt=0;xt<de[Ae];xt++){let Qt;if(ut)Qt=Se[xt].toString();else{const Ct=[];for(let Pt=0;Pt<Pe[0];Pt++)for(let fn=0;fn<Pe[2];fn++)Ct.push(Oe.get(Pt,xt,fn));Qt=Ct.join(",")}const gt=We.get(Qt);if(gt!=null)je[xt]=gt;else{const Ct=We.size;We.set(Qt,Ct),je[xt]=Ct,st.push(xt)}}const tt=Pe.slice();tt[1]=We.size;const yt=new p.YDk(tt,Ee);st.forEach((xt,Qt)=>{for(let gt=0;gt<Pe[0];gt++)for(let Ct=0;Ct<Pe[2];Ct++)yt.set(Oe.get(gt,xt,Ct),gt,Qt,Ct)});const At=de.slice();return At[Ae]=tt[1],{outputValues:yt.values,outputShape:At,indices:je}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},8053:function(Wt,dt,L){"use strict";var p=L(9677);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ze={},Z={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function ie(i){delete ze[i]}function P(i,r){ze[i]=r}function W(i,r){if(!(i in ze)||r!=null){const l=ee(i,r);if(l!==null)ze[i]=l;else return console.log("Could not get context for WebGL version",i),null}const o=ze[i];return o==null||o.isContextLost()?(delete ze[i],W(i)):(o.disable(o.DEPTH_TEST),o.disable(o.STENCIL_TEST),o.disable(o.BLEND),o.disable(o.DITHER),o.disable(o.POLYGON_OFFSET_FILL),o.disable(o.SAMPLE_COVERAGE),o.enable(o.SCISSOR_TEST),o.enable(o.CULL_FACE),o.cullFace(o.BACK),ze[i])}function pe(i){if(!(0,p.OBj)().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&i===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function ee(i,r){if(i!==1&&i!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const o=r??pe(i);return o.addEventListener("webglcontextlost",l=>{l.preventDefault(),delete ze[i]},!1),(0,p.OBj)().getBool("SOFTWARE_WEBGL_ENABLED")&&(Z.failIfMajorPerformanceCaveat=!1),i===1?o.getContext("webgl",Z)||o.getContext("experimental-webgl",Z):o.getContext("webgl2",Z)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var we;(function(i){i[i.DENSE=0]="DENSE",i[i.SHARED_BATCH=1]="SHARED_BATCH"})(we||(we={}));var xe;(function(i){i[i.RENDER=0]="RENDER",i[i.UPLOAD=1]="UPLOAD",i[i.PIXELS=2]="PIXELS",i[i.DOWNLOAD=3]="DOWNLOAD"})(xe||(xe={}));var K;(function(i){i[i.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",i[i.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",i[i.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",i[i.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",i[i.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(K||(K={}));function _(i,r){return[r,i]}function De(i,r){return i*r}function Fe(i,r){return[r*4,i]}function Ke(i){const r=p.D5U.sizeFromShape(i),o=Math.ceil(r/4);return p.D5U.sizeToSquarishShape(o)}function rt(i,r){if(i%r!==0)throw new Error(`unpackedSize (${i}) must be a multiple of ${r}`);return i/r}function ht(i,r,o){const l=i.length*o/4;if(r.length<l)throw new Error(`matrix length (${r.length}) must be >= ${l}`);let c=0;for(let f=0;f<i.length;f+=4)for(let g=0;g<o;g++)r[c++]=i[f+g]}function Vt(i,r){return[Math.max(1,Math.ceil(r/2)),Math.max(1,Math.ceil(i/2))]}function on(i,r){const[o,l]=Vt(i,r);return o*l*4}function $t(i,r){const o=i;let l,c,f,g,C,v,D,F,H,Y;return(0,p.OBj)().getNumber("WEBGL_VERSION")===2?(l=o.R32F,c=o.R16F,f=o.RGBA16F,g=o.RGBA32F,C=o.RED,D=4,F=1,H=o.HALF_FLOAT,Y=o.FLOAT,v=o.RGBA8):(l=i.RGBA,c=i.RGBA,f=i.RGBA,g=o.RGBA,C=i.RGBA,D=4,F=4,H=r!=null?r.HALF_FLOAT_OES:null,Y=i.FLOAT,v=i.RGBA),{internalFormatFloat:l,internalFormatHalfFloat:c,internalFormatPackedHalfFloat:f,internalFormatPackedFloat:g,textureFormatFloat:C,downloadTextureFormat:v,downloadUnpackNumChannels:D,defaultNumChannels:F,textureTypeHalfFloat:H,textureTypeFloat:Y}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ve(i,r){const o=r();return(0,p.OBj)().getBool("DEBUG")&&y(i),o}function y(i){const r=i.getError();if(r!==i.NO_ERROR)throw new Error("WebGL Error: "+G(i,r))}const Qe=596e-10,V=65504;function re(i){return!!((0,p.OBj)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||i===0||Qe<Math.abs(i)&&Math.abs(i)<V)}function G(i,r){switch(r){case i.NO_ERROR:return"NO_ERROR";case i.INVALID_ENUM:return"INVALID_ENUM";case i.INVALID_VALUE:return"INVALID_VALUE";case i.INVALID_OPERATION:return"INVALID_OPERATION";case i.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case i.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case i.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${r}`}}function Re(i,r){return Ot(i,()=>i.getExtension(r),'Extension "'+r+'" not supported on this browser.')}function Be(i,r){const o=Ot(i,()=>i.createShader(i.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ve(i,()=>i.shaderSource(o,r)),ve(i,()=>i.compileShader(o)),i.getShaderParameter(o,i.COMPILE_STATUS)===!1)throw console.log(i.getShaderInfoLog(o)),new Error("Failed to compile vertex shader.");return o}function at(i,r){const o=Ot(i,()=>i.createShader(i.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ve(i,()=>i.shaderSource(o,r)),ve(i,()=>i.compileShader(o)),(0,p.OBj)().get("ENGINE_COMPILE_ONLY"))return o;if(i.getShaderParameter(o,i.COMPILE_STATUS)===!1)throw nt(r,i.getShaderInfoLog(o)),new Error("Failed to compile fragment shader.");return o}const S=/ERROR: [0-9]+:([0-9]+):/g;function nt(i,r){const o=S.exec(r);if(o==null){console.log(`Couldn't parse line number in error: ${r}`),console.log(i);return}const l=+o[1],c=i.split(`
`),f=c.length.toString().length+2,g=c.map((H,Y)=>p.D5U.rightPad((Y+1).toString(),f)+H);let C=0;for(let H=0;H<g.length;H++)C=Math.max(g[H].length,C);const v=g.slice(0,l-1),D=g.slice(l-1,l),F=g.slice(l);console.log(v.join(`
`)),console.log(r.split(`
`)[0]),console.log(`%c ${p.D5U.rightPad(D[0],C)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(F.join(`
`))}function ne(i){return Ot(i,()=>i.createProgram(),"Unable to create WebGLProgram.")}function Ne(i,r){if(ve(i,()=>i.linkProgram(r)),!(0,p.OBj)().get("ENGINE_COMPILE_ONLY")&&i.getProgramParameter(r,i.LINK_STATUS)===!1)throw console.log(i.getProgramInfoLog(r)),new Error("Failed to link vertex and fragment shaders.")}function Ve(i,r){if(ve(i,()=>i.validateProgram(r)),i.getProgramParameter(r,i.VALIDATE_STATUS)===!1)throw console.log(i.getProgramInfoLog(r)),new Error("Shader program validation failed.")}function ce(i,r){const o=Ot(i,()=>i.createBuffer(),"Unable to create WebGLBuffer");return ve(i,()=>i.bindBuffer(i.ARRAY_BUFFER,o)),ve(i,()=>i.bufferData(i.ARRAY_BUFFER,r,i.STATIC_DRAW)),o}function me(i,r){const o=Ot(i,()=>i.createBuffer(),"Unable to create WebGLBuffer");return ve(i,()=>i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,o)),ve(i,()=>i.bufferData(i.ELEMENT_ARRAY_BUFFER,r,i.STATIC_DRAW)),o}function pt(){return env().getNumber("WEBGL_VERSION")===2?1:4}function ct(i){return Ot(i,()=>i.createTexture(),"Unable to create WebGLTexture.")}function Lt(i,r){const o=(0,p.OBj)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(i<=0||r<=0){const l=`[${i}x${r}]`;throw new Error("Requested texture size "+l+" is invalid.")}if(i>o||r>o){const l=`[${i}x${r}]`,c=`[${o}x${o}]`;throw new Error("Requested texture size "+l+" greater than WebGL maximum on this browser / GPU "+c+".")}}function Nt(i){return Ot(i,()=>i.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function ln(i,r,o,l,c,f,g){const C=i.getAttribLocation(r,o);return C===-1?!1:(ve(i,()=>i.bindBuffer(i.ARRAY_BUFFER,l)),ve(i,()=>i.vertexAttribPointer(C,c,i.FLOAT,!1,f,g)),ve(i,()=>i.enableVertexAttribArray(C)),!0)}function Sn(i,r,o){cn(i,o),ve(i,()=>i.activeTexture(i.TEXTURE0+o)),ve(i,()=>i.bindTexture(i.TEXTURE_2D,r))}function tn(i,r){cn(i,r),ve(i,()=>i.activeTexture(i.TEXTURE0+r)),ve(i,()=>i.bindTexture(i.TEXTURE_2D,null))}function kn(i,r,o){return Ot(i,()=>i.getUniformLocation(r,o),'uniform "'+o+'" not present in program.')}function bn(i,r,o){return i.getUniformLocation(r,o)}function nn(i,r,o,l){ve(i,()=>Sn(i,r,l)),ve(i,()=>i.uniform1i(o,l))}function ps(i){ve(i,()=>i.bindFramebuffer(i.FRAMEBUFFER,null)),ve(i,()=>i.viewport(0,0,i.canvas.width,i.canvas.height)),ve(i,()=>i.scissor(0,0,i.canvas.width,i.canvas.height))}function Xn(i,r,o){ve(i,()=>i.bindFramebuffer(i.FRAMEBUFFER,o)),ve(i,()=>i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,r,0))}function Te(i,r){ve(i,()=>i.bindFramebuffer(i.FRAMEBUFFER,r)),ve(i,()=>i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,null,0))}function Je(i){const r=i.checkFramebufferStatus(i.FRAMEBUFFER);if(r!==i.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+ft(i,r))}function ft(i,r){switch(r){case i.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case i.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case i.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case i.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${r}`}}function Ot(i,r,o){const l=ve(i,()=>r());if(l==null)throw new Error(o);return l}function cn(i,r){const o=i.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,l=r+i.TEXTURE0;if(l<i.TEXTURE0||l>o){const c=`[gl.TEXTURE0, gl.TEXTURE${o}]`;throw new Error(`textureUnit must be in ${c}.`)}}function Rn(i,r=2){return p.D5U.sizeFromShape(i.slice(0,i.length-r))}function Un(i){if(i.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[i.length>1?i[i.length-2]:1,i[i.length-1]]}function Kn(i){let r=[1,1,1];return i.length===0||i.length===1&&i[0]===1||(r=[Rn(i),...Un(i)]),r}function Us(i,r=!1){let o=(0,p.OBj)().getNumber("WEBGL_MAX_TEXTURE_SIZE"),l=(0,p.OBj)().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");l===1/0&&(0,p.OBj)().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(l=o/2),r&&(o=o*2,l=l*2,i=i.map((C,v)=>v>=i.length-2?p.D5U.nearestLargerEven(i[v]):i[v]),i.length===1&&(i=[2,i[0]])),i.length!==2&&(i=p.D5U.squeezeShape(i).newShape);let c=p.D5U.sizeFromShape(i),f=null;i.length<=1&&c<=o?f=[1,c]:i.length===2&&i[0]<=o&&i[1]<=o?f=i:i.length===3&&i[0]*i[1]<=o&&i[2]<=o?f=[i[0]*i[1],i[2]]:i.length===3&&i[0]<=o&&i[1]*i[2]<=o?f=[i[0],i[1]*i[2]]:i.length===4&&i[0]*i[1]*i[2]<=o&&i[3]<=o?f=[i[0]*i[1]*i[2],i[3]]:i.length===4&&i[0]<=o&&i[1]*i[2]*i[3]<=o&&(f=[i[0],i[1]*i[2]*i[3]]);const g=f!=null&&Math.max(...f)>l&&Math.min(...f)<=(r?2:1)&&Math.min(...f)>0;if(f==null||g)if(r){const C=Rn(i);let v=2,D=2;i.length&&([v,D]=Un(i)),c=C*(v/2)*(D/2),f=p.D5U.sizeToSquarishShape(c).map(F=>F*2)}else f=p.D5U.sizeToSquarishShape(c);return f}function As(i){return i%2===0}function _r(i,r){if(i=i.slice(-2),r=r.slice(-2),p.D5U.arraysEqual(i,r)||!i.length||!r.length||i[0]===0||i[1]===0||r[0]===0||r[1]===0)return!0;if(i.length!==r.length){const o=i[i.length-1],l=r[r.length-1];if(o===l||As(o)&&As(l)&&(i[0]===1||r[0]===1))return!0}return i[1]===r[1]&&As(i[0])&&As(r[0])}let Ar,Ns;function Jr(i){if(Ar==null){const r=W(i);Ar=r.getParameter(r.MAX_TEXTURE_SIZE)}return Ar}function Ys(){Ar=null}function eo(){Ns=null}function bo(i){if(Ns==null){const r=W(i);Ns=r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Ns)}function to(i){if(i===0)return 0;let r;const o=W(i);return ks(o,"EXT_disjoint_timer_query_webgl2")&&i===2?r=2:ks(o,"EXT_disjoint_timer_query")?r=1:r=0,r}function ks(i,r){return i.getExtension(r)!=null}function Gr(i){try{if(W(i)!=null)return!0}catch(r){return console.log("Error when getting WebGL context: ",r),!1}return!1}function hr(i){if(i===0)return!1;const r=W(i);if(i===1){if(!ks(r,"OES_texture_float"))return!1}else if(!ks(r,"EXT_color_buffer_float"))return!1;return wr(r)}function br(i){if(i===0)return!1;const r=W(i);if(i===1){if(!ks(r,"OES_texture_float")||!ks(r,"WEBGL_color_buffer_float"))return!1}else{if(ks(r,"EXT_color_buffer_float"))return wr(r);const l="EXT_color_buffer_half_float";if(ks(r,l)){const c=r.getExtension(l);return Ps(r,c)}return!1}return wr(r)}function wr(i){const r=$t(i),o=i.createTexture();i.bindTexture(i.TEXTURE_2D,o),i.texImage2D(i.TEXTURE_2D,0,r.internalFormatFloat,1,1,0,r.textureFormatFloat,r.textureTypeFloat,null);const f=i.createFramebuffer();i.bindFramebuffer(i.FRAMEBUFFER,f),i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,o,0);const g=i.checkFramebufferStatus(i.FRAMEBUFFER)===i.FRAMEBUFFER_COMPLETE;return i.bindTexture(i.TEXTURE_2D,null),i.bindFramebuffer(i.FRAMEBUFFER,null),i.deleteTexture(o),i.deleteFramebuffer(f),g}function Ps(i,r){const o=$t(i,r),l=i.createTexture();i.bindTexture(i.TEXTURE_2D,l),i.texImage2D(i.TEXTURE_2D,0,o.internalFormatHalfFloat,1,1,0,o.textureFormatFloat,o.textureTypeHalfFloat,null);const g=i.createFramebuffer();i.bindFramebuffer(i.FRAMEBUFFER,g),i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,l,0);const C=i.checkFramebufferStatus(i.FRAMEBUFFER)===i.FRAMEBUFFER_COMPLETE;return i.bindTexture(i.TEXTURE_2D,null),i.bindFramebuffer(i.FRAMEBUFFER,null),i.deleteTexture(l),i.deleteFramebuffer(g),C}function pr(i){return i!==2?!1:W(i).fenceSync!=null}function mn(i,r){Array.isArray(i)||(i=[i]),i.forEach(o=>{o!=null&&p.D5U.assert(o.dtype!=="complex64",()=>`${r} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const le=(0,p.OBj)();le.registerFlag("HAS_WEBGL",()=>le.getNumber("WEBGL_VERSION")>0),le.registerFlag("WEBGL_VERSION",()=>Gr(2)?2:Gr(1)?1:0),le.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),le.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>le.get("WEBGL_VERSION")===2),le.registerFlag("WEBGL_CPU_FORWARD",()=>!0),le.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),le.registerFlag("WEBGL_PACK",()=>le.getBool("HAS_WEBGL")),le.registerFlag("WEBGL_PACK_NORMALIZATION",()=>le.getBool("WEBGL_PACK")),le.registerFlag("WEBGL_PACK_CLIP",()=>le.getBool("WEBGL_PACK")),le.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>le.getBool("WEBGL_PACK")),le.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>le.getBool("WEBGL_PACK")),le.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>le.getBool("WEBGL_PACK")),le.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>le.getBool("WEBGL_PACK")),le.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>le.getBool("WEBGL_PACK")),le.registerFlag("WEBGL_PACK_REDUCE",()=>le.getBool("WEBGL_PACK")),le.registerFlag("WEBGL_LAZILY_UNPACK",()=>le.getBool("WEBGL_PACK")),le.registerFlag("WEBGL_CONV_IM2COL",()=>le.getBool("WEBGL_PACK")),le.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>le.getBool("WEBGL_PACK")),le.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Jr(le.getNumber("WEBGL_VERSION"))),le.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>bo(le.getNumber("WEBGL_VERSION"))),le.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const i=le.getNumber("WEBGL_VERSION");return i===0?0:to(i)}),le.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>le.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!p.C2$.isMobile()),le.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>hr(le.getNumber("WEBGL_VERSION"))),le.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>le.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:le.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),le.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>br(le.getNumber("WEBGL_VERSION"))),le.registerFlag("WEBGL_FENCE_API_ENABLED",()=>pr(le.getNumber("WEBGL_VERSION"))),le.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>le.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),le.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,i=>{if(typeof i!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${i}.`);if(i<0&&i!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${i}.`)}),le.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>p.C2$.isMobile()?1:-1,i=>{if(typeof i!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${i}.`);if(i<0&&i!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${i}.`)}),le.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),le.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),le.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),le.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),le.registerFlag("WEBGL_EXP_CONV",()=>!1),le.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>le.getBool("IS_TEST")),le.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),le.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),le.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),le.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dn(){let i,r,o,l,c,f,g,C,v,D;return(0,p.OBj)().getNumber("WEBGL_VERSION")===2?(i="#version 300 es",r="in",o="out",l="in",c="texture",f="outputColor",g="out vec4 outputColor;",C=(0,p.OBj)().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",v="",D=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(i="",r="attribute",o="varying",l="varying",c="texture2D",f="gl_FragColor",g="",C=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,v=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,D=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:i,attribute:r,varyingVs:o,varyingFs:l,texture2D:c,output:f,defineOutput:g,defineSpecialNaN:C,defineSpecialInf:v,defineRound:D}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wn(i,r,o="index"){const l=p.D5U.computeStrides(r);return l.map((c,f)=>{const g=`int ${i[f]} = ${o} / ${c}`,C=f===l.length-1?`int ${i[f+1]} = ${o} - ${i[f]} * ${c}`:`index -= ${i[f]} * ${c}`;return`${g}; ${C};`}).join("")}function qs(i,r,o="index"){const l=p.D5U.computeStrides(r);return l.map((c,f)=>{const g=`int ${i[f]} = ${o} / outShapeStrides[${f}]`,C=f===l.length-1?`int ${i[f+1]} = ${o} - ${i[f]} * outShapeStrides[${f}]`:`index -= ${i[f]} * outShapeStrides[${f}]`;return`${g}; ${C};`}).join("")}function ws(i,r){const o=i.length,l=i.map(f=>`${r}[${f}]`),c=new Array(o-1);c[o-2]=l[o-1];for(let f=o-3;f>=0;--f)c[f]=`(${c[f+1]} * ${l[f+1]})`;return c}function ns(i,r,o="index"){const l=i.map((f,g)=>g),c=ws(l,r);return c.map((f,g)=>{const C=`int ${i[g]} = ${o} / ${c[g]}`,v=g===c.length-1?`int ${i[g+1]} = ${o} - ${i[g]} * ${c[g]}`:`index -= ${i[g]} * ${c[g]}`;return`${C}; ${v};`}).join("")}function Pr(i){return i.length===1?`${i[0]}`:`vec${i.length}(${i.join(",")})`}function ls(i,r){if(i.length!==r.length)throw new Error(`Vectors to be dotted must be of the same length -got ${i.length} and ${r.length}`);const o=[],l=Math.floor(i.length/4),c=i.length%4;for(let f=0;f<l;f++){const g=i.slice(f*4,f*4+4),C=r.slice(f*4,f*4+4);o.push(`${Pr(g)}, ${Pr(C)}`)}if(c!==0){let f=i.slice(l*4),g=r.slice(l*4);f.length===1&&(f=f.map(C=>`float(${C})`),g=g.map(C=>`float(${C})`)),o.push(`${Pr(f)}, ${Pr(g)}`)}return o.map((f,g)=>`dot(${f})`).join("+")}function vr(i){const r=p.D5U.computeStrides(i).map(o=>o.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${r[0]} + coords.y * ${r[1]} + coords.z;
  }
`}function Or(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const Os=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:Qs}=p.Wap;function Jo(i,r,o){const l=[];if(i.forEach(te=>{const ae=p.D5U.sizeFromShape(te.shapeInfo.logicalShape);if(te.shapeInfo.isUniform?l.push(`uniform float ${te.name}${ae>1?`[${ae}]`:""};`):(l.push(`uniform sampler2D ${te.name};`),l.push(`uniform int offset${te.name};`)),o.enableShapeUniforms){const{uniformShape:Ce}=Ur(o.packedInputs,te.shapeInfo.logicalShape,te.shapeInfo.texShape);switch(Ce.length){case 1:l.push(`uniform int ${te.name}Shape;`);break;case 2:l.push(`uniform ivec2 ${te.name}Shape;`);break;case 3:l.push(`uniform ivec3 ${te.name}Shape;`);break;case 4:l.push(`uniform ivec4 ${te.name}Shape;`);break;default:break}l.push(`uniform ivec2 ${te.name}TexShape;`)}}),o.enableShapeUniforms){switch(r.logicalShape.length){case 1:l.push("uniform int outShape;");break;case 2:l.push("uniform ivec2 outShape;"),l.push("uniform int outShapeStrides;");break;case 3:l.push("uniform ivec3 outShape;"),l.push("uniform ivec2 outShapeStrides;");break;case 4:l.push("uniform ivec4 outShape;"),l.push("uniform ivec3 outShapeStrides;");break;default:break}l.push("uniform ivec2 outTexShape;")}o.customUniforms&&o.customUniforms.forEach(te=>{l.push(`uniform ${te.type} ${te.name}${te.arrayIndex?`[${te.arrayIndex}]`:""};`)});const c=l.join(`
`),f=i.map(te=>Js(te,r,o.packedInputs,o.enableShapeUniforms)).join(`
`),g=r.texShape,C=Dn(),v=Zn(C);let D,F,H=Ro(C);return r.isPacked?(D=Fr(r.logicalShape,g,o.enableShapeUniforms),F=no(C)):(D=Hr(r.logicalShape,g,o.enableShapeUniforms),F=vs(C)),o.packedInputs&&(H+=Sr),[H,v,F,c,D,f,o.userCode].join(`
`)}function Zs(i,r=!1){const o=i.shapeInfo.logicalShape;switch(o.length){case 0:return jr(i,r);case 1:return Kr(i,r);case 2:return vo(i,r);case 3:return cs(i,r);case 4:return Oo(i,r);case 5:return Lr(i);case 6:return Co(i);default:throw new Error(`${o.length}-D input sampling is not yet supported`)}}function Ms(i,r){switch(i.shapeInfo.logicalShape.length){case 0:return Ao(i);case 1:return Ws(i,r);case 2:return zo(i,r);case 3:return Po(i,r);default:return as(i,r)}}function Js(i,r,o=!1,l){let c="";o?c+=Ms(i,l):c+=Zs(i,l);const f=i.shapeInfo.logicalShape,g=r.logicalShape;return f.length<=g.length&&(o?c+=fs(i,r):c+=uo(i,r)),c}function Fr(i,r,o){switch(i.length){case 0:return so();case 1:return ro(i,r,o);case 2:return _o(i,r,o);case 3:return oo(i,r,o);default:return er(i,r,o)}}function Hr(i,r,o){switch(i.length){case 0:return so();case 1:return wo(i,r,o);case 2:return ao(i,r,o);case 3:return js(i,r,o);case 4:return Br(i,r,o);case 5:return tr(i,r);case 6:return Do(i,r);default:throw new Error(`${i.length}-D output sampling is not yet supported`)}}function Zn(i){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${i.texture2D}(textureSampler, uv).r;
    }
  `}function vs(i){return`
    void setOutput(float val) {
      ${i.output} = vec4(val, 0, 0, 0);
    }
  `}function no(i){return`
    void setOutput(vec4 val) {
      ${i.output} = val;
    }
  `}function Ro(i){return`${i.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${i.varyingFs} vec2 resultUV;
    ${i.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${i.defineSpecialNaN}
    ${i.defineSpecialInf}
    ${i.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Cr}
    ${Cs}
    ${fr}
  `}const Cr=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Cs=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,fr=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Sr=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function so(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function ro(i,r,o){const l=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return l[0]===1?o?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${l[1]}.0);
      }
    `:l[1]===1?o?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${l[0]}.0);
      }
    `:o?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${l[0]}, ${l[1]}));
      return 2 * (resTexRC.x * ${l[1]} + resTexRC.y);
    }
  `}function wo(i,r,o){return r[0]===1?o?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?o?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${r[0]}.0);
      }
    `:o?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return resTexRC.x * ${r[1]} + resTexRC.y;
    }
  `}function oo(i,r,o){if(o)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const l=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],c=Math.ceil(i[2]/2),f=c*Math.ceil(i[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${l[0]}, ${l[1]}));
      int index = resTexRC.x * ${l[1]} + resTexRC.y;

      int b = index / ${f};
      index -= b * ${f};

      int r = 2 * (index / ${c});
      int c = imod(index, ${c}) * 2;

      return ivec3(b, r, c);
    }
  `}function js(i,r,o){if(o)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${qs(["r","c","d"],i)}
    return ivec3(r, c, d);
  }
`;const l=wn(["r","c","d"],i);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      ${l}
      return ivec3(r, c, d);
    }
  `}function er(i,r,o){if(o)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const l=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],c=Math.ceil(i[i.length-1]/2),f=c*Math.ceil(i[i.length-2]/2);let g=f,C="",v="b, r, c";for(let D=2;D<i.length-1;D++)g*=i[i.length-D-1],C=`
      int b${D} = index / ${g};
      index -= b${D} * ${g};
    `+C,v=`b${D}, `+v;return`
    ivec${i.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${l[0]}, ${l[1]}));
      int index = resTexRC.x * ${l[1]} + resTexRC.y;

      ${C}

      int b = index / ${f};
      index -= b * ${f};

      int r = 2 * (index / ${c});
      int c = imod(index, ${c}) * 2;

      return ivec${i.length}(${v});
    }
  `}function Br(i,r,o){if(o)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${qs(["r","c","d","d2"],i)}
      return ivec4(r, c, d, d2);
    }
  `;const l=wn(["r","c","d","d2"],i);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      ${l}
      return ivec4(r, c, d, d2);
    }
  `}function tr(i,r){const o=wn(["r","c","d","d2","d3"],i);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${r[0]},
                             ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${o}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Do(i,r){const o=wn(["r","c","d","d2","d3","d4"],i);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${o}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function _o(i,r,o){const l=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(p.D5U.arraysEqual(i,r))return o?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${l[0]}, ${l[1]}));
      }
    `;const c=Math.ceil(i[1]/2);return o?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${l[0]}, ${l[1]}));

      int index = resTexRC.x * ${l[1]} + resTexRC.y;
      int r = 2 * (index / ${c});
      int c = imod(index, ${c}) * 2;

      return ivec2(r, c);
    }
  `}function ao(i,r,o){return p.D5U.arraysEqual(i,r)?o?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `:i[1]===1?o?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${r[0]}, ${r[1]}));
        int index = resTexRC.x * ${r[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:i[0]===1?o?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${r[0]}, ${r[1]}));
        int index = resTexRC.x * ${r[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:o?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = index / ${i[1]};
      int c = index - r * ${i[1]};
      return ivec2(r, c);
    }
  `}function ms(i){return`offset${i}`}function Ao(i){const r=i.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),l=Dn();return`
    vec4 ${o}() {
      return ${l.texture2D}(${r}, halfCR);
    }
  `}function jr(i,r){const o=i.name,l="get"+o.charAt(0).toUpperCase()+o.slice(1);if(i.shapeInfo.isUniform)return`float ${l}() {return ${o};}`;const[c,f]=i.shapeInfo.texShape;if(c===1&&f===1)return`
      float ${l}() {
        return sampleTexture(${o}, halfCR);
      }
    `;const g=ms(o);if(r)return`
    float ${l}() {
      vec2 uv = uvFromFlat(${o}TexShape[0], ${o}TexShape[1], ${g});
      return sampleTexture(${o}, uv);
    }
  `;const[C,v]=i.shapeInfo.texShape;return`
    float ${l}() {
      vec2 uv = uvFromFlat(${C}, ${v}, ${g});
      return sampleTexture(${o}, uv);
    }
  `}function Ws(i,r){const o=i.name,l="get"+o.charAt(0).toUpperCase()+o.slice(1),c=i.shapeInfo.texShape,f=Dn();if(r)return`
    vec4 ${l}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${o}TexShape[0]) / 2.0), ceil(float(${o}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${f.texture2D}(${o}, uv);
    }
  `;const g=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];return`
    vec4 ${l}(int index) {
      vec2 uv = packedUVfrom1D(
        ${g[0]}, ${g[1]}, index);
      return ${f.texture2D}(${o}, uv);
    }
  `}function Kr(i,r){const o=i.name,l="get"+o.charAt(0).toUpperCase()+o.slice(1);if(i.shapeInfo.isUniform)return`
      float ${l}(int index) {
        ${Ss(i)}
      }
    `;const c=i.shapeInfo.texShape,f=c[0],g=c[1];if(g===1&&f===1)return`
      float ${l}(int index) {
        return sampleTexture(${o}, halfCR);
      }
    `;const C=ms(o);return g===1?r?`
      float ${l}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${C}) + 0.5) / float(${o}TexShape[0]));
        return sampleTexture(${o}, uv);
      }
    `:`
      float ${l}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${C}) + 0.5) / ${f}.0);
        return sampleTexture(${o}, uv);
      }
    `:f===1?r?`
      float ${l}(int index) {
        vec2 uv = vec2((float(index + ${C}) + 0.5) / float(${o}TexShape[1]), 0.5);
        return sampleTexture(${o}, uv);
      }
    `:`
      float ${l}(int index) {
        vec2 uv = vec2((float(index + ${C}) + 0.5) / ${g}.0, 0.5);
        return sampleTexture(${o}, uv);
      }
    `:r?`
    float ${l}(int index) {
      vec2 uv = uvFromFlat(${o}TexShape[0], ${o}TexShape[1], index + ${C});
      return sampleTexture(${o}, uv);
    }
  `:`
    float ${l}(int index) {
      vec2 uv = uvFromFlat(${f}, ${g}, index + ${C});
      return sampleTexture(${o}, uv);
    }
  `}function zo(i,r){const o=i.shapeInfo.logicalShape,l=i.name,c="get"+l.charAt(0).toUpperCase()+l.slice(1),f=i.shapeInfo.texShape,g=f[0],C=f[1],v=Dn();if(f!=null&&p.D5U.arraysEqual(o,f))return r?`
      vec4 ${c}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}TexShape[1], ${l}TexShape[0]);

        return ${v.texture2D}(${l}, uv);
      }
    `:`
      vec4 ${c}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${C}.0, ${g}.0);

        return ${v.texture2D}(${l}, uv);
      }
    `;if(r)return`
    vec4 ${c}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${l}TexShape[0]) / 2.0), ceil(float(${l}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${l}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${v.texture2D}(${l}, uv);
    }
  `;const D=[Math.ceil(f[0]/2),Math.ceil(f[1]/2)],F=Math.ceil(o[1]/2);return`
    vec4 ${c}(int row, int col) {
      vec2 uv = packedUVfrom2D(${F}, ${D[0]}, ${D[1]}, row, col);
      return ${v.texture2D}(${l}, uv);
    }
  `}function vo(i,r){const o=i.shapeInfo.logicalShape,l=i.name,c="get"+l.charAt(0).toUpperCase()+l.slice(1),f=i.shapeInfo.texShape;if(f!=null&&p.D5U.arraysEqual(o,f)){if(r)return`
      float ${c}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}TexShape[1], ${l}TexShape[0]);
        return sampleTexture(${l}, uv);
      }
    `;const Y=f[0],te=f[1];return`
    float ${c}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${te}.0, ${Y}.0);
      return sampleTexture(${l}, uv);
    }
  `}const{newShape:g,keptDims:C}=p.D5U.squeezeShape(o),v=g;if(v.length<o.length){const Y=ar(i,v),te=["row","col"];return`
      ${Zs(Y,r)}
      float ${c}(int row, int col) {
        return ${c}(${nr(te,C)});
      }
    `}if(i.shapeInfo.isUniform)return`
      float ${c}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${o[1]}, 1)));
        ${Ss(i)}
      }
    `;const D=f[0],F=f[1],H=ms(l);return F===1?r?`
      float ${c}(int row, int col) {
        float index = dot(vec3(row, col, ${H}), vec3(${l}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${l}TexShape[0]));
        return sampleTexture(${l}, uv);
      }
    `:`
    float ${c}(int row, int col) {
      float index = dot(vec3(row, col, ${H}), vec3(${o[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${D}.0);
      return sampleTexture(${l}, uv);
    }
  `:D===1?r?`
      float ${c}(int row, int col) {
        float index = dot(vec3(row, col, ${H}), vec3(${l}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${l}TexShape[1]), 0.5);
        return sampleTexture(${l}, uv);
      }
    `:`
    float ${c}(int row, int col) {
      float index = dot(vec3(row, col, ${H}), vec3(${o[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${F}.0, 0.5);
      return sampleTexture(${l}, uv);
    }
  `:r?`
      float ${c}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${l}Shape[1] + col + ${H};
        vec2 uv = uvFromFlat(${l}TexShape[0], ${l}TexShape[1], index);
        return sampleTexture(${l}, uv);
      }
    `:`
  float ${c}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${o[1]} + col + ${H};
    vec2 uv = uvFromFlat(${D}, ${F}, index);
    return sampleTexture(${l}, uv);
  }
`}function Po(i,r){const o=i.shapeInfo.logicalShape,l=i.name,c="get"+l.charAt(0).toUpperCase()+l.slice(1),f=i.shapeInfo.texShape,g=[Math.ceil(f[0]/2),Math.ceil(f[1]/2)];if(o[0]===1){const Y=o.slice(1),te=[1,2],ae=ar(i,Y),Ce=["b","row","col"];return`
        ${Ms(ae,r)}
        vec4 ${c}(int b, int row, int col) {
          return ${c}(${nr(Ce,te)});
        }
      `}const C=Dn();if(r)return`
    vec4 ${c}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${l}TexShape[0]) / 2.0), ceil(float(${l}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${l}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${l}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${C.texture2D}(${l}, uv);
    }
  `;const v=g[0],D=g[1],F=Math.ceil(o[2]/2),H=F*Math.ceil(o[1]/2);return`
    vec4 ${c}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${v}, ${D}, ${H}, ${F}, b, row, col);
      return ${C.texture2D}(${l}, uv);
    }
  `}function cs(i,r){const o=i.shapeInfo.logicalShape,l=i.name,c="get"+l.charAt(0).toUpperCase()+l.slice(1),f=o[1]*o[2],g=o[2],{newShape:C,keptDims:v}=p.D5U.squeezeShape(o),D=C;if(D.length<o.length){const Ce=ar(i,D),Le=["row","col","depth"];return`
        ${Zs(Ce,r)}
        float ${c}(int row, int col, int depth) {
          return ${c}(${nr(Le,v)});
        }
      `}if(i.shapeInfo.isUniform)return`
      float ${c}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${f}, ${g}, 1)));
        ${Ss(i)}
      }
    `;const F=i.shapeInfo.texShape,H=F[0],Y=F[1],te=i.shapeInfo.flatOffset;if(Y===f&&te==null)return r?`
      float ${c}(int row, int col, int depth) {
        int stride1 = ${l}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${l}TexShape[1], ${l}TexShape[0]);
        return sampleTexture(${l}, uv);
      }
    `:`
        float ${c}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${g}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${Y}.0, ${H}.0);
          return sampleTexture(${l}, uv);
        }
      `;if(Y===g&&te==null)return r?`
      float ${c}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${l}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}TexShape[1], ${l}TexShape[0]);
        return sampleTexture(${l}, uv);
      }
    `:`
    float ${c}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${o[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${Y}.0, ${H}.0);
      return sampleTexture(${l}, uv);
    }
  `;const ae=ms(l);return r?`
    float ${c}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${l}Shape[1] * ${l}Shape[2];
      int stride1 = ${l}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${ae};
      vec2 uv = uvFromFlat(${l}TexShape[0], ${l}TexShape[1], index);
      return sampleTexture(${l}, uv);
    }
    `:`
      float ${c}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${f} + col * ${g} + depth + ${ae};
        vec2 uv = uvFromFlat(${H}, ${Y}, index);
        return sampleTexture(${l}, uv);
      }
  `}function as(i,r){const o=i.name,l="get"+o.charAt(0).toUpperCase()+o.slice(1),c=Dn();if(r)return`
    vec4 ${l}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${o}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${o}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${o}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${o}TexShape[0]) / 2.0), ceil(float(${o}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${c.texture2D}(${o}, uv);
    }
  `;const f=i.shapeInfo.logicalShape,g=f.length,C=i.shapeInfo.texShape,v=[Math.ceil(C[0]/2),Math.ceil(C[1]/2)],D=v[0],F=v[1],H=Math.ceil(f[g-1]/2);let Y=H*Math.ceil(f[g-2]/2),te="int b, int row, int col",ae=`b * ${Y} + (row / 2) * ${H} + (col / 2)`;for(let Ce=2;Ce<g-1;Ce++)te=`int b${Ce}, `+te,Y*=f[g-Ce-1],ae=`b${Ce} * ${Y} + `+ae;return`
    vec4 ${l}(${te}) {
      int index = ${ae};
      int texR = index / ${F};
      int texC = index - texR * ${F};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${F}, ${D});
      return ${c.texture2D}(${o}, uv);
    }
  `}function Oo(i,r){const o=i.shapeInfo.logicalShape,l=i.name,c="get"+l.charAt(0).toUpperCase()+l.slice(1),f=o[3],g=o[2]*f,C=o[1]*g,{newShape:v,keptDims:D}=p.D5U.squeezeShape(o);if(v.length<o.length){const Ge=ar(i,v),Et=["row","col","depth","depth2"];return`
      ${Zs(Ge,r)}
      float ${c}(int row, int col, int depth, int depth2) {
        return ${c}(${nr(Et,D)});
      }
    `}if(i.shapeInfo.isUniform)return`
      float ${c}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${C}, ${g}, ${f}, 1)));
        ${Ss(i)}
      }
    `;const F=i.shapeInfo.flatOffset,H=i.shapeInfo.texShape,Y=H[0],te=H[1],ae=`int stride2 = ${l}Shape[3];`,Ce=`int stride1 = ${l}Shape[2] * stride2;`,Le=`int stride0 = ${l}Shape[1] * stride1;`;if(te===C&&F==null)return r?`
      float ${c}(int row, int col, int depth, int depth2) {
        ${ae}
        ${Ce}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${l}TexShape[1], ${l}TexShape[0]);
        return sampleTexture(${l}, uv);
      }
    `:`
      float ${c}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${g}, ${f}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${te}.0, ${Y}.0);
        return sampleTexture(${l}, uv);
      }
    `;if(te===f&&F==null)return r?`
      float ${c}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${l}Shape[1] * ${l}Shape[2], ${l}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${l}TexShape[1], ${l}TexShape[0]);
        return sampleTexture(${l}, uv);
      }
    `:`
      float ${c}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${o[1]*o[2]}, ${o[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${te}.0, ${Y}.0);
        return sampleTexture(${l}, uv);
      }
    `;const be=ms(l);return r?`
    float ${c}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${ae}
      ${Ce}
      ${Le}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${l}TexShape[0], ${l}TexShape[1], index + ${be});
      return sampleTexture(${l}, uv);
    }
  `:`
    float ${c}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${C} + col * ${g} +
          depth * ${f} + depth2;
      vec2 uv = uvFromFlat(${Y}, ${te}, index + ${be});
      return sampleTexture(${l}, uv);
    }
  `}function Lr(i){const r=i.shapeInfo.logicalShape,o=i.name,l="get"+o.charAt(0).toUpperCase()+o.slice(1),c=r[4],f=r[3]*c,g=r[2]*f,C=r[1]*g,{newShape:v,keptDims:D}=p.D5U.squeezeShape(r);if(v.length<r.length){const Ce=ar(i,v),Le=["row","col","depth","depth2","depth3"];return`
      ${Zs(Ce)}
      float ${l}(int row, int col, int depth, int depth2, int depth3) {
        return ${l}(${nr(Le,D)});
      }
    `}if(i.shapeInfo.isUniform)return`
      float ${l}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${C}, ${g}, ${f}, ${c})) +
          depth3;
        ${Ss(i)}
      }
    `;const F=i.shapeInfo.flatOffset,H=i.shapeInfo.texShape,Y=H[0],te=H[1];if(te===C&&F==null)return`
      float ${l}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${g}, ${f}, ${c}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${te}.0, ${Y}.0);
        return sampleTexture(${o}, uv);
      }
    `;if(te===c&&F==null)return`
      float ${l}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${r[1]*r[2]*r[3]},
               ${r[2]*r[3]}, ${r[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${te}.0, ${Y}.0);
        return sampleTexture(${o}, uv);
      }
    `;const ae=ms(o);return`
    float ${l}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${C} + col * ${g} + depth * ${f} +
          depth2 * ${c} + depth3 + ${ae};
      vec2 uv = uvFromFlat(${Y}, ${te}, index);
      return sampleTexture(${o}, uv);
    }
  `}function Co(i){const r=i.shapeInfo.logicalShape,o=i.name,l="get"+o.charAt(0).toUpperCase()+o.slice(1),{newShape:c,keptDims:f}=p.D5U.squeezeShape(r);if(c.length<r.length){const Le=ar(i,c),be=["row","col","depth","depth2","depth3","depth4"];return`
      ${Zs(Le)}
      float ${l}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${l}(${nr(be,f)});
      }
    `}const g=r[5],C=r[4]*g,v=r[3]*C,D=r[2]*v,F=r[1]*D;if(i.shapeInfo.isUniform)return`
      float ${l}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${F}, ${D}, ${v}, ${C})) +
          dot(
            vec2(depth3, depth4),
            vec2(${g}, 1)));
        ${Ss(i)}
      }
    `;const H=i.shapeInfo.flatOffset,Y=i.shapeInfo.texShape,te=Y[0],ae=Y[1];if(ae===F&&H==null)return`
      float ${l}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${D}, ${v}, ${C}, ${g})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${ae}.0, ${te}.0);
        return sampleTexture(${o}, uv);
      }
    `;if(ae===g&&H==null)return`
      float ${l}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${r[1]*r[2]*r[3]*r[4]},
               ${r[2]*r[3]*r[4]},
               ${r[3]*r[4]},
               ${r[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${ae}.0, ${te}.0);
        return sampleTexture(${o}, uv);
      }
    `;const Ce=ms(o);return`
    float ${l}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${F} + col * ${D} + depth * ${v} +
          depth2 * ${C} + depth3 * ${g} + depth4 + ${Ce};
      vec2 uv = uvFromFlat(${te}, ${ae}, index);
      return sampleTexture(${o}, uv);
    }
  `}function Ss(i){const r=i.name,o=p.D5U.sizeFromShape(i.shapeInfo.logicalShape);return o<2?`return ${r};`:`
    for (int i = 0; i < ${o}; i++) {
      if (i == index) {
        return ${r}[i];
      }
    }
  `}function fs(i,r){const o=i.name,l=o.charAt(0).toUpperCase()+o.slice(1),c="get"+l+"AtOutCoords",f=i.shapeInfo.logicalShape.length,g=r.logicalShape.length,C=Qs(i.shapeInfo.logicalShape,r.logicalShape),v=An(g),D=g-f;let F;const H=["x","y","z","w","u","v"];f===0?F="":g<2&&C.length>=1?F="coords = 0;":F=C.map(Ge=>`coords.${H[Ge+D]} = 0;`).join(`
`);let Y="";g<2&&f>0?Y="coords":Y=i.shapeInfo.logicalShape.map((Ge,Et)=>`coords.${H[Et+D]}`).join(", ");let te="return outputValue;";const Ce=p.D5U.sizeFromShape(i.shapeInfo.logicalShape)===1,be=p.D5U.sizeFromShape(r.logicalShape)===1;if(f===1&&!Ce&&!be)te=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(Ce&&!be)g===1?te=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:te=`
        return vec4(outputValue.x);
      `;else if(C.length){const Ge=f-2,Et=f-1;C.indexOf(Ge)>-1&&C.indexOf(Et)>-1?te="return vec4(outputValue.x);":C.indexOf(Ge)>-1?te="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":C.indexOf(Et)>-1&&(te="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${c}() {
      ${v} coords = getOutputCoords();
      ${F}
      vec4 outputValue = get${l}(${Y});
      ${te}
    }
  `}function uo(i,r){const o=i.name,l=o.charAt(0).toUpperCase()+o.slice(1),c="get"+l+"AtOutCoords",f=r.texShape,g=i.shapeInfo.texShape,C=i.shapeInfo.logicalShape.length,v=r.logicalShape.length;if(!i.shapeInfo.isUniform&&C===v&&i.shapeInfo.flatOffset==null&&p.D5U.arraysEqual(g,f))return`
      float ${c}() {
        return sampleTexture(${o}, resultUV);
      }
    `;const D=An(v),F=Qs(i.shapeInfo.logicalShape,r.logicalShape),H=v-C;let Y;const te=["x","y","z","w","u","v"];C===0?Y="":v<2&&F.length>=1?Y="coords = 0;":Y=F.map(Ce=>`coords.${te[Ce+H]} = 0;`).join(`
`);let ae="";return v<2&&C>0?ae="coords":ae=i.shapeInfo.logicalShape.map((Ce,Le)=>`coords.${te[Le+H]}`).join(", "),`
    float ${c}() {
      ${D} coords = getOutputCoords();
      ${Y}
      return get${l}(${ae});
    }
  `}function An(i){if(i<=1)return"int";if(i===2)return"ivec2";if(i===3)return"ivec3";if(i===4)return"ivec4";if(i===5)return"ivec5";if(i===6)return"ivec6";throw Error(`GPU for rank ${i} is not yet supported`)}function Ur(i,r,o){const{newShape:l,keptDims:c}=p.D5U.squeezeShape(r),f=r.length,g=i&&f===3&&r[0]===1,C=g?r.slice(1):l,v=!i&&f>1&&!p.D5U.arraysEqual(r,o)&&l.length<f||g;return{useSqueezeShape:v,uniformShape:v?C:r,keptDims:c}}function ar(i,r){const o=JSON.parse(JSON.stringify(i));return o.shapeInfo.logicalShape=r,o}function nr(i,r){return r.map(o=>i[o]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ir(i,r,o,l){const c=o.map((F,H)=>{const Y={logicalShape:F.shape,texShape:F.isUniform?null:F.texData.texShape,isUniform:F.isUniform,isPacked:F.isUniform?!1:F.texData.isPacked,flatOffset:null};return F.texData!=null&&F.texData.slice!=null&&F.texData.slice.flatOffset>0&&(Y.flatOffset=F.texData.slice.flatOffset),{name:r.variableNames[H],shapeInfo:Y}}),f=c.map(F=>F.shapeInfo),g={logicalShape:l.shape,texShape:l.texData.texShape,isUniform:!1,isPacked:l.texData.isPacked,flatOffset:null},C=Jo(c,g,r),v=at(i.gl,C),D=i.createProgram(v);return(0,p.OBj)().get("ENGINE_COMPILE_ONLY")?{program:r,fragmentShader:v,source:C,webGLProgram:D,inShapeInfos:f,outShapeInfo:g,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(i.buildVao(D),Object.assign({program:r,fragmentShader:v,source:C,webGLProgram:D,inShapeInfos:f,outShapeInfo:g},So(i,r,D)))}function So(i,r,o){const l=[],c=[];let f,g,C,v=null,D=null;D=i.getUniformLocation(o,"NAN",!1),(0,p.OBj)().getNumber("WEBGL_VERSION")===1&&(v=i.getUniformLocation(o,"INFINITY",!1));const F=!1;for(const H of r.variableNames){const Y={name:H,uniform:i.getUniformLocation(o,H,F),offset:i.getUniformLocation(o,`offset${H}`,F)};r.enableShapeUniforms&&(Y.shape=i.getUniformLocation(o,`${H}Shape`,F),Y.texShape=i.getUniformLocation(o,`${H}TexShape`,F)),l.push(Y)}if(r.enableShapeUniforms&&(f=i.getUniformLocation(o,"outShape",F),C=i.getUniformLocation(o,"outShapeStrides",F),g=i.getUniformLocation(o,"outTexShape",F)),r.customUniforms)for(const H of r.customUniforms)c.push(i.getUniformLocation(o,H.name,F));return{variablesLocations:l,customUniformLocations:c,infLoc:v,nanLoc:D,outShapeLocation:f,outShapeStridesLocation:C,outTexShapeLocation:g}}function Mr(i,r){if(i.length!==r.length)throw Error(`Binary was compiled with ${i.length} inputs, but was executed with ${r.length} inputs`);i.forEach((o,l)=>{const c=o.logicalShape,f=r[l],g=f.shape;if(!p.D5U.arraysEqual(c,g))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${c} and ${g} must match`);if(o.isUniform&&f.isUniform)return;const C=o.texShape,v=f.isUniform?null:f.texData.texShape;if(!p.D5U.arraysEqual(C,v))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${C} and ${v} must match`)})}function Ye(i,r,o,l,c){r.program.enableShapeUniforms||(Mr(r.inShapeInfos,o),Mr([r.outShapeInfo],[l]));const f=l.texData.texture,g=l.texData.texShape;l.texData.isPacked?i.setOutputPackedMatrixTexture(f.texture,g[0],g[1]):i.setOutputMatrixTexture(f.texture,g[0],g[1]),i.setProgram(r.webGLProgram),i.bindVertexArray(r.webGLProgram.vao),(0,p.OBj)().getNumber("WEBGL_VERSION")===1&&r.infLoc!==null&&i.gl.uniform1f(r.infLoc,1/0),r.nanLoc!==null&&i.gl.uniform1f(r.nanLoc,NaN);for(let v=0;v<o.length;++v){const D=o[v],{uniform:F,offset:H,shape:Y,texShape:te}=r.variablesLocations[v];if(Y){const{uniformShape:ae}=Ur(r.program.packedInputs,D.shape,D.texData.texShape);switch(ae.length){case 1:i.gl.uniform1iv(Y,new Int32Array(ae));break;case 2:i.gl.uniform2iv(Y,new Int32Array(ae));break;case 3:i.gl.uniform3iv(Y,new Int32Array(ae));break;case 4:i.gl.uniform4iv(Y,new Int32Array(ae));break;default:break}}if(te&&i.gl.uniform2i(te,D.texData.texShape[0],D.texData.texShape[1]),F!=null){if(D.isUniform){if(p.D5U.sizeFromShape(D.shape)<2)i.gl.uniform1f(F,D.uniformValues[0]);else{let ae=D.uniformValues;ae instanceof Float32Array||(ae=new Float32Array(ae)),i.gl.uniform1fv(F,ae)}continue}D.texData.slice!=null&&H!=null&&i.gl.uniform1i(H,D.texData.slice.flatOffset),i.setInputMatrixTexture(D.texData.texture.texture,F,v)}}const C=r.outShapeLocation;if(C)switch(l.shape.length){case 1:i.gl.uniform1iv(C,new Int32Array(l.shape));break;case 2:i.gl.uniform2iv(C,new Int32Array(l.shape));break;case 3:i.gl.uniform3iv(C,new Int32Array(l.shape));break;case 4:i.gl.uniform4iv(C,new Int32Array(l.shape));break;default:break}if(r.outShapeStridesLocation){const v=p.D5U.computeStrides(l.shape);switch(l.shape.length){case 2:i.gl.uniform1iv(r.outShapeStridesLocation,new Int32Array(v));break;case 3:i.gl.uniform2iv(r.outShapeStridesLocation,new Int32Array(v));break;case 4:i.gl.uniform3iv(r.outShapeStridesLocation,new Int32Array(v));break;default:break}}if(r.outTexShapeLocation&&i.gl.uniform2i(r.outTexShapeLocation,l.texData.texShape[0],l.texData.texShape[1]),r.program.customUniforms&&c)for(let v=0;v<r.program.customUniforms.length;++v){const D=r.program.customUniforms[v],F=r.customUniformLocations[v],H=c[v];if(D.type==="float")i.gl.uniform1fv(F,H);else if(D.type==="vec2")i.gl.uniform2fv(F,H);else if(D.type==="vec3")i.gl.uniform3fv(F,H);else if(D.type==="vec4")i.gl.uniform4fv(F,H);else if(D.type==="int")i.gl.uniform1iv(F,H);else if(D.type==="ivec2")i.gl.uniform2iv(F,H);else if(D.type==="ivec3")i.gl.uniform3iv(F,H);else if(D.type==="ivec4")i.gl.uniform4iv(F,H);else throw Error(`uniform type ${D.type} is not supported yet.`)}i.executeProgram()}function Ir(i,r,o){let l="";r.concat(o).forEach(g=>{const C=g.texData!=null&&g.texData.slice!=null&&g.texData.slice.flatOffset>0;if(i.enableShapeUniforms&&!g.isUniform){const v=g.texData.texShape,{useSqueezeShape:D,uniformShape:F,keptDims:H}=Ur(i.packedInputs,g.shape,v);let Y="",te="",ae="";if(F.length===1&&i.packedInputs){const jt=[Math.ceil(v[0]/2),Math.ceil(v[1]/2)];Y=`${jt[0]>1}_${jt[1]>1}`}else if(F.length===2&&!i.packedInputs)te=`${F[0]>1}_${F[1]>1}`;else if(F.length>2&&!i.packedInputs){const jt=p.D5U.computeStrides(F);ae=`${jt[0]===v[1]}_${jt[jt.length-1]===v[1]}`}const Ce=g.shape.length,Le=F.length===2&&p.D5U.arraysEqual(g.shape,v),be=p.D5U.sizeFromShape(g.shape)===1,Ge=p.Wap.getBroadcastDims(g.shape,o.shape),Et=!i.packedInputs&&Ce===o.shape.length&&p.D5U.arraysEqual(v,o.texData.texShape),vt=i.packedInputs||F.length>2?"":`${v[0]>1}_${v[1]>1}`;l+=`${Ce}_${Et}_${D?H:""}_${F.length}_${be}_${Ge}_${Le}_${Y}_${te}_${ae}_${vt}_${C}`}else{const v=g.isUniform?"uniform":g.texData.texShape;l+=`${g.shape}_${v}_${C}`}});const c=i.userCode;let f=i.constructor.name;return f+="_"+l+"_"+c+`${(0,p.OBj)().getNumber("WEBGL_VERSION")}`,f}function Jn(i){return(0,p.OBj)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&i<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Er{constructor(r){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=we.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const o=Dn();this.outputShape=r,this.enableShapeUniforms=Jn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?qs(["r","c","d"],r):wn(["r","c","d"],r)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${o.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wr{constructor(r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=we.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const o=Dn();this.outputShape=r,this.enableShapeUniforms=Jn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?qs(["r","c","d"],r):wn(["r","c","d"],r)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${o.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fs{constructor(r){this.variableNames=["A"],this.outTexUsage=xe.DOWNLOAD;const o=Dn();this.outputShape=r,this.userCode=`
      ${Os}

      void main() {
        float x = getAAtOutCoords();
        ${o.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ur{constructor(r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=xe.DOWNLOAD;const o=Dn();this.outputShape=r,this.userCode=`
      ${Os}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${o.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Se={R:0,G:1,B:2,A:3};class fe{constructor(r,o=!1,l="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const c=Dn();this.outputShape=r,this.enableShapeUniforms=Jn(this.outputShape.length);let f="result";o&&(f="floor(result * 255. + 0.5)");let g="";for(let C=0;C<l.length;C++){const v=l[C];g+=`
          if(offset == ${C}) {
            result = values[${Se[v]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Or():vr(r)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${l.length});

        flatIndex = idiv(flatIndex, ${l.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${c.texture2D}(A, uv);
          ${g}
        }
        ${c.output} = vec4(${f}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class de{constructor(r,o=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const l=Dn();this.outputShape=r,this.enableShapeUniforms=Jn(this.outputShape.length);let c="",f="result";o&&(f="floor(result * 255. + 0.5)");for(let g=0;g<=1;g++)for(let C=0;C<=1;C++){const v=g*2+C;c+=`
          localCoords = coords;
          if(localCoords[2] + ${C} < ${this.enableShapeUniforms?"outShape[2]":`${r[2]}`}) {
          localCoords[2] += ${C};
          if (localCoords[1] + ${g} < ${this.enableShapeUniforms?"outShape[1]":`${r[1]}`}) {
            localCoords[1] += ${g};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${l.texture2D}(A, uv);

            if (offset == 0) {
              result[${v}] = values[0];
            } else if (offset == 1) {
              result[${v}] = values[1];
            } else if (offset == 2) {
              result[${v}] = values[2];
            } else {
              result[${v}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Or():vr(r)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${c}

          ${l.output} = ${f};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ee(i){const r=Dn(),o=`${r.version}
    precision highp float;
    ${r.attribute} vec3 clipSpacePos;
    ${r.attribute} vec2 uv;
    ${r.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return Be(i,o)}function Ae(i){const r=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return ce(i,r)}function Pe(i){const r=new Uint16Array([0,1,2,2,1,3]);return me(i,r)}function We(i,r,o,l,c,f){Lt(r,o);const g=ct(i),C=i.TEXTURE_2D;return ve(i,()=>i.bindTexture(C,g)),ve(i,()=>i.texParameteri(C,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE)),ve(i,()=>i.texParameteri(C,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE)),ve(i,()=>i.texParameteri(C,i.TEXTURE_MIN_FILTER,i.NEAREST)),ve(i,()=>i.texParameteri(C,i.TEXTURE_MAG_FILTER,i.NEAREST)),(0,p.OBj)().getNumber("WEBGL_VERSION")===1?ve(i,()=>i.texImage2D(C,0,l,r,o,0,c,f,null)):ve(i,()=>i.texStorage2D(C,1,l,r,o)),ve(i,()=>i.bindTexture(i.TEXTURE_2D,null)),{texture:g,texShape:[o,r]}}function je(i){return i.internalFormatFloat}function Oe(i,r,o,l){const[c,f]=_(r,o);return We(i,c,f,je(l),l.textureFormatFloat,i.FLOAT)}function st(i){return i.internalFormatHalfFloat}function ut(i,r,o,l){const[c,f]=_(r,o);return We(i,c,f,st(l),l.textureFormatFloat,l.textureTypeHalfFloat)}function tt(i){return i.downloadTextureFormat}function yt(i,r,o,l){const[c,f]=_(r,o);return We(i,c,f,tt(l),i.RGBA,i.UNSIGNED_BYTE)}function At(i){return i.internalFormatPackedFloat}function xt(i,r,o,l){const[c,f]=Vt(r,o);return We(i,c,f,At(l),i.RGBA,i.FLOAT)}function Qt(i){return i.internalFormatPackedHalfFloat}function gt(i,r,o,l){const[c,f]=Vt(r,o);return We(i,c,f,Qt(l),i.RGBA,l.textureTypeHalfFloat)}function Ct(i,r,o){return ve(i,()=>i.bindBuffer(i.ARRAY_BUFFER,o)),ln(i,r,"clipSpacePos",o,3,20,0)&&ln(i,r,"uv",o,2,20,12)}function Pt(i,r,o,l,c,f){ve(i,()=>i.bindTexture(i.TEXTURE_2D,r));let g,C,v;c instanceof Uint8Array?(g=new Uint8Array(o*l*4),C=i.UNSIGNED_BYTE,v=i.RGBA):(g=new Float32Array(o*l*4),C=i.FLOAT,v=f.internalFormatPackedFloat),g.set(c),(0,p.OBj)().getNumber("WEBGL_VERSION")===2?ve(i,()=>i.texSubImage2D(i.TEXTURE_2D,0,0,0,o,l,i.RGBA,C,g)):ve(i,()=>i.texImage2D(i.TEXTURE_2D,0,v,o,l,0,i.RGBA,C,g)),ve(i,()=>i.bindTexture(i.TEXTURE_2D,null))}function fn(i,r,o){ve(i,()=>i.bindTexture(i.TEXTURE_2D,r)),o.data instanceof Uint8Array?(0,p.OBj)().getNumber("WEBGL_VERSION")===2?ve(i,()=>i.texSubImage2D(i.TEXTURE_2D,0,0,0,o.width,o.height,i.RGBA,i.UNSIGNED_BYTE,o.data)):ve(i,()=>i.texImage2D(i.TEXTURE_2D,0,i.RGBA,o.width,o.height,0,i.RGBA,i.UNSIGNED_BYTE,o.data)):(0,p.OBj)().getNumber("WEBGL_VERSION")===2?ve(i,()=>i.texSubImage2D(i.TEXTURE_2D,0,0,0,i.RGBA,i.UNSIGNED_BYTE,o)):ve(i,()=>i.texImage2D(i.TEXTURE_2D,0,i.RGBA,i.RGBA,i.UNSIGNED_BYTE,o)),ve(i,()=>i.bindTexture(i.TEXTURE_2D,null))}function pn(i,r,o,l){const c=i.createBuffer();ve(i,()=>i.bindBuffer(i.PIXEL_PACK_BUFFER,c));const C=4*4*r*o;return ve(i,()=>i.bufferData(i.PIXEL_PACK_BUFFER,C,i.STREAM_READ)),ve(i,()=>i.readPixels(0,0,o,r,i.RGBA,i.FLOAT,0)),ve(i,()=>i.bindBuffer(i.PIXEL_PACK_BUFFER,null)),c}function Pn(i,r,o){const l=i,c=new Float32Array(o);return l.bindBuffer(l.PIXEL_PACK_BUFFER,r),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function Jt(i,r,o,l){const[c,f]=_(r,o),g=4,C=new Uint8Array(De(r*o,g));return ve(i,()=>i.readPixels(0,0,c,f,l.downloadTextureFormat,i.UNSIGNED_BYTE,C)),new Float32Array(C.buffer)}function Cn(i,r,o,l,c,f,g,C){const v=i,D=new Float32Array(on(f,g));return v.bindBuffer(v.PIXEL_PACK_BUFFER,r),v.getBufferSubData(v.PIXEL_PACK_BUFFER,0,D),v.bindBuffer(v.PIXEL_PACK_BUFFER,null),D}function Hn(i,r,o){const l=new Float32Array(r*o*4);return ve(i,()=>i.readPixels(0,0,o,r,i.RGBA,i.FLOAT,l)),l}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kt{constructor(r){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const o=(0,p.OBj)().getNumber("WEBGL_VERSION");if(r!=null?(this.gl=r,P(o,r)):this.gl=W(o),r=this.gl,(0,p.OBj)().getNumber("WEBGL_VERSION")===2){const f=r;this.createVertexArray=()=>ve(f,()=>f.createVertexArray()),this.bindVertexArray=g=>ve(f,()=>f.bindVertexArray(g)),this.deleteVertexArray=g=>ve(f,()=>f.deleteVertexArray(g)),this.getVertexArray=()=>ve(f,()=>f.getParameter(f.VERTEX_ARRAY_BINDING))}else if(r!=null){const f=r.getExtension("OES_vertex_array_object");if(f==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ve(r,()=>f.createVertexArrayOES()),this.bindVertexArray=g=>ve(r,()=>f.bindVertexArrayOES(g)),this.deleteVertexArray=g=>ve(r,()=>f.deleteVertexArrayOES(g)),this.getVertexArray=()=>ve(r,()=>r.getParameter(f.VERTEX_ARRAY_BINDING_OES))}let l="WEBGL_color_buffer_float";const c="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),(0,p.OBj)().getNumber("WEBGL_VERSION")===1){const f="OES_texture_float",g="OES_texture_half_float";if(this.textureFloatExtension=Re(this.gl,f),ks(this.gl,g))this.textureHalfFloatExtension=Re(this.gl,g);else if((0,p.OBj)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(l),ks(this.gl,c))this.colorBufferHalfFloatExtension=Re(this.gl,c);else if((0,p.OBj)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(l="EXT_color_buffer_float",ks(this.gl,l))this.colorBufferFloatExtension=this.gl.getExtension(l);else if(ks(this.gl,c))this.colorBufferHalfFloatExtension=this.gl.getExtension(c);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=Ae(this.gl),this.indexBuffer=Pe(this.gl),this.framebuffer=Nt(this.gl),this.textureConfig=$t(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,p.OBj)().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const r=this.gl;ve(r,()=>r.finish()),ve(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,null)),ve(r,()=>r.deleteFramebuffer(this.framebuffer)),ve(r,()=>r.bindBuffer(r.ARRAY_BUFFER,null)),ve(r,()=>r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,null)),ve(r,()=>r.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(r,o){return this.throwIfDisposed(),Oe(this.gl,r,o,this.textureConfig)}createFloat16MatrixTexture(r,o){return this.throwIfDisposed(),ut(this.gl,r,o,this.textureConfig)}createUnsignedBytesMatrixTexture(r,o){return this.throwIfDisposed(),yt(this.gl,r,o,this.textureConfig)}uploadPixelDataToTexture(r,o){this.throwIfDisposed(),fn(this.gl,r,o)}uploadDenseMatrixToTexture(r,o,l,c){this.throwIfDisposed(),Pt(this.gl,r,o,l,c,this.textureConfig)}createFloat16PackedMatrixTexture(r,o){return this.throwIfDisposed(),gt(this.gl,r,o,this.textureConfig)}createPackedMatrixTexture(r,o){return this.throwIfDisposed(),xt(this.gl,r,o,this.textureConfig)}deleteMatrixTexture(r){this.throwIfDisposed(),this.outputTexture===r&&(Te(this.gl,this.framebuffer),this.outputTexture=null),ve(this.gl,()=>this.gl.deleteTexture(r))}downloadByteEncodedFloatMatrixFromOutputTexture(r,o,l){return this.downloadMatrixDriver(r,()=>Jt(this.gl,o,l,this.textureConfig))}downloadPackedMatrixFromBuffer(r,o,l,c,f,g){return Cn(this.gl,r,o,l,c,f,g,this.textureConfig)}downloadFloat32MatrixFromBuffer(r,o){return Pn(this.gl,r,o)}createBufferFromTexture(r,o,l){this.bindTextureToFrameBuffer(r);const c=pn(this.gl,o,l,this.textureConfig);return this.unbindTextureToFrameBuffer(),c}createAndWaitForFence(){const r=this.createFence(this.gl);return this.pollFence(r)}createFence(r){let o,l;if((0,p.OBj)().getBool("WEBGL_FENCE_API_ENABLED")){const c=r,f=c.fenceSync(c.SYNC_GPU_COMMANDS_COMPLETE,0);r.flush(),l=()=>{const g=c.clientWaitSync(f,0,0);return g===c.ALREADY_SIGNALED||g===c.CONDITION_SATISFIED},o=f}else(0,p.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(o=this.beginQuery(),this.endQuery(),l=()=>this.isQueryAvailable(o,(0,p.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):l=()=>!0;return{query:o,isFencePassed:l}}downloadMatrixFromPackedTexture(r,o,l){return this.downloadMatrixDriver(r,()=>Hn(this.gl,o,l))}createProgram(r){this.throwIfDisposed();const o=this.gl;this.vertexShader==null&&(this.vertexShader=Ee(o));const l=ne(o);ve(o,()=>o.attachShader(l,this.vertexShader)),ve(o,()=>o.attachShader(l,r)),Ne(o,l);const c=Object.assign(l,{vao:this.createVertexArray()});return this.debug&&Ve(o,c),c}buildVao(r){this.setProgram(r),this.bindVertexArray(r.vao);const o=this.gl;ve(o,()=>o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),Ct(o,r,this.vertexBuffer)}deleteProgram(r){this.throwIfDisposed(),r===this.program&&(this.program=null),r!=null&&(ve(this.gl,()=>this.gl.deleteProgram(r)),this.deleteVertexArray(r.vao))}setProgram(r){this.throwIfDisposed(),this.program=r,this.program!=null&&this.debug&&Ve(this.gl,this.program),ve(this.gl,()=>this.gl.useProgram(r))}getUniformLocation(r,o,l=!0){return this.throwIfDisposed(),l?kn(this.gl,r,o):bn(this.gl,r,o)}getAttributeLocation(r,o){return this.throwIfDisposed(),ve(this.gl,()=>this.gl.getAttribLocation(r,o))}getUniformLocationNoThrow(r,o){return this.throwIfDisposed(),this.gl.getUniformLocation(r,o)}setInputMatrixTexture(r,o,l){this.throwIfDisposed(),this.throwIfNoProgram(),nn(this.gl,r,o,l)}setOutputMatrixTexture(r,o,l){this.setOutputMatrixTextureDriver(r,l,o)}setOutputPackedMatrixTexture(r,o,l){this.throwIfDisposed();const[c,f]=Vt(o,l);this.setOutputMatrixTextureDriver(r,c,f)}setOutputMatrixWriteRegion(r,o,l,c){this.setOutputMatrixWriteRegionDriver(l,r,c,o)}setOutputPackedMatrixWriteRegion(r,o,l,c){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Ve(this.gl,this.program),Je(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const r=this.gl;if(this.debug){const o=this.getVertexArray();console.assert(o===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}ve(r,()=>r.drawElements(r.TRIANGLES,6,r.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ve(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Re(this.gl,(0,p.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if((0,p.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const l=this.gl,c=this.getQueryTimerExtensionWebGL2(),f=l.createQuery();return l.beginQuery(c.TIME_ELAPSED_EXT,f),f}const r=this.getQueryTimerExtensionWebGL1(),o=r.createQueryEXT();return r.beginQueryEXT(r.TIME_ELAPSED_EXT,o),o}endQuery(){if((0,p.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const o=this.gl,l=this.getQueryTimerExtensionWebGL2();o.endQuery(l.TIME_ELAPSED_EXT);return}const r=this.getQueryTimerExtensionWebGL1();r.endQueryEXT(r.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(r){return await p.D5U.repeatedTry(()=>this.disposed||this.isQueryAvailable(r,(0,p.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(r,(0,p.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(r,o){if(o===0)return null;if(o===2){const l=this.gl;return l.getQueryParameter(r,l.QUERY_RESULT)/1e6}else{const l=this.getQueryTimerExtensionWebGL1();return l.getQueryObjectEXT(r,l.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(r,o){if(o===0)return!0;if(o===2){const l=this.gl,c=this.getQueryTimerExtensionWebGL2(),f=l.getQueryParameter(r,l.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(c.GPU_DISJOINT_EXT)),f&&!this.disjoint}else{const l=this.getQueryTimerExtensionWebGL1(),c=l.getQueryObjectEXT(r,l.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(l.GPU_DISJOINT_EXT)),c&&!this.disjoint}}pollFence(r){return new Promise(o=>{this.addItemToPoll(()=>r.isFencePassed(),()=>o())})}pollItems(){const r=Tr(this.itemsToPoll.map(o=>o.isDoneFn));for(let o=0;o<=r;++o){const{resolveFn:l}=this.itemsToPoll[o];l()}this.itemsToPoll=this.itemsToPoll.slice(r+1)}addItemToPoll(r,o){if(this.itemsToPoll.push({isDoneFn:r,resolveFn:o}),this.itemsToPoll.length>1)return;let l;"setTimeoutCustom"in(0,p.OBj)().platform&&(l=(0,p.OBj)().platform.setTimeoutCustom.bind((0,p.OBj)().platform)),p.D5U.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,l)}bindTextureToFrameBuffer(r){this.throwIfDisposed(),Xn(this.gl,r,this.framebuffer),this.debug&&Je(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Xn(this.gl,this.outputTexture,this.framebuffer),this.debug&&Je(this.gl)):Te(this.gl,this.framebuffer)}downloadMatrixDriver(r,o){this.bindTextureToFrameBuffer(r);const l=o();return this.unbindTextureToFrameBuffer(),l}setOutputMatrixTextureDriver(r,o,l){this.throwIfDisposed();const c=this.gl;Xn(c,r,this.framebuffer),this.debug&&Je(c),this.outputTexture=r,ve(c,()=>c.viewport(0,0,o,l)),ve(c,()=>c.scissor(0,0,o,l))}setOutputMatrixWriteRegionDriver(r,o,l,c){this.throwIfDisposed(),ve(this.gl,()=>this.gl.scissor(r,o,l,c))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function Tr(i){let r=0;for(;r<i.length&&i[r]();++r);return r-1}var Vr=L(1172);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:lo,bincountImpl:Xr,bincountReduceImpl:Io,bitwiseAndImpl:co,castImpl:zr,ceilImpl:Wn,concatImpl:ea,equalImpl:Fo,expImpl:lr,expm1Impl:Go,floorImpl:Ho,gatherNdImpl:Rs,gatherV2Impl:Eo,greaterImpl:$r,greaterEqualImpl:Bo,lessImpl:ho,lessEqualImpl:Ha,linSpaceImpl:Ut,logImpl:ta,maxImpl:To,maximumImpl:ma,minimumImpl:Gt,multiplyImpl:Nr,negImpl:ga,notEqualImpl:mr,prodImpl:gr,raggedGatherImpl:na,raggedRangeImpl:h,raggedTensorToTensorImpl:N,rangeImpl:A,rsqrtImpl:Q,scatterImpl:ge,sigmoidImpl:ke,simpleAbsImpl:Ie,sliceImpl:He,sparseFillEmptyRowsImpl:lt,sparseReshapeImpl:Rt,sparseSegmentReductionImpl:zt,sqrtImpl:yn,staticRegexReplaceImpl:an,stridedSliceImpl:Xt,stringNGramsImpl:xn,stringSplitImpl:Tn,stringToHashBucketFastImpl:ss,subImpl:Yn,tileImpl:gs,topKImpl:cr,transposeImpl:Is,uniqueImpl:Fn}=Vr;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Es(i,r){return["x","y","z","w","u","v"].slice(0,r).map(o=>`${i}.${o}`)}function os(i,r){return r===1?[i]:Es(i,r)}function Ta(i,r){if(i===1)return"rc";let o="";for(let l=0;l<i;l++)o+=r[l],l<i-1&&(o+=",");return o}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $a{constructor(r){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=r,this.rank=r.length,this.enableShapeUniforms=Jn(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const o=os("rc",this.rank),l=An(this.rank),c=this.getOutOfBoundsCondition(o),f=this.getSetup(o),g=this.getOutput(o);this.userCode=`
        void main() {
          ${l} rc = getOutputCoords();

          if(${c}) {
            setOutput(vec4(0));
          } else {
            ${f}

            setOutput(vec4(${g}));
          }
        }
      `}}getSourceCoordsArr(r){const o=[];for(let l=0;l<=1;l++)for(let c=0;c<=1;c++){let f=`${l===0?"r":"rp1"}, ${c===0?"c":"cp1"}`;for(let g=2;g<this.rank;g++)f=`${r[r.length-1-g]},`+f;o.push(f)}return o}getOutOfBoundsCondition(r){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let o="";for(let l=this.rank-2;l<this.rank;l++)o+=`${r[l]} >= ${this.enableShapeUniforms?`outShape[${l}]`:this.outputShape[l]}`,l<this.rank-1&&(o+="||");return o}getSetup(r){if(this.rank===1)return"";const o=r.slice(-2),l=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],c=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${o[0]};
      int c = ${o[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${l};
      bool rEdge = rp1 >= ${c};
    `}getOutput(r){const o=this.getSourceCoordsArr(r);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${o[0]}),
            cEdge ? 0. : getA(${o[1]}),
            rEdge ? 0. : getA(${o[2]}),
            rEdge || cEdge ? 0. : getA(${o[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ya{constructor(r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=r,this.enableShapeUniforms=Jn(this.outputShape.length);let l="";for(let c=0;c<4;c++){let f="thisRC = rc;";c%2===1&&(f+="thisRC.z += 1;"),c>1&&(f+="thisRC.y += 1;"),l+=`
        ${f}
        ${c>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${c}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${c>0?"}":""}
      `}this.userCode=`
      ${jo(o,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Or():vr(r)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":r[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":r[2]};

        ${l}

        setOutput(result);
      }
    `}}function jo(i,r){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${r?ns(["r","c","d"],"inputShape"):wn(["r","c","d"],i)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $o{constructor(r){this.gpgpu=r,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(r,o,l){const c=Ft(o,l),f=ja(r,c,l);f in this.freeTextures||(this.freeTextures[f]=[]),f in this.usedTextures||(this.usedTextures[f]=[]);const g=Ko(r,c,this.gpgpu.gl,this.gpgpu.textureConfig,l);if(this.freeTextures[f].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=g,this.log();const v=this.freeTextures[f].pop();return this.usedTextures[f].push(v),v}let C;return c===K.PACKED_2X2_FLOAT32?C=this.gpgpu.createPackedMatrixTexture(r[0],r[1]):c===K.PACKED_2X2_FLOAT16?C=this.gpgpu.createFloat16PackedMatrixTexture(r[0],r[1]):c===K.UNPACKED_FLOAT32?C=this.gpgpu.createFloat32MatrixTexture(r[0],r[1]):c===K.UNPACKED_FLOAT16?C=this.gpgpu.createFloat16MatrixTexture(r[0],r[1]):c===K.PACKED_4X1_UNSIGNED_BYTE&&(C=this.gpgpu.createUnsignedBytesMatrixTexture(r[0],r[1])),this.usedTextures[f].push(C),this.numUsedTextures++,this._numBytesAllocated+=g,this.log(),C}releaseTexture(r,o,l,c){if(this.freeTextures==null)return;const f=Ft(l,c),g=ja(o,f,c);g in this.freeTextures||(this.freeTextures[g]=[]);const C=Ko(o,f,this.gpgpu.gl,this.gpgpu.textureConfig,c),v=(0,p.OBj)().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");v!==-1&&this._numBytesAllocated>v?(this.gpgpu.deleteMatrixTexture(r.texture),this._numBytesAllocated-=C):(this.freeTextures[g].push(r),this.numFreeTextures++,this._numBytesFree+=C),this.numUsedTextures--;const D=this.usedTextures[g],F=D&&D.indexOf(r);if(F==null||F<0)throw new Error("Cannot release a texture that was never provided by this texture manager");D[F]=D[D.length-1],D.pop(),this.log()}log(){if(!this.logEnabled)return;const r=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${r})`);const o=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*o)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const r in this.freeTextures)this.freeTextures[r].forEach(o=>{this.gpgpu.deleteMatrixTexture(o.texture)});for(const r in this.usedTextures)this.usedTextures[r].forEach(o=>{this.gpgpu.deleteMatrixTexture(o.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function kr(i,r){const o=i;if(r===o.R32F)return 4;if(r===o.R16F)return 2;if(r===o.RGBA32F)return 16;if(r===i.RGBA)return 16;if(r===o.RGBA16F)return 8;if(r===o.RGBA8)return 4;throw new Error(`Unknown internal format ${r}`)}function Ko(i,r,o,l,c){const f=ii(r,l);let g;if(c){const[v,D]=Vt(i[0],i[1]);g=v*D}else{const[v,D]=_(i[0],i[1]);g=v*D}const C=kr(o,f);return g*C}function ii(i,r){switch(i){case K.PACKED_2X2_FLOAT32:return At(r);case K.PACKED_2X2_FLOAT16:return Qt(r);case K.UNPACKED_FLOAT32:return je(r);case K.UNPACKED_FLOAT16:return st(r);case K.PACKED_4X1_UNSIGNED_BYTE:return tt(r);default:throw new Error(`Unknown physical texture type ${i}`)}}function Na(i){return(0,p.OBj)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?i?K.PACKED_2X2_FLOAT32:K.UNPACKED_FLOAT32:i?K.PACKED_2X2_FLOAT16:K.UNPACKED_FLOAT16}function Ft(i,r){if(i===xe.UPLOAD)return K.PACKED_2X2_FLOAT32;if(i===xe.RENDER||i==null)return Na(r);if(i===xe.DOWNLOAD||i===xe.PIXELS)return K.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${i}`)}function ja(i,r,o){return`${i[0]}_${i[1]}_${r}_${o}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yr{constructor(r,o){this.variableNames=["A"],this.outputShape=r,this.enableShapeUniforms=Jn(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${o}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const yr="if (isnan(x)) return x;",ui="return x;",Ka="return abs(x);";function Vi(i=0){return yr+`
    return x > 0.0 ? 1.0 : float(${i});
  `}const li="return (x >= 0.0) ? x : (exp(x) - 1.0);",ci=yr+`
  return (x < 0.0) ? 0.0 : x;
`,di=yr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,No="return x;",hi="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xa="return x;",ka=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,pi=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Ya=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,U="return 1.0 / (1.0 + exp(-1.0 * x));";class E{constructor(r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=Jn(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${o}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class z{constructor(r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=r,this.enableShapeUniforms=Jn(this.outputShape.length);const o=r.length,l=os("rc",o),c=An(o),f=Ta(o,l),g=l.slice(-2),C=o<=1?"rc":`vec2(${g.join(",")})`;this.userCode=`
      void main() {
        ${c} rc = getOutputCoords();
        vec4 packedInput = getA(${f});

        setOutput(getChannel(packedInput, ${C}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q=p.GDt.whereImpl,se=1e-7,_e=1e-4,Me={};function et(i){return i in Me||(Me[i]={}),Me[i]}const bt=(0,p.OBj)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),It=600;function sn(){return(0,p.OBj)().global.screen==null?1024:(0,p.OBj)().global.screen.height*(0,p.OBj)().global.screen.width*window.devicePixelRatio*It/1024/1024}class _t extends p.Zuw{nextDataId(){return _t.nextDataId++}constructor(r){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!(0,p.OBj)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let o;if(r!=null){if(r instanceof kt)o=r;else{const l=W((0,p.OBj)().getNumber("WEBGL_VERSION"),r);o=new kt(l)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const l=W((0,p.OBj)().getNumber("WEBGL_VERSION"));o=new kt(l),this.binaryCache=et((0,p.OBj)().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=o,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new $o(this.gpgpu),this.numMBBeforeWarning=sn(),this.texData=new p.JLz(this,(0,p.SRH)())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(r,o,l,c,f,g){const C=this.makeTensorInfo(o,l),v=this.texData.get(C.dataId);v.isPacked=!1,v.texture={texture:r,texShape:[c,f]},v.texShape=[c,f];const D=Kn(o),F=new fe(D,!1,g),H=this.runWebGLProgram(F,[C],l,[[c,f]]);return H.shape=o,v.texture=null,this.disposeIntermediateTensorInfo(C),H.dataId}write(r,o,l){if(((0,p.OBj)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||(0,p.OBj)().getBool("DEBUG"))&&this.checkNumericalProblems(r),l==="complex64"&&r!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const c={id:this.nextDataId()};return this.texData.set(c,{shape:o,dtype:l,values:r,usage:xe.UPLOAD,refCount:1}),c}refCount(r){return this.texData.has(r)?this.texData.get(r).refCount:0}incRef(r){const o=this.texData.get(r);o.refCount++}decRef(r){if(this.texData.has(r)){const o=this.texData.get(r);o.refCount--}}move(r,o,l,c,f){if((0,p.OBj)().getBool("DEBUG")&&this.checkNumericalProblems(o),c==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(r,{shape:l,dtype:c,values:o,usage:xe.UPLOAD,refCount:f})}disposeIntermediateTensorInfo(r){this.disposeData(r.dataId)}readSync(r){const o=this.texData.get(r),{values:l,dtype:c,complexTensorInfos:f,slice:g,shape:C,isPacked:v}=o;if(g!=null){let Y;v?Y=new E(C,No):Y=new Yr(C,No);const te=this.runWebGLProgram(Y,[{dataId:r,shape:C,dtype:c}],c),ae=this.readSync(te.dataId);return this.disposeIntermediateTensorInfo(te),ae}if(l!=null)return this.convertAndCacheOnCPU(r);if(c==="string")return l;const D=this.activeTimers!=null;let F;D&&(F=p.D5U.now());let H;if(c==="complex64"){const Y=this.readSync(f.real.dataId),te=this.readSync(f.imag.dataId);H=p.Wap.mergeRealAndImagArrays(Y,te)}else H=this.getValuesFromTexture(r);return D&&(this.downloadWaitMs+=p.D5U.now()-F),this.convertAndCacheOnCPU(r,H)}async read(r){if(this.pendingRead.has(r)){const ae=this.pendingRead.get(r);return new Promise(Ce=>ae.push(Ce))}const o=this.texData.get(r),{values:l,shape:c,slice:f,dtype:g,complexTensorInfos:C,isPacked:v}=o;if(f!=null){let ae;v?ae=new E(c,No):ae=new Yr(c,No);const Ce=this.runWebGLProgram(ae,[{dataId:r,shape:c,dtype:g}],g),Le=this.read(Ce.dataId);return this.disposeIntermediateTensorInfo(Ce),Le}if(l!=null)return this.convertAndCacheOnCPU(r);if((0,p.OBj)().getBool("DEBUG")&&!(0,p.OBj)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&(0,p.OBj)().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let D=null,F;if(g!=="complex64"&&(0,p.OBj)().get("WEBGL_BUFFER_SUPPORTED")){F=this.decode(r);const ae=this.texData.get(F.dataId);D=this.gpgpu.createBufferFromTexture(ae.texture.texture,...Ke(c))}this.pendingRead.set(r,[]),g!=="complex64"&&await this.gpgpu.createAndWaitForFence();let H;if(g==="complex64"){const ae=await Promise.all([this.read(C.real.dataId),this.read(C.imag.dataId)]),Ce=ae[0],Le=ae[1];H=p.Wap.mergeRealAndImagArrays(Ce,Le)}else if(D==null)H=this.getValuesFromTexture(r);else{const ae=p.D5U.sizeFromShape(c);H=this.gpgpu.downloadFloat32MatrixFromBuffer(D,ae)}if(F!=null&&this.disposeIntermediateTensorInfo(F),D!=null){const ae=this.gpgpu.gl;ve(ae,()=>ae.deleteBuffer(D))}const Y=this.convertAndCacheOnCPU(r,H),te=this.pendingRead.get(r);return this.pendingRead.delete(r),te.forEach(ae=>ae(Y)),this.pendingDisposal.has(r)&&(this.pendingDisposal.delete(r),this.disposeData(r)&&(0,p.SRH)().removeDataId(r,this),this.pendingDeletes--),Y}readToGPU(r,o={}){const l=this.texData.get(r),{values:c,shape:f,slice:g,dtype:C,isPacked:v,texture:D}=l;if(C==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(g!=null){let te;v?te=new E(f,No):te=new Yr(f,No);const ae=this.runWebGLProgram(te,[{dataId:r,shape:f,dtype:C}],C),Ce=this.readToGPU(ae,o);return this.disposeIntermediateTensorInfo(ae),Ce}if(D==null)throw c!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const F=this.decode(r,o.customTexShape),H=(0,p.SRH)().makeTensorFromTensorInfo(F),Y=this.texData.get(F.dataId);return Object.assign({tensorRef:H},Y.texture)}bufferSync(r){const o=this.readSync(r.dataId);if(r.dtype==="string")try{const l=o.map(c=>p.D5U.decodeString(c));return(0,p.f3b)(r.shape,r.dtype,l)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,p.f3b)(r.shape,r.dtype,o)}checkNumericalProblems(r){if(r!=null)for(let o=0;o<r.length;o++){const l=r[o];if(!re(l))throw(0,p.OBj)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${l} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${l} cannot be represented on this device.`)}}getValuesFromTexture(r){const{shape:o,dtype:l,isPacked:c}=this.texData.get(r),f=p.D5U.sizeFromShape(o);if((0,p.OBj)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const Y=this.decode(r),te=this.texData.get(Y.dataId),ae=this.gpgpu.downloadMatrixFromPackedTexture(te.texture.texture,...Ke(o)).subarray(0,f);return this.disposeIntermediateTensorInfo(Y),ae}const g=(0,p.OBj)().getBool("WEBGL_PACK")&&c===!0,C=g?Kn(o):o,v=g?new ur(C):new Fs(C),D=this.runWebGLProgram(v,[{shape:C,dtype:l,dataId:r}],"float32"),F=this.texData.get(D.dataId),H=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(F.texture.texture,F.texShape[0],F.texShape[1]).subarray(0,f);return this.disposeIntermediateTensorInfo(D),H}timerAvailable(){return(0,p.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(r){const o=this.activeTimers,l=[];let c=!1;this.programTimersStack==null?(this.programTimersStack=l,c=!0):this.activeTimers.push(l),this.activeTimers=l,r();const f=p.D5U.flatten(this.activeTimers.map(v=>v.query)).filter(v=>v!=null),g=p.D5U.flatten(this.activeTimers.map(v=>v.name)).filter(v=>v!=null);this.activeTimers=o,c&&(this.programTimersStack=null);const C={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if((0,p.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const v=await Promise.all(f);C.kernelMs=p.D5U.sum(v),C.getExtraProfileInfo=()=>v.map((D,F)=>({name:g[F],ms:D})).map(D=>`${D.name}: ${D.ms}`).join(", ")}else C.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,C})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return(0,p.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:p.D5U.now(),endMs:null}}endTimer(r){return(0,p.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),r):(r.endMs=p.D5U.now(),r)}async getQueryTime(r){if((0,p.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(r);const o=r;return o.endMs-o.startMs}disposeData(r,o=!1){if(this.pendingDisposal.has(r))return!1;if(!this.texData.has(r))return!0;if(o?this.texData.get(r).refCount=0:this.texData.get(r).refCount--,!o&&this.texData.get(r).refCount>0)return!1;if(this.pendingRead.has(r))return this.pendingDisposal.add(r),this.pendingDeletes++,!1;this.releaseGPUData(r);const{complexTensorInfos:l}=this.texData.get(r);return l!=null&&(this.disposeData(l.real.dataId,o),this.disposeData(l.imag.dataId,o)),this.texData.delete(r),!0}releaseGPUData(r){const{texture:o,dtype:l,texShape:c,usage:f,isPacked:g,slice:C}=this.texData.get(r),v=C&&C.origDataId||r,D=this.dataRefCount.get(v);D>1?this.dataRefCount.set(v,D-1):(this.dataRefCount.delete(v),o!=null&&(this.numBytesInGPU-=this.computeBytes(c,l),this.textureManager.releaseTexture(o,c,f,g)));const F=this.texData.get(r);F.texture=null,F.texShape=null,F.isPacked=!1,F.slice=null}getTexture(r){return this.uploadToGPU(r),this.texData.get(r).texture.texture}getDataInfo(r){return this.texData.get(r)}shouldExecuteOnCPU(r,o=bt){return(0,p.OBj)().getBool("WEBGL_CPU_FORWARD")&&r.every(l=>this.texData.get(l.dataId).texture==null&&p.D5U.sizeFromShape(l.shape)<o)}getGPGPUContext(){return this.gpgpu}where(r){p.Wap.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const o=r.dataSync();return q(r.shape,o)}packedUnaryOp(r,o,l){const c=new E(r.shape,o),f=this.compileAndRun(c,[r],l);return(0,p.SRH)().makeTensorFromTensorInfo(f)}abs(r){if(this.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const c=Ie(this.texData.get(r.dataId).values);return this.makeOutput(r.shape,r.dtype,c)}if((0,p.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(r,Ka,r.dtype);const o=new Yr(r.shape,Ka),l=this.compileAndRun(o,[r]);return(0,p.SRH)().makeTensorFromTensorInfo(l)}makeTensorInfo(r,o,l){let c;if(o==="string"&&l!=null&&l.length>0&&p.D5U.isString(l[0])){const f=l.map(g=>p.D5U.encodeString(g));c=this.write(f,r,o)}else c=this.write(l,r,o);return this.texData.get(c).usage=null,{dataId:c,shape:r,dtype:o}}makeOutput(r,o,l){return(0,p.SRH)().makeTensorFromTensorInfo(this.makeTensorInfo(r,o,l),this)}unpackTensor(r){const o=new z(r.shape);return this.runWebGLProgram(o,[r],r.dtype)}packTensor(r){const o=new $a(r.shape);return this.runWebGLProgram(o,[r],r.dtype,null,!0)}packedReshape(r,o){const l=[Rn(r.shape),...Un(r.shape)],c={dtype:r.dtype,shape:l,dataId:r.dataId},f=[Rn(o),...Un(o)],g=new ya(f,l),C=!0,v=[l],D=this.runWebGLProgram(g,[c],r.dtype,v,C);return{dataId:D.dataId,shape:o,dtype:D.dtype}}decode(r,o){const l=this.texData.get(r),{isPacked:c,shape:f,dtype:g}=l;if(o!=null){const Y=p.D5U.sizeFromShape(f),te=o[0]*o[1]*4;p.D5U.assert(Y<=te,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const C=Kn(f);let v;c?v=new Wr(C):v=new Er(C);const D=!0,F=[o??Ke(C)],H=this.runWebGLProgram(v,[{shape:C,dtype:g,dataId:r}],g,F,D,o);return{dtype:g,shape:f,dataId:H.dataId}}runWebGLProgram(r,o,l,c,f=!1,g){const C=this.makeTensorInfo(r.outputShape,l),v=this.texData.get(C.dataId);if(r.packedOutput&&(v.isPacked=!0),r.outPackingScheme===we.DENSE){const be=g??Ke(r.outputShape);v.texShape=be.map(Ge=>Ge*2)}if(r.outTexUsage!=null&&(v.usage=r.outTexUsage),p.D5U.sizeFromShape(C.shape)===0)return v.values=p.D5U.getTypedArrayFromDType(C.dtype,0),C;const D=[],F=o.map(be=>{if(be.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let Ge=this.texData.get(be.dataId);if(Ge.texture==null){if(!r.packedInputs&&p.D5U.sizeFromShape(be.shape)<=(0,p.OBj)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:be.shape,texData:null,isUniform:!0,uniformValues:Ge.values};r.packedInputs&&(Ge.isPacked=!0,Ge.shape=be.shape)}if(this.uploadToGPU(be.dataId),!!Ge.isPacked!=!!r.packedInputs)be=Ge.isPacked?this.unpackTensor(be):this.packTensor(be),D.push(be),Ge=this.texData.get(be.dataId);else if(Ge.isPacked&&!_r(Ge.shape,be.shape)){const Et=be,vt=be.shape;be.shape=Ge.shape,be=this.packedReshape(be,vt),D.push(be),Ge=this.texData.get(be.dataId),Et.shape=vt}return{shape:be.shape,texData:Ge,isUniform:!1}});this.uploadToGPU(C.dataId);const H={shape:C.shape,texData:v,isUniform:!1},Y=Ir(r,F,H),te=this.getAndSaveBinary(Y,()=>ir(this.gpgpu,r,F,H)),ae=this.activeTimers!=null;let Ce;ae&&(Ce=this.startTimer()),(0,p.OBj)().get("ENGINE_COMPILE_ONLY")||Ye(this.gpgpu,te,F,H,c),D.forEach(be=>this.disposeIntermediateTensorInfo(be)),ae&&(Ce=this.endTimer(Ce),this.activeTimers.push({name:r.constructor.name,query:this.getQueryTime(Ce)}));const Le=(0,p.OBj)().getNumber("WEBGL_FLUSH_THRESHOLD");if(Le>0){const be=p.D5U.now();be-this.lastGlFlushTime>Le&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=be)}if(!(0,p.OBj)().getBool("WEBGL_LAZILY_UNPACK")&&v.isPacked&&f===!1){const be=this.unpackTensor(C);return this.disposeIntermediateTensorInfo(C),be}return C}compileAndRun(r,o,l,c,f=!1){return l=l||o[0].dtype,this.runWebGLProgram(r,o,l,c,f)}getAndSaveBinary(r,o){return r in this.binaryCache||(this.binaryCache[r]=o()),this.binaryCache[r]}getTextureManager(){return this.textureManager}dispose(){this.disposed||((0,p.OBj)().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(o=>{this.gpgpu.deleteProgram(this.binaryCache[o].webGLProgram),delete this.binaryCache[o]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=(0,p.lub)(()=>{if(!(0,p.OBj)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const r=(0,p.OBj)().getBool("DEBUG");(0,p.OBj)().set("DEBUG",!1);const o=this.abs((0,p.iD$)(1e-8)).dataSync()[0];if((0,p.OBj)().set("DEBUG",r),o>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?se:_e}uploadToGPU(r){const o=this.texData.get(r),{shape:l,dtype:c,values:f,texture:g,usage:C,isPacked:v}=o;if(g!=null)return;const D=this.activeTimers!=null;let F;D&&(F=p.D5U.now());let H=o.texShape;if(H==null&&(H=Us(l,v),o.texShape=H),f!=null){const Y=Kn(l);let te,ae=H[1],Ce=H[0];const Le=f instanceof Uint8Array||f instanceof Uint8ClampedArray;(v||!Le)&&([ae,Ce]=Vt(H[0],H[1])),v?te=new de(Y,Le):te=new fe(Y,Le);const be=Le?[Ce,ae]:H,Ge=this.makeTensorInfo(be,c),Et=this.texData.get(Ge.dataId);Le?Et.usage=xe.PIXELS:Et.usage=xe.UPLOAD,Et.texShape=be,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(Ge.dataId),ae,Ce,f);const vt=[[Ce,ae]],En=this.runWebGLProgram(te,[Ge],c,vt,!0),gn=this.texData.get(En.dataId);o.texShape=gn.texShape,o.isPacked=gn.isPacked,o.usage=gn.usage,(0,p.OBj)().get("ENGINE_COMPILE_ONLY")?this.disposeData(En.dataId):(o.texture=gn.texture,o.values=null,this.texData.delete(En.dataId)),this.disposeIntermediateTensorInfo(Ge),D&&(this.uploadWaitMs+=p.D5U.now()-F)}else{const Y=this.acquireTexture(H,C,c,v);o.texture=Y}}convertAndCacheOnCPU(r,o){const l=this.texData.get(r),{dtype:c}=l;return o!=null&&(l.values=Tt(o,c)),l.values}acquireTexture(r,o,l,c){if(this.numBytesInGPU+=this.computeBytes(r,l),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const f=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${f} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(r,o,c)}computeBytes(r,o){return r[0]*r[1]*p.D5U.bytesPerElement(o)}checkCompileCompletion(){for(const[,r]of Object.entries(this.binaryCache))this.checkCompletion_(r)}async checkCompileCompletionAsync(){const r=[];if(this.gpgpu.parallelCompilationExtension){for(const[,o]of Object.entries(this.binaryCache))r.push(this.checkCompletionAsync_(o));return Promise.all(r)}else{for(const[,o]of Object.entries(this.binaryCache)){const l=new Promise(c=>{try{this.checkCompletion_(o),c(!0)}catch(f){throw f}});r.push(l)}return Promise.all(r)}}async checkCompletionAsync_(r){return this.gpgpu.gl.getProgramParameter(r.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(r):(await(0,p.glt)(),this.checkCompletionAsync_(r))}checkCompletion_(r){if(this.gpgpu.gl.getProgramParameter(r.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(r.webGLProgram)),this.gpgpu.gl.getShaderParameter(r.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(nt(r.source,this.gpgpu.gl.getShaderInfoLog(r.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const r of Object.values(this.binaryCache)){this.gpgpu.buildVao(r.webGLProgram);const{variablesLocations:o,customUniformLocations:l,infLoc:c,nanLoc:f,outShapeLocation:g,outShapeStridesLocation:C,outTexShapeLocation:v}=So(this.gpgpu,r.program,r.webGLProgram);r.variablesLocations=o,r.customUniformLocations=l,r.infLoc=c,r.nanLoc=f,r.outShapeLocation=g,r.outShapeStridesLocation=C,r.outTexShapeLocation=v}}createTensorFromGPUData(r,o,l){r.channels=r.channels||"RGBA";const{texture:c,height:f,width:g,channels:C}=r,v=(0,p.SRH)().backend;if(!v.gpgpu.gl.isTexture(c))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const D=v.writeTexture(c,o,l,f,g,C);return(0,p.SRH)().makeTensorFromDataId(D,o,l,v)}}_t.nextDataId=0;function Tt(i,r){if(r==="float32"||r==="complex64")return i;if(r==="int32"||r==="bool"){const o=r==="int32"?new Int32Array(i.length):new Uint8Array(i.length);for(let l=0;l<o.length;++l)o[l]=Math.round(i[l]);return o}else throw new Error(`Unknown dtype ${r}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */p.C2$.isBrowser()&&(0,p.jqO)("webgl",()=>new _t,2);const Kt=null;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $n=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,qn="return (a - b) * (a - b);";class es{constructor(r,o,l){this.variableNames=["A","B"],this.outputShape=p.Wap.assertAndGetBroadcastShape(o,l),this.enableShapeUniforms=Jn(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${r}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vs=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`,xa=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,un=`
  return vec4(notEqual(a, b));
`;class Ts{constructor(r,o,l,c=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=p.Wap.assertAndGetBroadcastShape(o,l);const f=this.outputShape.length;this.enableShapeUniforms=Jn(f);let g="";if(c)if(f===0||p.D5U.sizeFromShape(this.outputShape)===1)g=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(g=`
          ${An(f)} coords = getOutputCoords();
        `,f===1)this.enableShapeUniforms?g+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:g+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const v=os("coords",f);this.enableShapeUniforms?g+=`
            bool nextRowOutOfBounds =
              (${v[f-2]} + 1) >= outShape[${f} - 2];
            bool nextColOutOfBounds =
              (${v[f-1]} + 1) >= outShape[${f} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:g+=`
            bool nextRowOutOfBounds =
              (${v[f-2]} + 1) >= ${this.outputShape[f-2]};
            bool nextColOutOfBounds =
              (${v[f-1]} + 1) >= ${this.outputShape[f-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${r}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${g}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rs(i){const{inputs:r,backend:o}=i,{x:l}=r;return o.incRef(l.dataId),{dataId:l.dataId,shape:l.shape,dtype:l.dtype}}const qa={kernelName:p.iJz,backendName:"webgl",kernelFunc:rs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function po(i){const{inputs:r,backend:o}=i,{real:l,imag:c}=r,f=o.makeTensorInfo(l.shape,"complex64"),g=o.texData.get(f.dataId),C=rs({inputs:{x:l},backend:o}),v=rs({inputs:{x:c},backend:o});return g.complexTensorInfos={real:C,imag:v},f}const Ra={kernelName:p.Zz9,backendName:"webgl",kernelFunc:po};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fo="return (a < 0.) ? b * a : a;",sa=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Xo(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{alpha:f}=l,g=o.makeTensorInfo([],"float32",p.D5U.createScalarValue(f,"float32")),C=(0,p.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ts(sa,c.shape,g.shape):new es(fo,c.shape,g.shape),v=o.runWebGLProgram(C,[c,g],"float32");return o.disposeIntermediateTensorInfo(g),v}const Da={kernelName:p.J$2,backendName:"webgl",kernelFunc:Xo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zi="return (a < 0.) ? b * a : a;",Yo=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function mo(i){const{inputs:r,backend:o}=i,{x:l,alpha:c}=r,f=(0,p.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ts(Yo,l.shape,c.shape):new es(zi,l.shape,c.shape);return o.runWebGLProgram(f,[l,c],"float32")}const Lo={kernelName:p.o0g,backendName:"webgl",kernelFunc:mo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ra="if (isnan(x)) return x;";function Bn({opSnippet:i,packedOpSnippet:r,cpuKernelImpl:o,dtype:l}){return({inputs:c,backend:f})=>{const{x:g}=c,C=f,v=l||g.dtype;if(C.shouldExecuteOnCPU([g])&&o!=null){const H=C.texData.get(g.dataId),Y=o(H.values,v);return C.makeTensorInfo(g.shape,v,Y)}const D=(0,p.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&r!=null;let F;return D?F=new E(g.shape,r):F=new Yr(g.shape,i),C.runWebGLProgram(F,[g],v)}}function sr({opSnippet:i,packedOpSnippet:r,checkOutOfBounds:o=!1,supportsComplex:l=!1,cpuKernelImpl:c,dtype:f}){return({inputs:g,backend:C})=>{const{a:v,b:D}=g,F=C;if(l&&v.dtype==="complex64"){const ae=F.texData.get(v.dataId),Ce=F.texData.get(D.dataId),[Le,be]=[[ae.complexTensorInfos.real,Ce.complexTensorInfos.real],[ae.complexTensorInfos.imag,Ce.complexTensorInfos.imag]].map(Et=>{const[vt,jt]=Et,En={dataId:vt.dataId,dtype:vt.dtype,shape:v.shape},gn={dataId:jt.dataId,dtype:jt.dtype,shape:D.shape},rn=new es(i,v.shape,D.shape);return F.runWebGLProgram(rn,[En,gn],(0,p.x8V)(vt.dtype,jt.dtype))}),Ge=po({inputs:{real:Le,imag:be},backend:F});return F.disposeIntermediateTensorInfo(Le),F.disposeIntermediateTensorInfo(be),Ge}const H=f||(0,p.x8V)(v.dtype,D.dtype);if((v.dtype==="string"||D.dtype==="string"||F.shouldExecuteOnCPU([v,D]))&&c!=null){const ae=F.texData.get(v.dataId).values,Ce=F.texData.get(D.dataId).values,Le=v.dtype==="string"?p.Wap.fromUint8ToStringArray(ae):ae,be=v.dtype==="string"?p.Wap.fromUint8ToStringArray(Ce):Ce,[Ge,Et]=c(v.shape,D.shape,Le,be,H),vt=F.makeTensorInfo(Et,H),jt=F.texData.get(vt.dataId);return jt.values=Ge,vt}const Y=(0,p.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&r!=null;let te;return Y?te=new Ts(r,v.shape,D.shape,o):te=new es(i,v.shape,D.shape),F.runWebGLProgram(te,[v,D],H)}}function Qa(i,r=!1){if(i==="linear")return r?Xa:ui;if(i==="relu")return r?pi:ci;if(i==="elu")return r?ka:li;if(i==="relu6")return r?Ya:di;if(i==="prelu")return r?Yo:zi;if(i==="leakyrelu")return r?sa:fo;if(i==="sigmoid")return r?U:hi;throw new Error(`Activation ${i} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oa{constructor(r,o,l,c=!1,f=!1,g=!1,C=null,v=!1,D=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=l,this.enableShapeUniforms=Jn(this.outputShape.length);const F=c?r[1]:r[2],H=Math.ceil(F/2),Y=c?"i * 2, rc.y":"rc.y, i * 2",te=f?"rc.z, i * 2":"i * 2, rc.z",ae=c?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],Ce=f?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let Le="",be="";C&&(v?Le=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${C}
        }`:D?Le=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${C}
        }`:Le=`vec4 activation(vec4 x) {
          ${C}
        }`,be="result = activation(result);");const Ge=g?"result += getBiasAtOutCoords();":"";g&&this.variableNames.push("bias"),v&&this.variableNames.push("preluActivationWeights"),D&&this.variableNames.push("leakyreluAlpha");let Et="rc.x",vt="rc.x";r[0]<o[0]?Et=`imod(rc.x, ${r[0]})`:o[0]<r[0]&&(vt=`imod(rc.x, ${o[0]})`),this.userCode=`
      ${Le}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${H}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${Et};
        int batchB = ${vt};
        for (int i = 0; i < ${H}; i++) {
          vec4 a = getMatrixA(batchA, ${Y});
          vec4 b = getMatrixB(batchB, ${te});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${ae[0]} * ${Ce[0]});
          result += (${ae[1]} * ${Ce[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${Ge}

        ${be}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fi={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class Gi{constructor(r,o,l){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=p.Wap.assertAndGetBroadcastShape(o,l),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${r}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _a="return a * b;";function mi(i){const{inputs:r,backend:o}=i,{a:l,b:c}=r,f=p.Wap.upcastType(l.dtype,c.dtype);if(l.dtype==="complex64"){const C=o.texData.get(l.dataId),v=o.texData.get(c.dataId),D=new Gi(fi.REAL,l.shape,c.shape),F=new Gi(fi.IMAG,l.shape,c.shape),H=[{dataId:C.complexTensorInfos.real.dataId,dtype:C.complexTensorInfos.real.dtype,shape:l.shape},{dataId:C.complexTensorInfos.imag.dataId,dtype:C.complexTensorInfos.imag.dtype,shape:l.shape},{dataId:v.complexTensorInfos.real.dataId,dtype:v.complexTensorInfos.real.dtype,shape:c.shape},{dataId:v.complexTensorInfos.imag.dataId,dtype:v.complexTensorInfos.imag.dtype,shape:c.shape}],Y=o.runWebGLProgram(D,H,"float32"),te=o.runWebGLProgram(F,H,"float32"),ae=po({inputs:{real:Y,imag:te},backend:o});return o.disposeIntermediateTensorInfo(Y),o.disposeIntermediateTensorInfo(te),ae}if(o.shouldExecuteOnCPU([l,c])){const C=o.texData.get(l.dataId),v=o.texData.get(c.dataId),[D,F]=Nr(l.shape,c.shape,C.values,v.values,f),H=o.makeTensorInfo(F,f),Y=o.texData.get(H.dataId);return Y.values=D,H}let g;return(0,p.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?g=new Ts(_a,l.shape,c.shape):g=new es(_a,l.shape,c.shape),o.runWebGLProgram(g,[l,c],f)}const _u={kernelName:p.wYn,backendName:"webgl",kernelFunc:mi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Au(i,r,o){const l=[Rn(i.shape),...Un(i.shape)],c={dtype:i.dtype,shape:l,dataId:i.dataId},f=[Rn(r),...Un(r)],g=new ya(f,l),C=!0,v=[l],D=o.runWebGLProgram(g,[c],i.dtype,v,C);return{dataId:D.dataId,shape:r,dtype:D.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ht(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{shape:f}=l,g=o,C=p.D5U.sizeFromShape(c.shape),v=p.D5U.inferFromImplicitShape(f,C),D=p.D5U.sizeFromShape(v);p.D5U.assert(C===D,()=>`The new shape (${v}) has ${D} elements and the old shape (${c.shape}) has ${C} elements. The new shape and old shape must have the same number of elements.`);const F=g.texData.get(c.dataId);return F.isPacked&&!_r(c.shape,v)&&!(F.texture!==null&&_r(F.shape,v))?Au(c,v,g):(g.incRef(c.dataId),{dataId:c.dataId,shape:v,dtype:c.dtype})}const Pu={kernelName:p.HZH,backendName:"webgl",kernelFunc:Ht};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hi{constructor(r,o){this.variableNames=["x"];const{windowSize:l,batchSize:c,inSize:f,outSize:g}=r;this.outputShape=[c,g];const C=Math.floor(l/4)*4,v=l%4;let D="sumValue += dot(values, ones);";if(o!=null){const H=1/o;D=`sumValue += dot(values * ${p.D5U.isInt(H)?H.toPrecision(2):H}, ones);`}let F="";f%l>0&&(F=`
        if (inIdx < 0 || inIdx >= ${f}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${F}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${l};

        float sumValue = 0.0;

        for (int i = 0; i < ${C}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${D}
        }

        int inIdx = inOffset + ${C};
        if (${v===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${D}
        } else if (${v===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${D}
        } else if (${v===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${D}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ou{constructor(r,o){this.variableNames=["x"];const{windowSize:l,batchSize:c,inSize:f,outSize:g}=r;this.outputShape=[c,g];let C="0.0",v="";o==="prod"?C="1.0":o==="min"?(C="1.0 / 1e-20",v="min"):o==="max"&&(C="-1.0 / 1e-20",v="max");let D=`${o}(${o}(${o}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;o==="sum"?D="sumValue":o==="prod"?D="prodValue":o==="all"?D="allValue":o==="any"&&(D="anyValue");const F=Math.floor(l/4)*4,H=l%4;let Y=`
      if (${o==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${o==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${v}(values, minMaxValue);
        if (${o==="min"} || ${o==="max"}) {
          minMaxValue = ${v}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,te="vec4";o==="all"?(C="1.0",Y=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,te="bvec4"):o==="any"&&(C="0.0",Y=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,te="bvec4");let ae="";f%l>0&&(ae=`
        if (inIdx < 0 || inIdx >= ${f}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${C};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${ae}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${l};

        vec4 minMaxValue = vec4(${C});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${F}; i += 4) {
          int inIdx = inOffset + i;
          ${te} values = ${te}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${Y}
        }

        int inIdx = inOffset + ${F};
        if (${H===1}) {
          ${te} values = ${te}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${Y}
        } else if (${H===2}) {
          ${te} values = ${te}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${Y}
        } else if (${H===3}) {
          ${te} values = ${te}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${Y}
        }
        setOutput(${D});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gi(i){const r=[];for(;r.length===0||r[r.length-1].outSize!==1;){const o=r.length?r[r.length-1].outSize:i[1],l=p.Wap.computeOptimalWindowSize(o);r.push({inSize:o,windowSize:l,outSize:Math.ceil(o/l)})}return r}function aa(i,r,o,l){const c=gi(i.shape);let f=i;for(let g=0;g<c.length;g++){const{inSize:C,windowSize:v,outSize:D}=c[g];let F,H;o==="mean"?F=g===0?new Hi({windowSize:v,inSize:C,batchSize:i.shape[0],outSize:D},C):new Hi({windowSize:v,inSize:C,batchSize:i.shape[0],outSize:D}):F=new Ou({windowSize:v,inSize:C,batchSize:i.shape[0],outSize:D},o),H=f,f=l.runWebGLProgram(F,[f],r),H.dataId!==i.dataId&&l.disposeIntermediateTensorInfo(H)}return f}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fu{constructor(r,o){this.variableNames=["A"];const l=new Array(r.length);for(let g=0;g<l.length;g++)l[g]=r[o[g]];this.outputShape=l,this.rank=l.length;const c=An(this.rank),f=zs(o);this.userCode=`
    void main() {
      ${c} resRC = getOutputCoords();
      setOutput(getA(${f}));
    }
    `}}function zs(i){const r=i.length;if(r>6)throw Error(`Transpose for rank ${r} is not yet supported`);const o=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],l=new Array(r);for(let c=0;c<i.length;c++)l[i[c]]=o[c];return l.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bu{constructor(r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const l=new Array(r.length);for(let F=0;F<l.length;F++)l[F]=r[o[F]];if(this.outputShape=l,this.rank=l.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const c=An(this.rank),f=Es("rc",this.rank),g=new Array(this.rank);for(let F=0;F<o.length;F++)g[o[F]]=f[F];const C=`vec2(${g.slice(-2).join()})`,v=`++${f[this.rank-1]} < ${l[this.rank-1]}`,D=`getChannel(getA(${g.join()}), ${C})`;this.userCode=`
    void main() {
      ${c} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${D};
      if(${v}) {
        result[1] = ${D};
      }
      --${f[this.rank-1]};
      if(++${f[this.rank-2]} < ${l[this.rank-2]}) {
        result[2] = ${D};
        if(${v}) {
          result[3] = ${D};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zt(i,r,o){const l=(0,p.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Bu(i.shape,r):new Fu(i.shape,r);return o.runWebGLProgram(l,[i],i.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lu(i,r,o,l){const c=r,f=i.shape.length,g=p.D5U.parseAxisParam(c,i.shape);let C=g;const v=p.Wap.getAxesPermutation(C,f),D=v!=null;let F=i;D&&(F=Zt(i,v,l),C=p.Wap.getInnerMostAxes(C.length,f)),p.Wap.assertAxesAreInnerMostDims("sum",C,f);const[H,Y]=p.Wap.computeOutAndReduceShapes(F.shape,C);let te=H;o&&(te=p.Wap.expandShapeToKeepDim(H,g));const ae=p.D5U.sizeFromShape(Y),Le=p.D5U.sizeFromShape(i.shape)/ae,be=Ht({inputs:{x:F},attrs:{shape:[Le,ae]},backend:l}),Ge=(0,p.z4k)(i.dtype),Et=aa(be,Ge,"sum",l),vt=Ht({inputs:{x:Et},attrs:{shape:te},backend:l});return l.disposeIntermediateTensorInfo(be),l.disposeIntermediateTensorInfo(Et),D&&l.disposeIntermediateTensorInfo(F),vt}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ia(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{axis:f,keepDims:g}=l;return Lu(c,f,g,o)}const yi={kernelName:p.GBy,backendName:"webgl",kernelFunc:ia};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dr(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{perm:f}=l,g=o,C=c.shape.length,v=new Array(C);for(let F=0;F<v.length;F++)v[F]=c.shape[f[F]];let D;if(g.shouldExecuteOnCPU([c])){const H=g.texData.get(c.dataId).values,Y=Is(H,c.shape,c.dtype,f,v);D=g.makeTensorInfo(v,c.dtype);const te=g.texData.get(D.dataId);te.values=Y}else D=Zt(c,f,g);return D}const ji={kernelName:p.G3Y,backendName:"webgl",kernelFunc:dr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const go=1e3;function rr({a:i,b:r,transposeA:o,transposeB:l,backend:c,bias:f=null,preluActivationWeights:g=null,leakyreluAlpha:C=0,activation:v=null}){const D=i.shape.length,F=r.shape.length,H=o?i.shape[D-2]:i.shape[D-1],Y=l?r.shape[F-1]:r.shape[F-2],te=o?i.shape[D-1]:i.shape[D-2],ae=l?r.shape[F-2]:r.shape[F-1],Ce=i.shape.slice(0,-2),Le=r.shape.slice(0,-2),be=p.D5U.sizeFromShape(Ce),Ge=p.D5U.sizeFromShape(Le),vt=p.Jyw.assertAndGetBroadcastShape(i.shape.slice(0,-2),r.shape.slice(0,-2)).concat([te,ae]);p.D5U.assert(H===Y,()=>`Error in matMul: inner shapes (${H}) and (${Y}) of Tensors with shapes ${i.shape} and ${r.shape} and transposeA=${o} and transposeB=${l} must match.`);const jt=o?[be,H,te]:[be,te,H],En=l?[Ge,ae,Y]:[Ge,Y,ae],gn=Ht({inputs:{x:i},backend:c,attrs:{shape:jt}}),rn=Ht({inputs:{x:r},backend:c,attrs:{shape:En}}),Gn=[gn,rn],_n=Math.max(be,Ge),_s=o?gn.shape[1]:gn.shape[2],Ls=f!=null,Zo=g!=null,Xs=v==="leakyrelu",us=v!=null?Qa(v,!0):null,yo=Ls||Zo||Xs||us!=null;let Mo;if((te===1||ae===1)&&_s>go&&yo===!1){let fa=gn,Ui=rn;o&&(fa=dr({inputs:{x:gn},backend:c,attrs:{perm:[0,2,1]}}),Gn.push(fa)),l&&(Ui=dr({inputs:{x:rn},backend:c,attrs:{perm:[0,2,1]}}),Gn.push(Ui));const za=ae!==1,Mi=ae===1;let Du=fa;za&&(Du=Ht({inputs:{x:fa},backend:c,attrs:{shape:[_n,_s,1]}}),Gn.push(Du));const Md=ae===1?2:1;let Wi=Ui;Mi&&(Wi=Ht({inputs:{x:Ui},backend:c,attrs:{shape:[_n,1,_s]}}),Gn.push(Wi));const rd=mi({inputs:{a:Du,b:Wi},backend:c});Mo=ia({inputs:{x:rd},backend:c,attrs:{axis:Md,keepDims:!0}}),Gn.push(rd)}else{const fa=(0,p.x8V)(i.dtype,r.dtype),Ui=new oa(jt,En,[_n,te,ae],o,l,Ls,us,Zo,Xs),za=[gn,rn];if(f!=null&&za.push(f),Zo&&za.push(g),Xs){const Mi=c.makeTensorInfo([],"float32",p.D5U.createScalarValue(C,"float32"));za.push(Mi),Gn.push(Mi)}Mo=c.runWebGLProgram(Ui,za,fa)}const Dr=Ht({inputs:{x:Mo},backend:c,attrs:{shape:vt}});Gn.push(Mo);for(const fa of Gn)c.disposeIntermediateTensorInfo(fa);return Dr}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uu(i){const{inputs:r,backend:o,attrs:l}=i,{a:c,b:f,bias:g,preluActivationWeights:C}=r,{transposeA:v,transposeB:D,activation:F,leakyreluAlpha:H}=l;return rr({a:c,b:f,transposeA:v,transposeB:D,backend:o,bias:g,preluActivationWeights:C,leakyreluAlpha:H,activation:F})}const ua={kernelName:p.usg,backendName:"webgl",kernelFunc:Uu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ki="return abs(x);";function ba(i){const{inputs:r,backend:o}=i,{x:l}=r;if(o.shouldExecuteOnCPU([l])&&l.dtype!=="complex64"){const f=o.texData.get(l.dataId),g=Ie(f.values);return o.makeTensorInfo(l.shape,l.dtype,g)}let c;return(0,p.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?c=new E(l.shape,Ki):c=new Yr(l.shape,Ki),o.runWebGLProgram(c,[l],l.dtype)}const Vn={kernelName:p.SYM,backendName:"webgl",kernelFunc:ba};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gs=yr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Mu=Bn({opSnippet:Gs}),Wu={kernelName:p.VGw,backendName:"webgl",kernelFunc:Mu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xi=yr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Vu=Bn({opSnippet:Xi}),zu={kernelName:p.SpW,backendName:"webgl",kernelFunc:Vu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yi="return a + b;",Gu=sr({opSnippet:Yi,packedOpSnippet:Yi,supportsComplex:!0,cpuKernelImpl:lo}),Hu={kernelName:p.mm_,backendName:"webgl",kernelFunc:Gu};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ju{constructor(r,o){this.outputShape=[],this.outputShape=r,this.variableNames=o.map((f,g)=>`T${g}`);const l=[];this.variableNames.forEach(f=>{l.push(`float v${f} = get${f}AtOutCoords();`)});const c=this.variableNames.map(f=>`v${f}`).join(" + ");this.userCode=`
      void main() {
        ${l.join(`
        `)}

        float result = ${c};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ku{constructor(r,o){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.variableNames=o.map((f,g)=>`T${g}`);const l=[];this.variableNames.forEach(f=>{l.push(`vec4 v${f} = get${f}AtOutCoords();`)});const c=this.variableNames.map(f=>`v${f}`).join(" + ");this.userCode=`
      void main() {
        ${l.join(`
        `)}

        vec4 result = ${c};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Za(i){const{inputs:r,backend:o}=i,l=r;if(l.length===1)return rs({inputs:{x:l[0]},backend:o});if(l.length>(0,p.OBj)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const v=Math.floor(l.length/2),D=Za({inputs:l.slice(0,v),backend:o}),F=Za({inputs:l.slice(v),backend:o});return Za({inputs:[D,F],backend:o})}const c=l.map(v=>v.dtype).reduce((v,D)=>(0,p.x8V)(v,D)),f=l.map(v=>v.shape),C=(0,p.OBj)().getBool("WEBGL_PACK")?new Ku(l[0].shape,f):new ju(l[0].shape,f);return o.runWebGLProgram(C,l,c)}const Xu={kernelName:p.Xze,backendName:"webgl",kernelFunc:Za};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yu(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{axis:f,keepDims:g}=l,C=c.shape.length,v=p.D5U.parseAxisParam(f,c.shape);let D=v;const F=p.Wap.getAxesPermutation(D,C);let H=c;F!=null&&(H=dr({inputs:{x:c},backend:o,attrs:{perm:F}}),D=p.Wap.getInnerMostAxes(D.length,C)),p.Wap.assertAxesAreInnerMostDims("all",D,C);const[Y,te]=p.Wap.computeOutAndReduceShapes(H.shape,D),ae=p.D5U.sizeFromShape(te),Ce=Ht({inputs:{x:H},backend:o,attrs:{shape:[-1,ae]}}),Le=aa(Ce,Ce.dtype,"all",o);let be;if(g){const Ge=p.Wap.expandShapeToKeepDim(Y,v);be=Ht({inputs:{x:Le},backend:o,attrs:{shape:Ge}})}else be=Ht({inputs:{x:Le},backend:o,attrs:{shape:Y}});return o.disposeIntermediateTensorInfo(Ce),o.disposeIntermediateTensorInfo(Le),F!=null&&o.disposeIntermediateTensorInfo(H),be}const qu={kernelName:p.oT6,backendName:"webgl",kernelFunc:Yu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qu(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{axis:f,keepDims:g}=l,C=c.shape.length,v=p.D5U.parseAxisParam(f,c.shape);let D=v;const F=p.Wap.getAxesPermutation(D,C);let H=c;F!=null&&(H=dr({inputs:{x:c},backend:o,attrs:{perm:F}}),D=p.Wap.getInnerMostAxes(D.length,C)),p.Wap.assertAxesAreInnerMostDims("any",D,C);const[Y,te]=p.Wap.computeOutAndReduceShapes(H.shape,D),ae=p.D5U.sizeFromShape(te),Ce=Ht({inputs:{x:H},backend:o,attrs:{shape:[-1,ae]}}),Le=aa(Ce,Ce.dtype,"any",o);let be;if(g){const Ge=p.Wap.expandShapeToKeepDim(Y,v);be=Ht({inputs:{x:Le},backend:o,attrs:{shape:Ge}})}else be=Ht({inputs:{x:Le},backend:o,attrs:{shape:Y}});return o.disposeIntermediateTensorInfo(Ce),o.disposeIntermediateTensorInfo(Le),F!=null&&o.disposeIntermediateTensorInfo(H),be}const Zu={kernelName:p.IKK,backendName:"webgl",kernelFunc:Qu};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ju{constructor(r,o,l){this.variableNames=["A"];const{windowSize:c,batchSize:f,outSize:g}=r;l||this.variableNames.push("bestIndicesA"),this.outputShape=[f,g];const C=o==="max"?">":"<",v=l?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${c};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${c}; i++) {
          int inIdx = ${v};
          float candidate = getA(batch, inIdx);
          if (candidate ${C} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class el{constructor(r,o,l,c){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,p.D5U.assert(r.length>2,()=>`Packed arg${l.charAt(0).toUpperCase()+l.slice(1)} supports only inputs with rank above 2.`);const f=r[r.length-1],g=Math.ceil(f/o);this.outputShape=r.slice(0,-1),g>1&&this.outputShape.push(g),c||this.variableNames.push("bestIndicesA");const C=this.outputShape,v=C.length,D=An(v),F=os("coords",v);let H,Y;if(g===1){Y=v+1;const rn=An(Y);H=`
        ${rn} sourceLocR = ${rn}(${F.join()}, 0);
        ++${F[v-1]};
        ${rn} sourceLocG = ${rn}(${F.join()}, 0);
        ++${F[v-2]};
        ${rn} sourceLocA = ${rn}(${F.join()}, 0);
        --${F[v-1]};
        ${rn} sourceLocB = ${rn}(${F.join()}, 0);
        --${F[v-2]};`}else Y=v,H=`
        ${D} sourceLocR = coords;
        ++${F[v-1]};
        ${D} sourceLocG = coords;
        ++${F[v-2]};
        ${D} sourceLocA = coords;
        --${F[v-1]};
        ${D} sourceLocB = coords;
        --${F[v-2]};`;const te=["x","y","z","w","u","v"].slice(0,Y),ae="."+te[Y-1],Ce=te.map(rn=>"int "+rn),Le=os("sourceLocR",Y-1).concat("inIdx.r"),be=os("sourceLocG",Y-1).concat("inIdx.g"),Ge=os("sourceLocB",Y-1).concat("inIdx.b"),Et=os("sourceLocA",Y-1).concat("inIdx.a"),vt=l==="max"?"greaterThan":"lessThan",jt=c?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${Le.join()}),
                             getBestIndicesAChannel(${be.join()}),
                             getBestIndicesAChannel(${Ge.join()}),
                             getBestIndicesAChannel(${Et.join()})));`,En=`vec4(
            getAChannel(${Le.join()}),
            hasNextCol ? getAChannel(${be.join()}) : 0.,
            hasNextRow ? getAChannel(${Ge.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${Et.join()}) : 0.)`,gn=c?"":`
      float getBestIndicesAChannel(${Ce.join()}) {
        return getChannel(getBestIndicesA(${te.join()}),
                                          vec2(${te.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${Ce.join()}) {
        return getChannel(getA(${te.join()}),
                               vec2(${te.slice(-2).join()}));
      }
      ${gn}
      void main() {
        ${D} coords = getOutputCoords();
        bool hasNextCol = ${F[v-1]} < ${C[v-1]-1};
        bool hasNextRow = ${F[v-2]} < ${C[v-2]-1};
        ${H}
        ivec4 srcIdx = ivec4(sourceLocR${ae}, sourceLocG${ae},
          sourceLocB${ae}, sourceLocA${ae}) * ${o};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${En};

        for (int i = 0; i < ${o}; i++) {
          inIdx = srcIdx;
          ${jt}
          vec4 candidate = ${En};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${vt}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qi(i,r,o,l=null){let c=r.shape[0],f=r.shape[1];l!=null&&(c=l.shape[0],f=l.shape[1]);const g=p.Wap.computeOptimalWindowSize(f),C={windowSize:g,inSize:f,batchSize:c,outSize:Math.ceil(f/g)},v=new Ju(C,o,l==null),D=[r];l!=null&&D.push(l);const F=i.runWebGLProgram(v,D,"int32");if(F.shape[1]===1)return F;const H=qi(i,r,o,F);return i.disposeIntermediateTensorInfo(F),H}function Qi(i,r,o,l=null){const c=l!=null?l.shape:r.shape,f=c[c.length-1],g=p.Wap.computeOptimalWindowSize(f),C=new el(c,g,o,l==null),v=l==null?[r]:[r,l],D=i.runWebGLProgram(C,v,"int32");if(D.shape.length===r.shape.length){const F=Qi(i,r,o,D);return i.disposeIntermediateTensorInfo(D),F}return D}function Zi(i,r,o,l){const c=[o];if(p.Wap.assertAxesAreInnerMostDims("arg"+l.charAt(0).toUpperCase()+l.slice(1),c,r.shape.length),!(0,p.OBj)().getBool("WEBGL_PACK_REDUCE")||r.shape.length<=2){const f=[],g=i.texData.get(r.dataId),C=g!==null&&g.isPacked;let v=r;C&&(v=i.unpackTensor(r),f.push(v));const[D,F]=p.Wap.computeOutAndReduceShapes(v.shape,c),H=p.D5U.sizeFromShape(F),Y=Ht({inputs:{x:v},backend:i,attrs:{shape:[-1,H]}});f.push(Y);const te=qi(i,Y,l);f.push(te);const ae=Ht({inputs:{x:te},backend:i,attrs:{shape:D}});return f.forEach(Ce=>i.disposeIntermediateTensorInfo(Ce)),ae}return Qi(i,r,l)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tl(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{axis:f}=l;let g=p.D5U.parseAxisParam(f,c.shape);const C=p.Wap.getAxesPermutation(g,c.shape.length);let v=c;const D=[];C!=null&&(v=dr({inputs:{x:c},backend:o,attrs:{perm:C}}),D.push(v),g=p.Wap.getInnerMostAxes(g.length,v.shape.length)),p.Wap.assertAxesAreInnerMostDims("argMax",[g[0]],v.shape.length);const F=Zi(o,v,g[0],"max");return D.forEach(H=>o.disposeIntermediateTensorInfo(H)),F}const nl={kernelName:p.sJF,backendName:"webgl",kernelFunc:tl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sl(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{axis:f}=l;let g=p.D5U.parseAxisParam(f,c.shape);const C=p.Wap.getAxesPermutation(g,c.shape.length);let v=c;const D=[];C!=null&&(v=dr({inputs:{x:c},backend:o,attrs:{perm:C}}),D.push(v),g=p.Wap.getInnerMostAxes(g.length,v.shape.length)),p.Wap.assertAxesAreInnerMostDims("argMin",[g[0]],v.shape.length);const F=Zi(o,v,g[0],"min");return D.forEach(H=>o.disposeIntermediateTensorInfo(H)),F}const rl={kernelName:p.aJk,backendName:"webgl",kernelFunc:sl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ol=yr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,al=Bn({opSnippet:ol}),il={kernelName:p.M2y,backendName:"webgl",kernelFunc:al};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xi=yr+"return log(x + sqrt(x * x + 1.0));",ul=Bn({opSnippet:xi}),Ja={kernelName:p.qw7,backendName:"webgl",kernelFunc:ul};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ll=yr+`
  return atan(x);
`,Ji=Bn({opSnippet:ll}),cl={kernelName:p.jMg,backendName:"webgl",kernelFunc:Ji};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aa=$n+`
  return atan(a, b);
`,od=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Vs+`
  return result;
`,bi=sr({opSnippet:Aa,packedOpSnippet:od}),dl={kernelName:p.QCc,backendName:"webgl",kernelFunc:bi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eu=yr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,hl=Bn({opSnippet:eu}),wi={kernelName:p.Oyi,backendName:"webgl",kernelFunc:hl};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pa{constructor(r,o,l,c=!1,f=!1){if(this.variableNames=["x"],o==="avg"&&l)throw new Error("Cannot compute positions for average pool.");const g=r.filterWidth,C=r.strideHeight,v=r.strideWidth,D=r.dilationHeight,F=r.dilationWidth,H=r.effectiveFilterHeight,Y=r.effectiveFilterWidth,te=r.padInfo.top,ae=r.padInfo.left;this.outputShape=r.outShape;const Ce=o==="avg",Le=`((batch  * ${r.inHeight} + xR) * ${r.inWidth} + xC) * ${r.inChannels} + d`,be=`(xR * ${r.inWidth} + xC) * ${r.inChannels} + d`;let Ge="0.0";if(Ce||(Ge="-1.0 / 1e-20"),l){const rn=">=";this.userCode=`
        const ivec2 strides = ivec2(${C}, ${v});
        const ivec2 pads = ivec2(${te}, ${ae});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${H};
              wR += ${D}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${r.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${Y};
                wC += ${F}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${r.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${rn} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${c?f?Le:be:`wR * ${Y} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const Et="max";let vt=`${o}(${o}(${o}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;o==="avg"&&(vt="avgValue / max(count, 1.0)");const jt=Math.floor(g/4)*4,En=g%4,gn=`
      if (${Ce}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${Et}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${C}, ${v});
      const ivec2 pads = ivec2(${te}, ${ae});
      const float initializationValue = ${Ge};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${r.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${Ge});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${H};
            wR += ${D}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${r.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${jt}; wC += 4) {
            int xC = xCCorner + wC * ${F};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${F}, d),
              getValue(batch, xR, xC + 2 * ${F}, d),
              getValue(batch, xR, xC + 3 * ${F}, d)
            );

            ${gn}
          }

          int xC = xCCorner + ${jt};
          if (${En===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${gn}
          } else if (${En===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${F}, d),
              initializationValue,
              initializationValue
            );

            ${gn}
          } else if (${En===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${F}, d),
              getValue(batch, xR, xC + 2 * ${F}, d),
              initializationValue
            );

            ${gn}
          }
        }
        setOutput(${vt});
      }
    `}}class la{constructor(r,o,l,c=!1,f=!1){if(this.variableNames=["x"],o==="avg"&&l)throw new Error("Cannot compute positions for average pool.");const g=r.filterWidth,C=r.strideDepth,v=r.strideHeight,D=r.strideWidth,F=r.dilationDepth,H=r.dilationHeight,Y=r.dilationWidth,te=r.effectiveFilterDepth,ae=r.effectiveFilterHeight,Ce=r.effectiveFilterWidth,Le=r.padInfo.front,be=r.padInfo.top,Ge=r.padInfo.left;this.outputShape=r.outShape;const Et=o==="avg";let vt="0.0";if(Et||(vt="-1.0 / 1e-20"),l){const _n=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${C}, ${v}, ${D});
        const ivec3 pads = ivec3(${Le}, ${be}, ${Ge});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${te};
              wD += ${F}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${r.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${ae};
                wR += ${H}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${r.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${Ce};
                  wC += ${Y}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${r.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${_n} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${c?f?`(((batch * ${r.inDepth} + xD) * ${r.inHeight} + xR) * ${r.inWidth} + xC) * ${r.inChannels} + ch`:`((xD * ${r.inHeight} + xR) * ${r.inWidth} + xC) * ${r.inChannels} + ch`:`wD * ${ae} * ${Ce} +
                      wR * ${Ce} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const jt="max";let En=`${o}(${o}(${o}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;o==="avg"&&(En="avgValue / max(count, 1.0)");const gn=Math.floor(g/4)*4,rn=g%4,Gn=`
      if (${Et}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${jt}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${C}, ${v}, ${D});
      const ivec3 pads = ivec3(${Le}, ${be}, ${Ge});
      const float initializationValue = ${vt};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${r.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${vt});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${te};
            wD += ${F}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${r.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${ae};
            wR += ${H}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${r.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${gn}; wC += 4) {
              int xC = xCCorner + wC * ${Y};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${Y}, ch),
                getValue(batch, xD, xR, xC + 2 * ${Y}, ch),
                getValue(batch, xD, xR, xC + 3 * ${Y}, ch)
              );

              ${Gn}
            }

            int xC = xCCorner + ${gn};
            if (${rn===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${Gn}
            } else if (${rn===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${Y}, ch),
                initializationValue,
                initializationValue
              );

              ${Gn}
            } else if (${rn===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${Y}, ch),
                getValue(batch, xD, xR, xC + 2 * ${Y}, ch),
                initializationValue
              );

              ${Gn}
            }
          }
        }
        setOutput(${En});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pl(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r;mn(c,"avgPool");const{filterSize:f,strides:g,pad:C,dimRoundingMode:v}=l,D=1;p.D5U.assert(p.Wap.eitherStridesOrDilationsAreOne(g,D),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${g} and dilations '${D}'`);const F=p.Wap.computePool2DInfo(c.shape,f,g,D,C,v);if(F.filterWidth===1&&F.filterHeight===1&&p.D5U.arraysEqual(F.inShape,F.outShape))return rs({inputs:{x:c},backend:o});const H=new Pa(F,"avg",!1);return o.runWebGLProgram(H,[c],"float32")}const fl={kernelName:p.JhU,backendName:"webgl",kernelFunc:pl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ml(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{filterSize:f,strides:g,pad:C,dimRoundingMode:v,dataFormat:D}=l,F=[1,1,1],H=p.Wap.computePool3DInfo(c.shape,f,g,F,C,v,D),Y=new la(H,"avg",!1);return o.runWebGLProgram(Y,[c],"float32")}const gl={kernelName:p._k9,backendName:"webgl",kernelFunc:ml};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yl{constructor(r){this.variableNames=["dy"],this.outputShape=r.inShape;const o=r.filterHeight,l=r.filterWidth,c=r.strideHeight,f=r.strideWidth,g=r.dilationHeight,C=r.dilationWidth,v=r.effectiveFilterHeight,D=r.effectiveFilterWidth,F=v-1-r.padInfo.top,H=D-1-r.padInfo.left,Y=1/(o*l);this.userCode=`
      const ivec2 pads = ivec2(${F}, ${H});
      const float avgMultiplier = float(${Y});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${v};
            wR += ${g}) {
          float dyR = float(dyRCorner + wR) / ${c}.0;

          if (dyR < 0.0 || dyR >= ${r.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${D};
            wC+= ${C}) {
            float dyC = float(dyCCorner + wC) / ${f}.0;

            if (dyC < 0.0 || dyC >= ${r.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class vi{constructor(r){this.variableNames=["dy"],this.outputShape=r.inShape;const o=r.filterDepth,l=r.filterHeight,c=r.filterWidth,f=r.strideDepth,g=r.strideHeight,C=r.strideWidth,v=r.dilationDepth,D=r.dilationHeight,F=r.dilationWidth,H=r.effectiveFilterDepth,Y=r.effectiveFilterHeight,te=r.effectiveFilterWidth,ae=H-1-r.padInfo.front,Ce=Y-1-r.padInfo.top,Le=te-1-r.padInfo.left,be=1/(o*l*c);this.userCode=`
      const ivec3 pads = ivec3(${ae}, ${Ce}, ${Le});
      const float avgMultiplier = float(${be});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${H};
            wD += ${v}) {
          float dyD = float(dyDCorner + wD) / ${f}.0;

          if (dyD < 0.0 || dyD >= ${r.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${Y};
              wR += ${D}) {
            float dyR = float(dyRCorner + wR) / ${g}.0;

            if (dyR < 0.0 || dyR >= ${r.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${te};
                wC += ${F}) {
              float dyC = float(dyCCorner + wC) / ${C}.0;

              if (dyC < 0.0 || dyC >= ${r.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wa(i){const{inputs:r,backend:o,attrs:l}=i,{dy:c,input:f}=r,g=f,{filterSize:C,strides:v,pad:D,dimRoundingMode:F}=l,H=[1,1,1],Y=p.Wap.computePool3DInfo(g.shape,C,v,H,D,F),te=new vi(Y);return o.runWebGLProgram(te,[c],g.dtype)}const Ds={kernelName:p.IMb,backendName:"webgl",kernelFunc:wa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oa(i){const{inputs:r,backend:o,attrs:l}=i,{dy:c,input:f}=r,g=f;mn([c,f],"avgPoolGrad");const{filterSize:C,strides:v,pad:D}=l,F=p.Wap.computePool2DInfo(g.shape,C,v,1,D),H=new yl(F);return o.runWebGLProgram(H,[c],g.dtype)}const xl={kernelName:p.ROF,backendName:"webgl",kernelFunc:Oa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bl(i){const{inputs:r,backend:o,attrs:l}=i,{a:c,b:f}=r,{transposeA:g,transposeB:C}=l;return rr({a:c,b:f,transposeA:g,transposeB:C,backend:o})}const ca={kernelName:p.XLW,backendName:"webgl",kernelFunc:bl};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wl{constructor(r,o,l,c,f,g){this.outputShape=[],this.variableNames=["x","mean","variance"],p.Wap.assertAndGetBroadcastShape(r,o),p.Wap.assertAndGetBroadcastShape(r,l);let C="0.0";c!=null&&(p.Wap.assertAndGetBroadcastShape(r,c),this.variableNames.push("offset"),C="getOffsetAtOutCoords()");let v="1.0";f!=null&&(p.Wap.assertAndGetBroadcastShape(r,f),this.variableNames.push("scale"),v="getScaleAtOutCoords()"),this.outputShape=r,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${C};
        float scale = ${v};
        float inv = scale * inversesqrt(variance + float(${g}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tu{constructor(r,o,l,c,f,g){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],p.Wap.assertAndGetBroadcastShape(r,o),p.Wap.assertAndGetBroadcastShape(r,l);let C="vec4(0.0)";c!=null&&(p.Wap.assertAndGetBroadcastShape(r,c),this.variableNames.push("offset"),C="getOffsetAtOutCoords()");let v="vec4(1.0)";f!=null&&(p.Wap.assertAndGetBroadcastShape(r,f),this.variableNames.push("scale"),v="getScaleAtOutCoords()"),this.outputShape=r,this.userCode=`
      void main() {
        vec4 offset = ${C};
        vec4 scale = ${v};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${g}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vl=({inputs:i,backend:r,attrs:o})=>{const{x:l,mean:c,variance:f,offset:g,scale:C}=i;p.D5U.assert(c.shape.length===f.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),p.D5U.assert(g==null||c.shape.length===g.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),p.D5U.assert(C==null||c.shape.length===C.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:v}=o;v==null&&(v=.001);const D=[l,c,f];let F=null;g!=null&&(F=g.shape,D.push(g));let H=null;C!=null&&(H=C.shape,D.push(C));const Y=(0,p.OBj)().getBool("WEBGL_PACK_NORMALIZATION")?new tu(l.shape,c.shape,f.shape,F,H,v):new wl(l.shape,c.shape,f.shape,F,H,v);return r.runWebGLProgram(Y,D,D[0].dtype)},Cl={kernelName:p.sHE,backendName:"webgl",kernelFunc:vl};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nu{constructor(r){this.variableNames=["source"],this.outputShape=r,this.rank=r.length;const o=An(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const l=Sl(this.rank);let c;const f=r.map((g,C)=>`sourceLoc.${Ci[C]} = start[${C}] + coords.${Ci[C]};`);c=`
        ${o} sourceLoc;
        ${o} coords = getOutputCoords();
        ${f.join(`
`)}
      `,this.userCode=`
      void main() {
        ${c}
        setOutput(getSource(${l}));
      }
    `}}const Ci=["x","y","z","w","u","v"];function Sl(i){if(i===1)return"sourceLoc";if(i<=6)return Ci.slice(0,i).map(r=>"sourceLoc."+r).join(",");throw Error(`Slicing for rank ${i} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Il{constructor(r){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.rank=r.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const o=An(this.rank),l=os("coords",this.rank),c=os("sourceLoc",this.rank),f=this.rank===1?"sourceLoc":`vec2(${c.slice(-2).join()})`,g=`getChannel(getSource(${c.join()}), ${f})`,C=`
      result.x = ${g};
      if (++${l[this.rank-1]} < ${r[this.rank-1]}) {
        ++${c[this.rank-1]};
        result.y = ${g};
        --${c[this.rank-1]};
      }
    `,v=this.rank===1?"":`
      --${l[this.rank-1]};
      if (++${l[this.rank-2]} < ${r[this.rank-2]}) {
        ++${c[this.rank-2]};
        result.z = ${g};
        if (++${l[this.rank-1]} < ${r[this.rank-1]}) {
          ++${c[this.rank-1]};
          result.w = ${g};
        }
      }
    `,D=this.rank<=4?`sourceLoc = coords +
            ${o}(${r.map((F,H)=>`start[${H}]`).join()});`:r.map((F,H)=>`${c[H]} = ${l[H]} + start[${H}];`).join(`
`);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        ${o} sourceLoc;
        ${D}
        vec4 result = vec4(0.);
        ${C}
        ${v}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function El(i,r,o,l){const c=l.texData.get(i.dataId),f=l.makeTensorInfo(o,i.dtype),g=l.texData.get(f.dataId);Object.assign(g,c),g.refCount=1,g.shape=o,g.dtype=i.dtype;let C=p.kuN.computeFlatOffset(r,p.D5U.computeStrides(i.shape));c.slice&&(C+=c.slice.flatOffset),g.slice={flatOffset:C,origDataId:c.slice&&c.slice.origDataId||i.dataId};const v=l.dataRefCount.get(g.slice.origDataId)||1;return l.dataRefCount.set(g.slice.origDataId,v+1),f}function va(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{begin:f,size:g}=l,[C,v]=p.kuN.parseSliceParams(c,f,g);if(p.kuN.assertParamsValid(c,C,v),p.D5U.sizeFromShape(v)===0)return o.makeTensorInfo(v,c.dtype,[]);if(o.shouldExecuteOnCPU([c])||c.dtype==="string"){const H=o.texData.get(c.dataId),Y=He(H.values,C,v,c.shape,c.dtype);return o.makeTensorInfo(v,c.dtype,Y)}const{isPacked:D}=o.texData.get(c.dataId),F=p.kuN.isSliceContinous(c.shape,C,v);if(D||!F){const H=(0,p.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Il(v):new nu(v),Y=[C];return o.runWebGLProgram(H,[c],c.dtype,Y)}return o.uploadToGPU(c.dataId),El(c,C,v,o)}const Tl={kernelName:p.p2w,backendName:"webgl",kernelFunc:va};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $l=i=>{const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{blockShape:f,crops:g}=l;p.D5U.assert(c.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const C=f.reduce((Ge,Et)=>Ge*Et),v=p.Wap.getReshaped(c.shape,f,C),D=p.Wap.getPermuted(v.length,f.length),F=p.Wap.getReshapedPermuted(c.shape,f,C),H=p.Wap.getSliceBeginCoords(g,f.length),Y=p.Wap.getSliceSize(F,g,f.length),te=[],ae=Ht({inputs:{x:c},backend:o,attrs:{shape:v}}),Ce=dr({inputs:{x:ae},backend:o,attrs:{perm:D}}),Le=Ht({inputs:{x:Ce},backend:o,attrs:{shape:F}}),be=va({inputs:{x:Le},backend:o,attrs:{begin:H,size:Y}});return te.push(ae),te.push(Ce),te.push(Le),te.forEach(Ge=>o.disposeIntermediateTensorInfo(Ge)),be},Nl={kernelName:p.zws,backendName:"webgl",kernelFunc:$l};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Si(i){const{inputs:r,backend:o,attrs:l}=i,{x:c,weights:f}=r,{size:g}=l,C=o.readSync(c.dataId),v=o.readSync(f.dataId),D=Xr(C,v,f.dtype,f.shape,g);return o.makeTensorInfo([g],f.dtype,D)}const kl={kernelName:p.zvY,backendName:"webgl",kernelFunc:Si};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rl=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Dl=`
  return float(int(a.r) & int(b.r));
`;function _l(i){const{inputs:r,backend:o}=i,{a:l,b:c}=r,f=(0,p.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS"),g=(0,p.OBj)().getNumber("WEBGL_VERSION");if(o.shouldExecuteOnCPU([l,c])||g===1){const v=o.texData.get(l.dataId).values,D=o.texData.get(c.dataId).values,[F,H]=co(l.shape,c.shape,v,D,l.dtype),Y=o.makeTensorInfo(H,l.dtype),te=o.texData.get(Y.dataId);return te.values=F,Y}let C;return f?C=new Ts(Rl,l.shape,c.shape,!1):C=new es(Dl,l.shape,c.shape),o.runWebGLProgram(C,[l,c],l.dtype)}const su={kernelName:p.hCO,backendName:"webgl",kernelFunc:_l};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Al(i){const{inputs:r,backend:o}=i,{s0:l,s1:c}=r,f=o.readSync(l.dataId),g=o.readSync(c.dataId),C=p.Wap.assertAndGetBroadcastShape(Array.from(f),Array.from(g));return o.makeTensorInfo([C.length],"int32",Int32Array.from(C))}const Fa={kernelName:p.eEB,backendName:"webgl",kernelFunc:Al};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ei=sr({opSnippet:"return float(a != b);",cpuKernelImpl:mr,dtype:"bool"}),Ti={kernelName:p.yQU,backendName:"webgl",kernelFunc:Ei};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ca(i){const{inputs:r,backend:o}=i,{input:l}=r,c=o.texData.get(l.dataId);return rs({inputs:{x:c.complexTensorInfos.real},backend:o})}const Pl={kernelName:p.xJR,backendName:"webgl",kernelFunc:Ca};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ru="return float(int(x));";function Ol(i,r){const o=new Yr(i.shape,ru),l=r.runWebGLProgram(o,[i],"int32");return{dataId:l.dataId,shape:l.shape,dtype:l.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $i(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{dtype:f}=l;if(f==="complex64"){if(c.dtype==="complex64")return rs({inputs:{x:c},backend:o});const g=p.lls(c.shape),C=$i({inputs:{x:c},backend:o,attrs:{dtype:"float32"}}),v=po({inputs:{real:C,imag:g},backend:o});return g.dispose(),o.disposeIntermediateTensorInfo(C),v}if(c.dtype==="complex64"){const g=Ca({inputs:{input:c},backend:o}),C=$i({inputs:{x:g},backend:o,attrs:{dtype:f}});return o.disposeIntermediateTensorInfo(g),C}if(!p.D5U.hasEncodingLoss(c.dtype,f)){const g=rs({inputs:{x:c},backend:o});return{dataId:g.dataId,shape:g.shape,dtype:f}}if(o.shouldExecuteOnCPU([c])){const g=o.texData.get(c.dataId).values,[C,v,D]=zr(g,c.shape,c.dtype,f);return o.makeTensorInfo(C,v,D)}if(f==="int32")return Ol(c,o);if(f==="bool"){const g=o.makeTensorInfo([],"bool",p.D5U.getTypedArrayFromDType("bool",1)),v=Ei({inputs:{a:c,b:g},backend:o});return o.disposeIntermediateTensorInfo(g),v}throw new Error(`Error in Cast: failed to cast ${c.dtype} to ${f}`)}const Fl={kernelName:p.RFZ,backendName:"webgl",kernelFunc:$i};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ou="return ceil(x);",Bl=Bn({opSnippet:ou,packedOpSnippet:ou,cpuKernelImpl:Wn}),Ll={kernelName:p.gJX,backendName:"webgl",kernelFunc:Bl};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ul{constructor(r){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=r,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ml{constructor(r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=r,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wl(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{clipValueMin:f,clipValueMax:g}=l;let C;(0,p.OBj)().getBool("WEBGL_PACK_CLIP")?C=new Ml(c.shape):C=new Ul(c.shape);const v=[[f],[g]];return o.runWebGLProgram(C,[c],c.dtype,v)}const au={kernelName:p.xnO,backendName:"webgl",kernelFunc:Wl};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ni{constructor(r){this.variableNames=["real","imag"],this.outputShape=r,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iu(i,r){return{dataId:r.dataId,dtype:r.dtype,shape:i.shape}}function Vl(i){const{inputs:r,backend:o}=i,{x:l}=r,c=o.texData.get(l.dataId),f=new Ni(l.shape),g=[iu(l,c.complexTensorInfos.real),iu(l,c.complexTensorInfos.imag)];return o.runWebGLProgram(f,g,g[0].dtype)}const ki={kernelName:p.yj2,backendName:"webgl",kernelFunc:Vl};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zl{constructor(r){this.outputShape=[],this.outputShape=p.Wap.computeOutShape(r,1),this.variableNames=r.map((g,C)=>`T${C}`);const o=new Array(r.length-1);o[0]=r[0][1];for(let g=1;g<o.length;g++)o[g]=o[g-1]+r[g][1];const l=[`if (yC < ${o[0]}) setOutput(getT0(yR, yC));`];for(let g=1;g<o.length;g++){const C=o[g-1];l.push(`else if (yC < ${o[g]}) setOutput(getT${g}(yR, yC-${C}));`)}const c=o.length,f=o[o.length-1];l.push(`else setOutput(getT${c}(yR, yC-${f}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${l.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class or{constructor(r,o){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=p.Wap.computeOutShape(r,o);const l=this.outputShape,c=l.length,f=An(c),g=os("coords",c),C=["x","y","z","w","u","v"].slice(0,c);this.variableNames=r.map((Ce,Le)=>`T${Le}`);const v=new Array(r.length-1);v[0]=r[0][o];for(let Ce=1;Ce<v.length;Ce++)v[Ce]=v[Ce-1]+r[Ce][o];const D=C[o],F=C.slice(-2),H=C.join();let Y=`if (${D} < ${v[0]}) {
        return getChannel(
            getT0(${H}), vec2(${F.join()}));
        }`;for(let Ce=1;Ce<v.length;Ce++){const Le=v[Ce-1];Y+=`
        if (${D} < ${v[Ce]}  && ${D} >= ${v[Ce-1]}) {
          return getChannel(
            getT${Ce}(${ei(C,D,Le)}),
            vec2(${ei(F,D,Le)}));
        }`}const te=v.length,ae=v[v.length-1];Y+=`
        return getChannel(
          getT${te}(${ei(C,D,ae)}),
          vec2(${ei(F,D,ae)}));`,this.userCode=`
      float getValue(${C.map(Ce=>"int "+Ce)}) {
        ${Y}
      }

      void main() {
        ${f} coords = getOutputCoords();
        vec4 result = vec4(getValue(${g}), 0., 0., 0.);

        ${g[c-1]} = ${g[c-1]} + 1;
        if (${g[c-1]} < ${l[c-1]}) {
          result.g = getValue(${g});
        }

        ${g[c-2]} = ${g[c-2]} + 1;
        if (${g[c-2]} < ${l[c-2]}) {
          result.a = getValue(${g});
        }

        ${g[c-1]} = ${g[c-1]} - 1;
        if (${g[c-2]} < ${l[c-2]} &&
            ${g[c-1]} < ${l[c-1]}) {
          result.b = getValue(${g});
        }
        setOutput(result);
      }
    `}}function ei(i,r,o){const l=i.indexOf(r);return i.map((f,g)=>g===l?`${f} - ${o}`:f).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ti(i){const{inputs:r,backend:o}=i,{input:l}=r,c=o.texData.get(l.dataId);return rs({inputs:{x:c.complexTensorInfos.imag},backend:o})}const Gl={kernelName:p.J_u,backendName:"webgl",kernelFunc:ti};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ba(i,r,o){const l=i[0].dtype;if(l==="complex64"){const te=i.map(Ge=>Ca({inputs:{input:Ge},backend:o})),ae=i.map(Ge=>ti({inputs:{input:Ge},backend:o})),Ce=Ba(te,r,o),Le=Ba(ae,r,o),be=po({inputs:{real:Ce,imag:Le},backend:o});return te.forEach(Ge=>o.disposeIntermediateTensorInfo(Ge)),ae.forEach(Ge=>o.disposeIntermediateTensorInfo(Ge)),o.disposeIntermediateTensorInfo(Ce),o.disposeIntermediateTensorInfo(Le),be}let c=o.shouldExecuteOnCPU(i);if(l==="string"&&(c=!0),c){const te=i.map(vt=>{const En=[-1,p.D5U.sizeFromShape(vt.shape.slice(r))];return Ht({inputs:{x:vt},backend:o,attrs:{shape:En}})}),ae=te.map(vt=>({vals:o.readSync(vt.dataId),shape:vt.shape})),Ce=p.Wap.computeOutShape(te.map(vt=>vt.shape),1),Le=te[0].shape[0]===1,be=ea(ae,Ce,l,Le),Ge=p.Wap.computeOutShape(i.map(vt=>vt.shape),r),Et=o.makeTensorInfo(Ge,l,be);return te.forEach(vt=>o.disposeIntermediateTensorInfo(vt)),Et}const f=i.filter(te=>p.D5U.sizeFromShape(te.shape)>0),g=(0,p.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&f[0].shape.length>1;if(f.length===1){const te=g?new Yr(i[0].shape,No):new E(i[0].shape,No);return o.runWebGLProgram(te,i,l)}const C=(0,p.OBj)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(f.length>C){const te=[];for(let Ce=0;Ce<f.length;Ce+=C){const Le=f.slice(Ce,Ce+C);te.push(Ba(Le,r,o))}const ae=Ba(te,r,o);for(const Ce of te)o.disposeIntermediateTensorInfo(Ce);return ae}if(g){const te=new or(f.map(ae=>ae.shape),r);return o.runWebGLProgram(te,f,l)}const{tensors2D:v,outShape:D}=Hl(f,r,o),F=new zl(v.map(te=>te.shape)),H=o.runWebGLProgram(F,v,l);v.forEach(te=>o.disposeIntermediateTensorInfo(te));const Y=Ht({inputs:{x:H},attrs:{shape:D},backend:o});return o.disposeIntermediateTensorInfo(H),Y}function Hl(i,r,o){const l=p.Wap.computeOutShape(i.map(f=>f.shape),r);return{tensors2D:i.map(f=>Ht({inputs:{x:f},attrs:{shape:[-1,p.D5U.sizeFromShape(f.shape.slice(r))]},backend:o})),outShape:l}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ri(i){const{inputs:r,backend:o,attrs:l}=i,{axis:c}=l,f=p.D5U.parseAxisParam(c,r[0].shape)[0],g=r.map(D=>D.shape);p.Wap.assertParamsConsistent(g,f);const C=p.Wap.computeOutShape(r.map(D=>D.shape),f);if(p.D5U.sizeFromShape(C)===0)return o.makeTensorInfo(C,r[0].dtype,[]);const v=r.filter(D=>p.D5U.sizeFromShape(D.shape)>0);return v.length===1?rs({inputs:{x:v[0]},backend:o}):Ba(v,f,o)}const jl={kernelName:p.Eh3,backendName:"webgl",kernelFunc:Ri};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uu{constructor(r,o=!1,l=null,c=!1,f=!1){this.variableNames=["x","W"],this.outputShape=r.outShape;const g=r.padInfo.top,C=r.padInfo.left,v=r.strideHeight,D=r.strideWidth,F=r.dilationHeight,H=r.dilationWidth,Y=r.filterHeight,te=r.filterWidth,ae=Math.floor(r.inChannels/4)*4,Ce=r.inChannels%4,Le=r.dataFormat==="channelsLast",be=Le?1:2,Ge=Le?2:3,Et=Le?3:1;let vt="",jt="";l&&(c?vt=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${l}
        }`:f?vt=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${l}
        }`:vt=`
          float activation(float x) {
            ${l}
          }
        `,jt="result = activation(result);");const En=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),f&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${vt}

      const ivec2 strides = ivec2(${v}, ${D});
      const ivec2 pads = ivec2(${g}, ${C});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${Et}];

        ivec2 xRCCorner =
            ivec2(coords[${be}], coords[${Ge}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${Y}; wR++) {
          int xR = xRCorner + wR * ${F};

          if (xR < 0 || xR >= ${r.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${te}; wC++) {
            int xC = xCCorner + wC * ${H};

            if (xC < 0 || xC >= ${r.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${ae}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${Le}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${Ce===1}) {

              if (${Le}) {
                dotProd +=
                    getX(batch, xR, xC, ${ae}) *
                    getW(wR, wC, ${ae}, d2);
              } else {
                dotProd +=
                    getX(batch, ${ae}, xR, xC) *
                    getW(wR, wC, ${ae}, d2);
              }

            } else if (${Ce===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${ae}, d2),
                getW(wR, wC, ${ae} + 1, d2)
              );

              if (${Le}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${ae}),
                  getX(batch, xR, xC, ${ae} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${ae}, xR, xC),
                  getX(batch, ${ae} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${Ce===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${ae}, d2),
                getW(wR, wC, ${ae} + 1, d2),
                getW(wR, wC, ${ae} + 2, d2)
              );

              if (${Le}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${ae}),
                  getX(batch, xR, xC, ${ae} + 1),
                  getX(batch, xR, xC, ${ae} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${ae}, xR, xC),
                  getX(batch, ${ae} + 1, xR, xC),
                  getX(batch, ${ae} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${En}
        ${jt}
        setOutput(result);
      }
    `}}class Kl{constructor(r){this.variableNames=["x","W"],this.outputShape=r.outShape;const o=r.padInfo.front,l=r.padInfo.top,c=r.padInfo.left,f=r.strideDepth,g=r.strideHeight,C=r.strideWidth,v=r.dilationDepth,D=r.dilationHeight,F=r.dilationWidth,H=r.filterDepth,Y=r.filterHeight,te=r.filterWidth,ae=Math.floor(r.inChannels/4)*4,Ce=r.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${f}, ${g}, ${C});
      const ivec3 pads = ivec3(${o}, ${l}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${H}; wF++) {
          int xF = xFCorner + wF * ${v};

          if (xF < 0 || xF >= ${r.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${Y}; wR++) {
            int xR = xRCorner + wR * ${D};

            if (xR < 0 || xR >= ${r.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${te}; wC++) {
              int xC = xCCorner + wC * ${F};

              if (xC < 0 || xC >= ${r.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${ae}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${Ce===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${ae}) *
                  getW(wF, wR, wC, ${ae}, d2);
              } else if (${Ce===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${ae}),
                  getX(batch, xF, xR, xC, ${ae} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${ae}, d2),
                  getW(wF, wR, wC, ${ae} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${Ce===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${ae}),
                  getX(batch, xF, xR, xC, ${ae} + 1),
                  getX(batch, xF, xR, xC, ${ae} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${ae}, d2),
                  getW(wF, wR, wC, ${ae} + 1, d2),
                  getW(wF, wR, wC, ${ae} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lu{constructor(r,o=!1,l=null,c=!1,f=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=r.outShape,this.enableShapeUniforms=Jn(this.outputShape.length);const g=r.padInfo.left,C=r.strideWidth,v=r.dilationWidth,D=r.filterHeight,F=r.filterWidth,H=F;let Y=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let Le=0;Le<F;Le++)Y+=`
           vec4 xTexelC${Le*2};
           int xTexelC${Le*2}Ready;
           vec4 xTexelC${Le*2+1};
           int xTexelC${Le*2+1}Ready;
           vec4 xC${Le};`;Y+=`
     for (int r = 0; r < ${D}; r++) {
      for (int d1 = 0; d1 < ${r.inChannels}; d1 += 2) {
       `;for(let Le=0;Le<F;Le++)Y+=`
           xTexelC${Le*2} = vec4(0.0);
           xTexelC${Le*2}Ready = 0;
           xTexelC${Le*2+1} = vec4(0.0);
           xTexelC${Le*2+1}Ready = 0;
           xC${Le} = vec4(0.0);`;Y+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let Le=0;Le<(H+1)/2;Le++){const be=Le*2;if(Y+=`
           xC = xCCorner + ${be*v};
           `,C===1){if(be<F&&(g%2===1?(Y+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${be}Ready == 0) {
                   xTexelC${be} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${be}.zw = vec2(0.0);
                   }
                   xTexelC${be}Ready = 1;
                 }
               `,v===1&&be>0?Y+=`
                 xC${be} = vec4(xTexelC${be-2}.zw, xTexelC${be}.xy);
                 `:Y+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${be} = vec4(previous.zw, xTexelC${be}.xy);
                   } else {
                     xC${be} = vec4(0.0, 0.0, xTexelC${be}.xy);
                   }
                   `):Y+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${be}Ready == 0) {
                   xTexelC${be} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${be}.zw = vec2(0.0);
                   }
                   xTexelC${be}Ready = 1;
                 }

                 xC${be} = xTexelC${be};
                 `,be+1<F)){const Ge=g%2===0?p.D5U.nearestLargerEven(v):v;v%2===0&&g%2===1||v%2!==0&&g%2!==1?(Y+=`
                   xCOffset = xC + imod(pads[1], 2) + ${Ge};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${be+1}Ready == 0) {
                     xTexelC${be+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${be+1}.zw = vec2(0.0);
                     }
                     xTexelC${be+1}Ready = 1;
                   }
                   `,v>1?Y+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${be+1} = vec4(previous.zw, xTexelC${be+1}.xy);
                     } else {
                      xC${be+1} = vec4(0.0, 0.0, xTexelC${be+1}.xy);
                     }
                     `:Y+=`
                     xC${be+1} = vec4(xTexelC${be}.zw, xTexelC${be+1}.xy);
                     `):Ge===1?Y+=`
                     xC${be+1} = xTexelC${be};
                     `:Y+=`
                     xCOffset = xC + ${Ge};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${be+1}Ready == 0) {
                       xTexelC${be+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${be+1}.zw = vec2(0.0);
                       }
                       xTexelC${be+1}Ready = 1;
                     }

                     xC${be+1} = xTexelC${be+1};
                     `}}else be<F&&(g%2===1?(Y+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${be}Ready == 0) {
                   xTexelC${be} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${be}.zw = vec2(0.0);
                   }
                   xTexelC${be}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${be+1}Ready == 0) {
                   xTexelC${be+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${be+1}.zw = vec2(0.0);
                   }
                   xTexelC${be+1}Ready = 1;
                 }

                 xC${be} = vec4(xTexelC${be}.zw, xTexelC${be+1}.zw);
               `,be+1<F&&(Y+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${be+1} = vec4(xTexelC${be+1}.xy, final.xy);
                 `)):(Y+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${be}Ready == 0) {
                   xTexelC${be} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${be}.zw = vec2(0.0);
                   }
                   xTexelC${be}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${be+1}Ready == 0) {
                   xTexelC${be+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${be+1}.zw = vec2(0.);
                   }
                   xTexelC${be+1}Ready = 1;
                 }

                 xC${be} = vec4(
                   xTexelC${be}.xy, xTexelC${be+1}.xy);
               `,be+1<F&&(Y+=`
                   xC${be+1} = vec4(xTexelC${be}.zw, xTexelC${be+1}.zw);
                 `)));be<F&&(Y+=`
             wTexel = getW(r, ${be}, d1, d2);
             dotProd += xC${be}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${r.inChannels}) {
               dotProd += xC${be}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,be+1<F&&(Y+=`
               wTexel = getW(r, ${be+1}, d1, d2);
               dotProd += xC${be+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${r.inChannels}) {
                 dotProd += xC${be+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}Y+=`
     }
   `,Y+=`
     }
   `,Y+=`
     }
   `;let te="",ae="";l&&(c?te=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${l}
         }`:f?te=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${l}
         }`:te=`vec4 activation(vec4 x) {
           ${l}
         }`,ae="result = activation(result);");const Ce=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),f&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${te}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${Y}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${Ce}
         ${ae}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xl{constructor(r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=r,this.enableShapeUniforms=Jn(this.outputShape.length);const{dataFormat:l}=o,c=Dn(),f=l==="channelsLast",g=f?1:2,C=f?2:3,v=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${r[2]} && pos < ${r[1]}) {`;let D="";for(let F=0;F<=1;F++)for(let H=0;H<=1;H++)D+=`
          blockIndex = rc.z + ${H};
          pos = rc.y + ${F};

          ${v}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${g}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${C}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${f}) {
                  innerDims = vec2(d1, ch);
                  result[${F*2+H}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${F*2+H}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${D}

        ${c.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function La(i,r){const o=i.length;return o>=3?r?[...i.slice(0,-3),i[o-3]*i[o-2],i[o-1]]:[...i.slice(0,-3),i[o-3],i[o-2]*i[o-1]]:!r&&o===1&&i[0]>1?[i[0],1]:null}function cu({x:i,filter:r,convInfo:o,backend:l,bias:c=null,preluActivationWeights:f=null,leakyreluAlpha:g=0,activation:C=null}){const v=i.shape,D=l.texData.get(i.dataId),F=o.inChannels,H=v[0]*v[1]*v[2],Y=o.outChannels,te=o.dataFormat==="channelsLast",ae=!1,Ce=!1;let Le;const be=[];if(f!=null){const vt=La(f.shape,te);vt!=null&&(f=Ht({inputs:{x:f},backend:l,attrs:{shape:vt}}),be.push(f))}if(c!=null){const vt=La(c.shape,te);vt!=null&&(c=Ht({inputs:{x:c},backend:l,attrs:{shape:vt}}),be.push(c))}if(!((H===1||Y===1)&&F>go)&&D.isPacked&&te&&D.texture!=null&&v[2]%2!==0&&p.D5U.arraysEqual(D.shape.slice(-3),v.slice(-3))){const vt=v[0]*v[1]*(v[2]+1),jt={dataId:i.dataId,shape:[1,vt,o.inChannels],dtype:i.dtype},En=D.shape;D.shape=D.shape.slice(),D.shape[D.shape.length-2]++,p.D5U.assert(_r(D.shape,jt.shape),()=>`packed reshape ${D.shape} to ${jt.shape} isn't free`);const gn=Ht({inputs:{x:r},backend:l,attrs:{shape:[1,o.inChannels,o.outChannels]}});be.push(gn);const rn=rr({a:jt,b:gn,backend:l,transposeA:ae,transposeB:Ce,bias:c,activation:C,preluActivationWeights:f,leakyreluAlpha:g}),Gn=l.texData.get(rn.dataId);p.D5U.assert(Gn.isPacked,()=>"batchMatMul result is expected to be packed"),D.shape=En,Gn.shape=o.outShape,Le=rs({inputs:{x:rn},backend:l}),Le.shape=o.outShape,be.push(rn)}else{const vt=o.outHeight*o.outWidth,jt=Ht({inputs:{x:i},backend:l,attrs:{shape:te?[o.batchSize,vt,o.inChannels]:[o.batchSize,o.inChannels,vt]}}),En=Ht({inputs:{x:r},backend:l,attrs:{shape:[1,o.inChannels,o.outChannels]}}),gn=rr({a:te?jt:En,b:te?En:jt,transposeA:!te,transposeB:Ce,backend:l,bias:c,activation:C,preluActivationWeights:f,leakyreluAlpha:g});Le=Ht({inputs:{x:gn},backend:l,attrs:{shape:o.outShape}}),be.push(jt),be.push(En),be.push(gn)}for(const vt of be)l.disposeIntermediateTensorInfo(vt);return Le}function da({x:i,filter:r,convInfo:o,backend:l,bias:c=null,preluActivationWeights:f=null,leakyreluAlpha:g=0,activation:C=null}){const{filterWidth:v,filterHeight:D,inChannels:F,outWidth:H,outHeight:Y,dataFormat:te}=o,ae=te==="channelsLast",Ce=v*D*F,Le=Y*H,be=[o.batchSize,Ce,Le],Ge=!0,Et=!1,vt=[];if(f!=null){const Dr=La(f.shape,ae);Dr!=null&&(f=Ht({inputs:{x:f},backend:l,attrs:{shape:Dr}}),vt.push(f))}if(c!=null){const Dr=La(c.shape,ae);Dr!=null&&(c=Ht({inputs:{x:c},backend:l,attrs:{shape:Dr}}),vt.push(c))}const jt=Ht({inputs:{x:r},backend:l,attrs:{shape:[1,Ce,p.D5U.sizeFromShape(r.shape)/Ce]}});vt.push(jt);const En=new Xl(be,o),gn=[i.shape,[o.padInfo.top,o.padInfo.left],[o.strideHeight,o.strideWidth],[o.dilationHeight,o.dilationWidth],[o.inChannels],[o.filterWidth*o.inChannels],[o.outWidth]],rn=l.runWebGLProgram(En,[i],"float32",gn),Gn=Ht({inputs:{x:rn},backend:l,attrs:{shape:be}});vt.push(rn),vt.push(Gn);const _n=c!=null,_s=f!=null,Ls=C==="leakyrelu",Zo=C?Qa(C,!0):null,Xs=new oa(ae?Gn.shape:jt.shape,ae?jt.shape:Gn.shape,ae?[o.batchSize,Le,o.outChannels]:[o.batchSize,o.outChannels,Le],Ge,Et,_n,Zo,_s,Ls),us=ae?[Gn,jt]:[jt,Gn];if(c&&us.push(c),_s&&us.push(f),Ls){const Dr=l.makeTensorInfo([],"float32",p.D5U.createScalarValue(g,"float32"));us.push(Dr),vt.push(Dr)}const yo=l.runWebGLProgram(Xs,us,"float32"),Mo=Ht({inputs:{x:yo},backend:l,attrs:{shape:o.outShape}});vt.push(yo);for(const Dr of vt)l.disposeIntermediateTensorInfo(Dr);return Mo}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yl(i){const{inputs:r,backend:o,attrs:l}=i,{x:c,filter:f}=r,{strides:g,pad:C,dataFormat:v,dilations:D,dimRoundingMode:F}=l,H=p.Wap.convertConv2DDataFormat(v),Y=p.Wap.computeConv2DInfo(c.shape,f.shape,g,D,C,F,!1,H);let te;if(Y.filterHeight===1&&Y.filterWidth===1&&Y.dilationHeight===1&&Y.dilationWidth===1&&Y.strideHeight===1&&Y.strideWidth===1&&(Y.padInfo.type==="SAME"||Y.padInfo.type==="VALID"))te=cu({x:c,filter:f,convInfo:Y,backend:o});else if(Y.strideWidth<=2&&H==="channelsLast"&&(0,p.OBj)().getBool("WEBGL_EXP_CONV")){const Ce=new lu(Y),Le=[[Y.padInfo.top,Y.padInfo.left],[Y.strideHeight,Y.strideWidth],[Y.dilationHeight,Y.dilationWidth],[Y.inHeight,Y.inWidth]];te=o.runWebGLProgram(Ce,[c,f],"float32",Le)}else if((0,p.OBj)().getBool("WEBGL_CONV_IM2COL"))te=da({x:c,filter:f,convInfo:Y,backend:o});else{const Ce=new uu(Y);te=o.runWebGLProgram(Ce,[c,f],"float32")}const ae=Ht({inputs:{x:te},backend:o,attrs:{shape:Y.outShape}});return o.disposeIntermediateTensorInfo(te),ae}const du={kernelName:p.mhS,backendName:"webgl",kernelFunc:Yl};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Di{constructor(r){this.variableNames=["x","dy"],this.outputShape=r.filterShape;const o=r.strideHeight,l=r.strideWidth,c=r.padInfo.top,f=r.padInfo.left,g=r.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${r.batchSize}; b++) {
          for (int yR = 0; yR < ${r.outHeight}; yR++) {
            int xR = wR + yR * ${o} - ${c};

            if (xR < 0 || xR >= ${r.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${r.outWidth}; yC++) {
              int xC = wC + yC * ${l} - ${f};

              if (xC < 0 || xC >= ${r.inWidth}) {
                continue;
              }

              ${g?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class ql{constructor(r){this.variableNames=["dy","W"],this.outputShape=r.inShape;const o=r.filterHeight,l=r.filterWidth,c=r.strideHeight,f=r.strideWidth,g=r.dataFormat==="channelsLast",C=o-1-r.padInfo.top,v=l-1-r.padInfo.left,D=g?1:2,F=g?2:3,H=g?3:1;this.userCode=`
      const ivec2 pads = ivec2(${C}, ${v});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${H}];

        ivec2 dyCorner = ivec2(coords[${D}], coords[${F}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o}; wR++) {
          float dyR = float(dyRCorner + wR) / ${c}.0;

          if (dyR < 0.0 || dyR >= ${r.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${o} - 1 - wR;

          for (int wC = 0; wC < ${l}; wC++) {
            float dyC = float(dyCCorner + wC) / ${f}.0;

            if (dyC < 0.0 || dyC >= ${r.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${l} - 1 - wC;

            for (int d2 = 0; d2 < ${r.outChannels}; d2++) {

              if (${g}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Ql{constructor(r){this.variableNames=["x","dy"],this.outputShape=r.filterShape;const o=r.strideDepth,l=r.strideHeight,c=r.strideWidth,f=r.padInfo.front,g=r.padInfo.top,C=r.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${r.batchSize}; b++) {
          for (int yF = 0; yF < ${r.outDepth}; yF++) {
            int xF = wF + yF * ${o} - ${f};

            if (xF < 0 || xF >= ${r.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${r.outHeight}; yR++) {
              int xR = wR + yR * ${l} - ${g};

              if (xR < 0 || xR >= ${r.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${r.outWidth}; yC++) {
                int xC = wC + yC * ${c} - ${C};

                if (xC < 0 || xC >= ${r.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Zl{constructor(r){this.variableNames=["dy","W"],this.outputShape=r.inShape;const o=r.filterDepth,l=r.filterHeight,c=r.filterWidth,f=r.strideDepth,g=r.strideHeight,C=r.strideWidth,v=o-1-r.padInfo.front,D=l-1-r.padInfo.top,F=c-1-r.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${v}, ${D}, ${F});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${o}; wF++) {
          float dyF = float(dyFCorner + wF) / ${f}.0;

          if (dyF < 0.0 || dyF >= ${r.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${o} - 1 - wF;

          for (int wR = 0; wR < ${l}; wR++) {
            float dyR = float(dyRCorner + wR) / ${g}.0;

            if (dyR < 0.0 || dyR >= ${r.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${l} - 1 - wR;

            for (int wC = 0; wC < ${c}; wC++) {
              float dyC = float(dyCCorner + wC) / ${C}.0;

              if (dyC < 0.0 || dyC >= ${r.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${c} - 1 - wC;

              for (int d2 = 0; d2 < ${r.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jl(i){const{inputs:r,backend:o,attrs:l}=i,{x:c,dy:f}=r,{strides:g,pad:C,dataFormat:v,dimRoundingMode:D,filterShape:F}=l,H=p.Wap.convertConv2DDataFormat(v),Y=p.Wap.computeConv2DInfo(c.shape,F,g,1,C,D,!1,H),te=new Di(Y);return o.runWebGLProgram(te,[c,f],"float32")}const ec={kernelName:p.wUP,backendName:"webgl",kernelFunc:Jl};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tc{constructor(r){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=r.inShape,this.enableShapeUniforms=Jn(this.outputShape.length);const o=r.filterHeight,l=r.filterWidth,c=o-1-r.padInfo.top,f=l-1-r.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${c}, ${f});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${o}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${r.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${o} - 1 - wR;

          for (int wC = 0; wC < ${l}; wC++) {
            int wCPerm = ${l} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${r.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${r.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${r.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${r.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${r.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nc(i){const{inputs:r,backend:o,attrs:l}=i,{dy:c,filter:f}=r,{inputShape:g,strides:C,pad:v,dataFormat:D,dimRoundingMode:F}=l,H=p.Wap.convertConv2DDataFormat(D),Y=p.Wap.computeConv2DInfo(g,f.shape,C,1,v,F,!1,H);if((0,p.OBj)().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&H==="channelsLast"){const te=[[Y.strideHeight,Y.strideWidth]],ae=new tc(Y);return o.runWebGLProgram(ae,[c,f],"float32",te)}else{const te=new ql(Y);return o.runWebGLProgram(te,[c,f],"float32")}}const sc={kernelName:p.wm,backendName:"webgl",kernelFunc:nc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hu(i){const{inputs:r,backend:o,attrs:l}=i,{x:c,filter:f}=r,{strides:g,pad:C,dilations:v}=l,D=p.Wap.computeConv3DInfo(c.shape,f.shape,g,v,C),F=new Kl(D);return o.runWebGLProgram(F,[c,f],"float32")}const rc={kernelName:p.x12,backendName:"webgl",kernelFunc:hu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oc(i){const{inputs:r,backend:o,attrs:l}=i,{x:c,dy:f}=r,{strides:g,pad:C,filterShape:v}=l,D=p.Wap.computeConv3DInfo(c.shape,v,g,1,C),F=new Ql(D);return o.runWebGLProgram(F,[c,f],"float32")}const Sa={kernelName:p.o2y,backendName:"webgl",kernelFunc:oc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ni(i){const{inputs:r,backend:o,attrs:l}=i,{dy:c,filter:f}=r,{pad:g,strides:C,inputShape:v}=l,D=p.Wap.computeConv3DInfo(v,f.shape,C,1,g),F=new Zl(D);return o.runWebGLProgram(F,[c,f],"float32")}const ac={kernelName:p.ik2,backendName:"webgl",kernelFunc:ni};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ha=ra+`
  return cos(x);
`,ic=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Vs}
  return result;
`,pu=Bn({opSnippet:ha,packedOpSnippet:ic}),uc={kernelName:p.mc4,backendName:"webgl",kernelFunc:pu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lc=Bn({opSnippet:`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`}),cc={kernelName:p.TR1,backendName:"webgl",kernelFunc:lc};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dc{constructor(r,o,l,c,f){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[g,C,v,D]=r,[F]=o,[H,Y]=l;this.outputShape=[F,H,Y,D];const te=c==="bilinear"?1:0,[ae,Ce]=[`${C-1}.0`,`${v-1}.0`],[Le,be,Ge]=H>1?[`${(C-1)/(H-1)}`,"(y2-y1) * height_ratio",`y1*${ae} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${ae}`],[Et,vt,jt]=Y>1?[`${(v-1)/(Y-1)}`,"(x2-x1) * width_ratio",`x1*${Ce} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${Ce}`];this.userCode=`
      const float height_ratio = float(${Le});
      const float width_ratio = float(${Et});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${g}) {
          return;
        }

        float height_scale = ${be};
        float width_scale = ${vt};

        float in_y = ${Ge};
        if( in_y < 0.0 || in_y > ${ae} ) {
          setOutput(float(${f}));
          return;
        }
        float in_x = ${jt};
        if( in_x < 0.0 || in_x > ${Ce} ) {
          setOutput(float(${f}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${te} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const si=i=>{const{inputs:r,backend:o,attrs:l}=i,{image:c,boxes:f,boxInd:g}=r,{cropSize:C,method:v,extrapolationValue:D}=l,F=new dc(c.shape,f.shape,C,v,D);return o.runWebGLProgram(F,[c,f,g],"float32")},hc={kernelName:p.VcC,backendName:"webgl",kernelFunc:si};var Ua;(function(i){i.Prod="*",i.Sum="+"})(Ua||(Ua={}));class _i{constructor(r,o,l,c){this.op=r,this.outputShape=o,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const f=this.outputShape.length,g=this.op===Ua.Prod?"1.0":"0.0",C=l?g:`getX(${fu(f,"coords",this.op)})`,v=this.outputShape[this.outputShape.length-1];let D="",F="";l?(D=c?`end != ${v-1}`:"end != 0",F=c?"end + 1":"end - 1"):(D=c?`end + pow2 < ${v}`:"end >= pow2",F=c?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${An(f)} coords = getOutputCoords();
        int end = ${mu(f,"coords",this.op)};
        float val = ${C};
        int pow2 = int(pow(2.0, index));
        if (${D}) {
          int idx = ${F};
          ${mu(f,"coords",this.op)} = idx;
          val ${this.op}= getX(${fu(f,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function fu(i,r,o){if(i===1)return`${r}`;if(i===2)return`${r}.x, ${r}.y`;if(i===3)return`${r}.x, ${r}.y, ${r}.z`;if(i===4)return`${r}.x, ${r}.y, ${r}.z, ${r}.w`;throw new Error(`Cumulative ${o} for rank ${i} is not yet supported`)}function mu(i,r,o){if(i===1)return`${r}`;if(i===2)return`${r}.y`;if(i===3)return`${r}.z`;if(i===4)return`${r}.w`;throw new Error(`Cumulative ${o} for rank ${i} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gu(i,r,o,l,c,f){const g=r.shape.length,C=p.Wap.getAxesPermutation([l],g);let v=r;C!=null&&(v=dr({inputs:{x:r},backend:o,attrs:{perm:C}}));const D=p.Wap.getInnerMostAxes(1,g)[0];if(D!==g-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${r.shape.length-1} but got axis=${l}`);const F=v.shape[D];let H=rs({inputs:{x:v},backend:o});for(let Y=0;Y<=Math.ceil(Math.log2(F))-1;Y++){const te=new _i(i,v.shape,!1,f),ae=[[Y]],Ce=H;H=o.runWebGLProgram(te,[H],H.dtype,ae),o.disposeIntermediateTensorInfo(Ce)}if(c){const Y=new _i(i,v.shape,c,f),te=H;H=o.runWebGLProgram(Y,[H],H.dtype),o.disposeIntermediateTensorInfo(te)}if(C!=null){const Y=p.Wap.getUndoAxesPermutation(C),te=dr({inputs:{x:H},backend:o,attrs:{perm:Y}});return o.disposeIntermediateTensorInfo(H),o.disposeIntermediateTensorInfo(v),te}return H}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pc(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{axis:f,exclusive:g,reverse:C}=l;return gu(Ua.Prod,c,o,f,g,C)}const fc={kernelName:p.Byc,backendName:"webgl",kernelFunc:pc};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mc(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{axis:f,exclusive:g,reverse:C}=l;return gu(Ua.Sum,c,o,f,g,C)}const gc={kernelName:p.iHb,backendName:"webgl",kernelFunc:mc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yc(i){const{inputs:r,backend:o,attrs:l}=i,{x:c,weights:f}=r,{size:g,binaryOutput:C}=l;if(c.shape.length===1){const v=o.readSync(c.dataId),D=o.readSync(f.dataId),F=Xr(v,D,f.dtype,f.shape,g);return o.makeTensorInfo([g],f.dtype,F)}else if(c.shape.length===2){const v=o.bufferSync(c),D=o.bufferSync(f),F=Io(v,D,g,C);return o.makeTensorInfo(F.shape,f.dtype,F.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${c.shape.length}.`)}const xc={kernelName:p.QRR,backendName:"webgl",kernelFunc:yc};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bc{constructor(r,o,l){this.variableNames=["x"],this.outputShape=[],this.outputShape=r,this.blockSize=o,this.dataFormat=l,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${o};
      int offset_h = imod(h, ${o});
      int in_w = w / ${o};
      int offset_w = imod(w, ${o});
      int offset_d = (offset_h * ${o} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wc(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{blockSize:f,dataFormat:g}=l,C=c.shape[0],v=g==="NHWC"?c.shape[1]:c.shape[2],D=g==="NHWC"?c.shape[2]:c.shape[3],F=g==="NHWC"?c.shape[3]:c.shape[1],H=v*f,Y=D*f,te=F/(f*f),ae=g==="NHWC"?[C,H,Y,te]:[C,te,H,Y],Ce=new bc(ae,f,g);return o.runWebGLProgram(Ce,[c],c.dtype)}const vc={kernelName:p.T0n,backendName:"webgl",kernelFunc:wc};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yu{constructor(r,o=!1,l=null,c=!1,f=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=r.outShape,this.enableShapeUniforms=Jn(this.outputShape.length);const g=r.filterHeight,C=r.filterWidth,v=r.outChannels/r.inChannels;let D="",F="";l&&(c?D=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${l}
        }`:f?D=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${l}
        }`:D=`
          float activation(float x) {
            ${l}
          }
        `,F="result = activation(result);");const H=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),f&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${D}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${v};
        int q = d2 - d1 * ${v};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${g}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${C}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${H}
        ${F}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ai{constructor(r,o=!1,l=null,c=!1,f=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=r.outShape,this.enableShapeUniforms=Jn(this.outputShape.length);const g=r.outChannels/r.inChannels,C=r.padInfo.left,v=r.strideWidth,D=r.dilationWidth,F=r.filterHeight,H=r.filterWidth,Y=H;let te=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let be=0;be<H;be++)te+=`
          vec4 xTexelC${be*2};
          int xTexelC${be*2}Ready;
          vec4 xTexelC${be*2+1};
          int xTexelC${be*2+1}Ready;
          vec4 xC${be};`;te+=`
    for (int r = 0; r < ${F}; r++) {
      `;for(let be=0;be<H;be++)te+=`
          xTexelC${be*2} = vec4(0.0);
          xTexelC${be*2}Ready = 0;
          xTexelC${be*2+1} = vec4(0.0);
          xTexelC${be*2+1}Ready = 0;
          xC${be} = vec4(0.0);`;te+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let be=0;be<(Y+1)/2;be++){const Ge=be*2;if(te+=`
          xC = xCCorner + ${Ge*D};
          `,v===1){if(Ge<H&&(C%2===1?(te+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Ge}Ready == 0) {
                  xTexelC${Ge} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${Ge}.zw = vec2(0.0);
                  }
                  xTexelC${Ge}Ready = 1;
                }
              `,D===1&&Ge>0?te+=`
                xC${Ge} = vec4(xTexelC${Ge-2}.zw, xTexelC${Ge}.xy);
                `:te+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${Ge} = vec4(previous.zw, xTexelC${Ge}.xy);
                  } else {
                    xC${Ge} = vec4(0.0, 0.0, xTexelC${Ge}.xy);
                  }
                  `):te+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${Ge}Ready == 0) {
                  xTexelC${Ge} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${Ge}.zw = vec2(0.0);
                  }
                  xTexelC${Ge}Ready = 1;
                }

                xC${Ge} = xTexelC${Ge};
                `,Ge+1<H)){const Et=C%2===0?p.D5U.nearestLargerEven(D):D;D%2===0&&C%2===1||D%2!==0&&C%2!==1?(te+=`
                  xCOffset = xC + imod(pads[1], 2) + ${Et};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Ge+1}Ready == 0) {
                    xTexelC${Ge+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${Ge+1}.zw = vec2(0.0);
                    }
                    xTexelC${Ge+1}Ready = 1;
                  }
                  `,D>1?te+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${Ge+1} = vec4(previous.zw, xTexelC${Ge+1}.xy);
                    } else {
                     xC${Ge+1} = vec4(0.0, 0.0, xTexelC${Ge+1}.xy);
                    }
                    `:te+=`
                    xC${Ge+1} = vec4(xTexelC${Ge}.zw, xTexelC${Ge+1}.xy);
                    `):Et===1?te+=`
                    xC${Ge+1} = xTexelC${Ge};
                    `:te+=`
                    xCOffset = xC + ${Et};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Ge+1}Ready == 0) {
                      xTexelC${Ge+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${Ge+1}.zw = vec2(0.0);
                      }
                      xTexelC${Ge+1}Ready = 1;
                    }

                    xC${Ge+1} = xTexelC${Ge+1};
                    `}}else Ge<H&&(C%2===1?(te+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Ge}Ready == 0) {
                  xTexelC${Ge} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${Ge}.zw = vec2(0.0);
                  }
                  xTexelC${Ge}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${Ge+1}Ready == 0) {
                  xTexelC${Ge+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${Ge+1}.zw = vec2(0.0);
                  }
                  xTexelC${Ge+1}Ready = 1;
                }

                xC${Ge} = vec4(xTexelC${Ge}.zw, xTexelC${Ge+1}.zw);
              `,Ge+1<H&&(te+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${Ge+1} = vec4(xTexelC${Ge+1}.xy, final.xy);
                `)):(te+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${Ge}Ready == 0) {
                  xTexelC${Ge} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${Ge}.zw = vec2(0.0);
                  }
                  xTexelC${Ge}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Ge+1}Ready == 0) {
                  xTexelC${Ge+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${Ge+1}.zw = vec2(0.);
                  }
                  xTexelC${Ge+1}Ready = 1;
                }

                xC${Ge} = vec4(
                  xTexelC${Ge}.xy, xTexelC${Ge+1}.xy);
              `,Ge+1<H&&(te+=`
                  xC${Ge+1} = vec4(xTexelC${Ge}.zw, xTexelC${Ge+1}.zw);
                `)));Ge<H&&(te+=`
            wTexel = getW(r, ${Ge}, d1, q);
            dotProd += xC${Ge} * vec4(wTexel.xz, wTexel.xz);
          `,Ge+1<H&&(te+=`
              wTexel = getW(r, ${Ge+1}, d1, q);
              dotProd += xC${Ge+1} * vec4(wTexel.xz, wTexel.xz);
            `))}te+=`
    }
  `,te+=`
      }
    `;let ae="",Ce="";l&&(c?ae=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${l}
        }`:f?ae=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${l}
        }`:ae=`vec4 activation(vec4 x) {
          ${l}
        }`,Ce="result = activation(result);");const Le=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),f&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${ae}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${g};
        int q = d2 - d1 * ${g};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${te}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${Le}
        ${Ce}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cc(i){const{inputs:r,backend:o,attrs:l}=i,{x:c,filter:f}=r,{strides:g,pad:C,dilations:v,dimRoundingMode:D}=l;let F=v;F==null&&(F=[1,1]),p.D5U.assert(p.Wap.eitherStridesOrDilationsAreOne(g,F),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${g} and dilations '${F}'`);const H=p.Wap.computeConv2DInfo(c.shape,f.shape,g,F,C,D,!0);let Y;(0,p.OBj)().getBool("WEBGL_PACK_DEPTHWISECONV")&&H.strideWidth<=2&&H.outChannels/H.inChannels===1?Y=new Ai(H):Y=new yu(H);const te=[[H.padInfo.top,H.padInfo.left],[H.strideHeight,H.strideWidth],[H.dilationHeight,H.dilationWidth],[H.inHeight,H.inWidth]];return o.runWebGLProgram(Y,[c,f],"float32",te)}const xr={kernelName:p.cie,backendName:"webgl",kernelFunc:Cc};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sc{constructor(r){this.variableNames=["x","dy"],this.outputShape=r.filterShape;const o=r.strideHeight,l=r.strideWidth,c=r.padInfo.top,f=r.padInfo.left,g=r.outChannels/r.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${g} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${r.batchSize}; b++) {
          for (int yR = 0; yR < ${r.outHeight}; yR++) {
            int xR = wR + yR * ${o} - ${c};

            if (xR < 0 || xR >= ${r.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${r.outWidth}; yC++) {
              int xC = wC + yC * ${l} - ${f};

              if (xC < 0 || xC >= ${r.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Uo{constructor(r){this.variableNames=["dy","W"],this.outputShape=r.inShape;const o=r.filterHeight,l=r.filterWidth,c=r.strideHeight,f=r.strideWidth,g=o-1-r.padInfo.top,C=l-1-r.padInfo.left,v=r.outChannels/r.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${g}, ${C});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${o}; wR++) {
          float dyR = float(dyRCorner + wR) / ${c}.0;

          if (dyR < 0.0 || dyR >= ${r.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${o} - 1 - wR;

          for (int wC = 0; wC < ${l}; wC++) {
            float dyC = float(dyCCorner + wC) / ${f}.0;

            if (dyC < 0.0 || dyC >= ${r.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${l} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${v}; dm++) {
              int d2 = d1 * ${v} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ic(i){const{inputs:r,backend:o,attrs:l}=i,{x:c,dy:f}=r,{strides:g,dilations:C,pad:v,dimRoundingMode:D,filterShape:F}=l,H=p.Wap.computeConv2DInfo(c.shape,F,g,C,v,D,!0),Y=new Sc(H);return o.runWebGLProgram(Y,[c,f],"float32")}const Ec={kernelName:p.sL$,backendName:"webgl",kernelFunc:Ic};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tc(i){const{inputs:r,backend:o,attrs:l}=i,{dy:c,filter:f}=r,{strides:g,dilations:C,pad:v,dimRoundingMode:D,inputShape:F}=l,H=p.Wap.computeConv2DInfo(F,f.shape,g,C,v,D,!0),Y=new Uo(H);return o.runWebGLProgram(Y,[c,f],"float32")}const $c={kernelName:p.y7R,backendName:"webgl",kernelFunc:Tc};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nc{constructor(r){this.variableNames=["X"],this.outputShape=[r,r],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kc(i){const{inputs:r,backend:o}=i,{x:l}=r,c=[...l.shape,...l.shape],f=p.D5U.sizeFromShape(l.shape),g=Ht({inputs:{x:l},backend:o,attrs:{shape:[f]}}),C=new Nc(f),v=o.runWebGLProgram(C,[g],g.dtype),D=Ht({inputs:{x:v},backend:o,attrs:{shape:c}});return o.disposeIntermediateTensorInfo(g),o.disposeIntermediateTensorInfo(v),D}const Rc={kernelName:p.$w,backendName:"webgl",kernelFunc:kc};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dc{constructor(r){this.variableNames=["x","W"],this.outputShape=r.outShape;const{inHeight:o,inWidth:l,padInfo:c,strideHeight:f,strideWidth:g,filterHeight:C,filterWidth:v,dilationHeight:D,dilationWidth:F}=r,{top:H,left:Y}=c;this.userCode=`
      const ivec2 strides = ivec2(${f}, ${g});
      const ivec2 pads = ivec2(${H}, ${Y});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${C}; h++) {
          int hIn = hBeg + h * ${D};

          if (hIn >= 0 && hIn < ${o}) {
            for (int w = 0; w < ${v}; w++) {
              int wIn = wBeg + w * ${F};

              if (wIn >= 0 && wIn < ${l}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ma(i){const{inputs:r,backend:o,attrs:l}=i,{x:c,filter:f}=r,{strides:g,pad:C,dilations:v}=l,D=p.Wap.computeDilation2DInfo(c.shape,f.shape,g,C,"NHWC",v);let F;const H=new Dc(D);F=o.runWebGLProgram(H,[c,f],"float32");const Y=Ht({inputs:{x:F},backend:o,attrs:{shape:D.outShape}});return o.disposeIntermediateTensorInfo(F),Y}const xu={kernelName:p.p4S,backendName:"webgl",kernelFunc:Ma};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bu(i){const{inputs:r,backend:o,attrs:l}=i,{equation:c}=l,f=r,{allDims:g,summedDims:C,idDims:v}=p.Wap.decodeEinsumEquation(c,f.length);p.Wap.checkEinsumDimSizes(g.length,v,f);const{path:D,steps:F}=p.Wap.getEinsumComputePath(C,v),H=F.length;let Y=null,te=g.length;const ae=[];for(let Ce=0;Ce<H;++Ce){for(const Le of F[Ce]){const{permutationIndices:be,expandDims:Ge}=p.Wap.getEinsumPermutation(te,v[Le]);let Et;p.Wap.isIdentityPermutation(be)?Et=f[Le]:(Et=dr({inputs:{x:f[Le]},backend:o,attrs:{perm:be}}),ae.push(Et));const vt=Et.shape.slice();for(let jt=0;jt<Ge.length;++jt)vt.splice(Ge[jt],0,1);p.D5U.arraysEqual(Et.shape,vt)||(Et=Ht({inputs:{x:Et},backend:o,attrs:{shape:vt}}),ae.push(Et)),Y===null?Y=Et:(Y=mi({inputs:{a:Et,b:Y},backend:o}),ae.push(Y))}Ce<H-1&&(D[Ce]>=0&&(Y=ia({inputs:{x:Y},backend:o,attrs:{axis:D[Ce]-(g.length-te),keepDims:!1}}),ae.push(Y)),te--)}for(const Ce of ae)Ce!==Y&&o.disposeIntermediateTensorInfo(Ce);return Y}const wu={kernelName:p.$g6,backendName:"webgl",kernelFunc:bu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ac=Bn({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`}),Pc={kernelName:p.SX0,backendName:"webgl",kernelFunc:Ac};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oc="return (b >= 0.0) ? a : a * (b + 1.0);",Fc=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Bc=i=>{const{inputs:r,backend:o}=i,{dy:l,y:c}=r,f=(0,p.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ts(Fc,l.shape,c.shape):new es(Oc,l.shape,c.shape);return o.runWebGLProgram(f,[l,c],l.dtype)},Lc={kernelName:p.HEU,backendName:"webgl",kernelFunc:Bc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uc=sr({opSnippet:"return float(a == b);",packedOpSnippet:`
  return vec4(equal(a, b));
`,dtype:"bool",cpuKernelImpl:Fo}),vu={kernelName:p.hdR,backendName:"webgl",kernelFunc:Uc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cu=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${p.Wap.ERF_P};
  float a1 = ${p.Wap.ERF_A1};
  float a2 = ${p.Wap.ERF_A2};
  float a3 = ${p.Wap.ERF_A3};
  float a4 = ${p.Wap.ERF_A4};
  float a5 = ${p.Wap.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Mc=Bn({opSnippet:Cu}),Wc={kernelName:p.Omj,backendName:"webgl",kernelFunc:Mc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vc=ra+`
  return exp(x);
`,Su=Bn({opSnippet:Vc,packedOpSnippet:`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cpuKernelImpl:lr,dtype:"float32"}),zc={kernelName:p.NEP,backendName:"webgl",kernelFunc:Su};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pi(i){const{inputs:r,attrs:o,backend:l}=i,{dim:c}=o,{input:f}=r,g=f.shape.length,C=f.shape.slice();let v=c;return c<0&&(p.D5U.assert(-(g+1)<=c,()=>`Axis must be in the interval [${-(g+1)}, ${g}]`),v=g+c+1),C.splice(v,0,1),Ht({inputs:{x:f},backend:l,attrs:{shape:C}})}const Gc={kernelName:p.YFo,backendName:"webgl",kernelFunc:Pi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iu="return exp(x) - 1.0;",Hc=Bn({opSnippet:Iu,packedOpSnippet:Iu,cpuKernelImpl:Go}),jc={kernelName:p.Y0y,backendName:"webgl",kernelFunc:Hc};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Eu{constructor(r,o,l){this.variableNames=["real","imag"];const c=o[1];this.outputShape=o;const f=l?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,g=l?`${c}.0`:"1.0";let C;if(r==="real")C="return real * expR - imag * expI;";else if(r==="imag")C="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${r}.`);this.userCode=`
      const float exponentMultiplier = ${f};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${C}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${c});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${c}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${g};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tu(i,r,o){const l=o.texData.get(i.dataId),c=p.D5U.sizeFromShape(i.shape),f=i.shape[i.shape.length-1],g=c/f,C=Ht({inputs:{x:i},backend:o,attrs:{shape:[g,f]}}),v=C.shape,D=new Eu("real",v,r),F=new Eu("imag",v,r),H=[{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:v},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:v}],Y=o.runWebGLProgram(D,H,"float32"),te=o.runWebGLProgram(F,H,"float32"),ae=po({inputs:{real:Y,imag:te},backend:o});o.disposeIntermediateTensorInfo(Y),o.disposeIntermediateTensorInfo(te);const Ce=Ht({inputs:{x:ae},backend:o,attrs:{shape:i.shape}});return o.disposeIntermediateTensorInfo(C),o.disposeIntermediateTensorInfo(ae),Ce}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kc(i){const{inputs:r,backend:o}=i,{input:l}=r;return Tu(l,!1,o)}const Xc={kernelName:p.vwp,backendName:"webgl",kernelFunc:Kc};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yc{constructor(r,o){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=r,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I(i){const{backend:r,attrs:o}=i,{shape:l,value:c}=o;let{dtype:f}=o;if(f=f||p.D5U.inferDtype(c),f==="string"){const g=p.D5U.getArrayFromDType(f,p.D5U.sizeFromShape(l));return g.fill(c),r.makeTensorInfo(l,f,g)}else{const g=new Yc(l,c),C=[[c]];return r.runWebGLProgram(g,[],f,C)}}const w={kernelName:p.deh,backendName:"webgl",kernelFunc:I};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class x{constructor(r){this.variableNames=["Image"],this.outputShape=[];const o=r[2];this.outputShape=r,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${o} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${o}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $={kernelName:p.Uyb,backendName:"webgl",kernelFunc:({inputs:i,backend:r})=>{const{image:o}=i,l=r,c=new x(o.shape);return l.runWebGLProgram(c,[o],o.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O="return floor(x);",M=Bn({opSnippet:O,packedOpSnippet:O,cpuKernelImpl:Ho}),j={kernelName:p.OR,backendName:"webgl",kernelFunc:M};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $e=sr({opSnippet:`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,packedOpSnippet:`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,dtype:"int32"}),qe={kernelName:p.jeX,backendName:"webgl",kernelFunc:$e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ze{constructor(r){this.variableNames=["A"];const o=Dn(),[l,c]=r;this.outputShape=r,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}.0, ${l}.0);

        vec4 values = ${o.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dt{constructor(r){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const o=Dn(),[l,c]=r;this.outputShape=r,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${c}.0, ${l}.0);
            vec4 values = ${o.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${o.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yt={kernelName:p.eBW,backendName:"webgl",kernelFunc:dn};let qt,In=(0,p.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function dn(i){const{inputs:r,backend:o,attrs:l}=i;let{pixels:c}=r;const{numChannels:f}=l,g=typeof HTMLVideoElement<"u"&&c instanceof HTMLVideoElement,C=typeof HTMLImageElement<"u"&&c instanceof HTMLImageElement,[v,D]=g?[c.videoWidth,c.videoHeight]:[c.width,c.height],F=[D,v],H=[D,v,f];if(C||g){const Ce=(0,p.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(qt==null||Ce!==In)&&(In=Ce,qt=document.createElement("canvas").getContext("2d",{willReadFrequently:In})),qt.canvas.width=v,qt.canvas.height=D,qt.drawImage(c,0,0,v,D),c=qt.canvas}const Y=o.makeTensorInfo(F,"int32");o.texData.get(Y.dataId).usage=xe.PIXELS,o.gpgpu.uploadPixelDataToTexture(o.getTexture(Y.dataId),c);const te=(0,p.OBj)().getBool("WEBGL_PACK")?new Dt(H):new Ze(H),ae=o.runWebGLProgram(te,[Y],"int32");return o.disposeData(Y.dataId),ae}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mn(i){const{inputs:r,backend:o,attrs:l}=i,{x:c,filter:f,bias:g,preluActivationWeights:C}=r,{strides:v,pad:D,dataFormat:F,dilations:H,dimRoundingMode:Y,activation:te,leakyreluAlpha:ae}=l,Ce=p.Wap.convertConv2DDataFormat(F),Le=p.Wap.computeConv2DInfo(c.shape,f.shape,v,H,D,Y,!1,Ce);let be;const Ge=[],Et=g!=null,vt=C!=null,jt=te==="leakyrelu",En=()=>{const rn=[c,f],Gn=(_n,_s)=>{if(_s==="NCHW"&&_n.shape.length===1&&_n.shape[0]!==1){const Ls=Ht({inputs:{x:_n},backend:o,attrs:{shape:[_n.shape[0],1,1]}});return Ge.push(Ls),Ls}return _n};if(Et&&rn.push(Gn(g,F)),vt&&rn.push(Gn(C,F)),jt){const _n=o.makeTensorInfo([],"float32",p.D5U.createScalarValue(ae,"float32"));rn.push(_n),Ge.push(_n)}return rn};if(Le.filterHeight===1&&Le.filterWidth===1&&Le.dilationHeight===1&&Le.dilationWidth===1&&Le.strideHeight===1&&Le.strideWidth===1&&(Le.padInfo.type==="SAME"||Le.padInfo.type==="VALID"))be=cu({x:c,filter:f,convInfo:Le,backend:o,bias:g,activation:te,preluActivationWeights:C,leakyreluAlpha:ae});else if(Le.strideWidth<=2&&Ce==="channelsLast"&&(0,p.OBj)().getBool("WEBGL_EXP_CONV")){const rn=te?Qa(te,!0):null,Gn=new lu(Le,Et,rn,vt,jt),_n=[[Le.padInfo.top,Le.padInfo.left],[Le.strideHeight,Le.strideWidth],[Le.dilationHeight,Le.dilationWidth],[Le.inHeight,Le.inWidth]],_s=En();be=o.runWebGLProgram(Gn,_s,"float32",_n)}else if((0,p.OBj)().getBool("WEBGL_CONV_IM2COL"))be=da({x:c,filter:f,convInfo:Le,backend:o,bias:g,activation:te,preluActivationWeights:C,leakyreluAlpha:ae});else{const rn=te?Qa(te,!1):null,Gn=new uu(Le,Et,rn,vt,jt),_n=En();be=o.runWebGLProgram(Gn,_n,"float32")}const gn=Ht({inputs:{x:be},backend:o,attrs:{shape:Le.outShape}});return Ge.push(be),Ge.forEach(rn=>o.disposeIntermediateTensorInfo(rn)),gn}const Ks={kernelName:p._V0,backendName:"webgl",kernelFunc:Mn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hs(i){const{inputs:r,backend:o,attrs:l}=i,{x:c,filter:f,bias:g,preluActivationWeights:C}=r,{strides:v,pad:D,dilations:F,dimRoundingMode:H,activation:Y,leakyreluAlpha:te}=l,ae=[];let Ce=F;Ce==null&&(Ce=[1,1]),p.D5U.assert(p.Wap.eitherStridesOrDilationsAreOne(v,Ce),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${v} and dilations '${Ce}'`);const Le=p.Wap.computeConv2DInfo(c.shape,f.shape,v,Ce,D,H,!0),be=(0,p.OBj)().getBool("WEBGL_PACK_DEPTHWISECONV")&&Le.strideWidth<=2&&Le.outChannels/Le.inChannels===1,Ge=Y?Qa(Y,be):null,Et=[c,f],vt=g!=null,jt=C!=null,En=Y==="leakyrelu";if(vt&&Et.push(g),jt&&Et.push(C),En){const _n=o.makeTensorInfo([],"float32",p.D5U.createScalarValue(te,"float32"));Et.push(_n),ae.push(_n)}let gn;be?gn=new Ai(Le,vt,Ge,jt,En):gn=new yu(Le,vt,Ge,jt,En);const rn=[[Le.padInfo.top,Le.padInfo.left],[Le.strideHeight,Le.strideWidth],[Le.dilationHeight,Le.dilationWidth],[Le.inHeight,Le.inWidth]],Gn=o.runWebGLProgram(gn,Et,"float32",rn);return ae.forEach(_n=>o.disposeIntermediateTensorInfo(_n)),Gn}const $s={kernelName:p.luS,backendName:"webgl",kernelFunc:Hs};class Bs{constructor(r,o,l,c){this.sliceDim=r,this.strides=o,this.paramsShape=c,this.variableNames=["x","indices"],this.outputShape=l;const f=An(l.length);let g=`
    int index;`;for(let C=0;C<this.sliceDim;C++)g+=`
          index = round(getIndices(coords[0], ${C}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[C]};
          flattenIndex += index * ${this.strides[C]};`;this.userCode=`
         void main() {
          ${f} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${g}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ln(i){const{inputs:r,backend:o}=i,{params:l,indices:c}=r,f=c.shape,g=f[f.length-1],C=p.D5U.sizeFromShape(l.shape),[v,D,F,H]=p.Wap.prepareAndValidate(l,c),Y=Ht({inputs:{x:c},backend:o,attrs:{shape:[D,g]}}),te=Ht({inputs:{x:l},backend:o,attrs:{shape:[p.D5U.sizeFromShape(l.shape)/F,F]}});if(o.shouldExecuteOnCPU([l,c])||l.dtype==="string"){const be=o.readSync(c.dataId),Ge=o.bufferSync(l),Et=Rs(be,Ge,l.dtype,D,g,F,H,l.shape,C);return o.makeTensorInfo(v,l.dtype,Et.values)}const ae=new Bs(g,H,[D,F],l.shape),Ce=o.runWebGLProgram(ae,[te,Y],te.dtype),Le=Ht({inputs:{x:Ce},backend:o,attrs:{shape:v}});return o.disposeIntermediateTensorInfo(Y),o.disposeIntermediateTensorInfo(te),o.disposeIntermediateTensorInfo(Ce),Le}const ys={kernelName:p.q1x,backendName:"webgl",kernelFunc:Ln};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xs{constructor(r,o){this.variableNames=["A","indices"],this.outputShape=o,this.rank=o.length;const l=An(this.rank),c=ds(r,2);this.userCode=`
      void main() {
        ${l} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${r[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${c}));
      }
    `}}function ds(i,r){const o=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[];for(let c=0;c<i.length;c++)c===2?l.push("index"):l.push(`${o[c]}`);return l.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hs(i){const{inputs:r,backend:o,attrs:l}=i,{x:c,indices:f}=r,{axis:g,batchDims:C}=l,v=p.D5U.parseAxisParam(g,c.shape)[0];if((0,p.OBj)().get("DEBUG")){const Ge=o.readSync(f.dataId),Et=c.shape[v];for(let vt=0;vt<Ge.length;++vt){const jt=Ge[vt];p.D5U.assert(jt<=Et-1&&jt>=0,()=>`GatherV2: the index value ${jt} is not in [0, ${Et-1}]`)}}const D=p.Wap.segment_util.collectGatherOpShapeInfo(c,f,v,C),F=p.D5U.sizeFromShape(f.shape),H=[],Y=Ht({inputs:{x:c},backend:o,attrs:{shape:[D.batchSize,D.outerSize,D.dimSize,D.sliceSize]}}),te=Ht({inputs:{x:f},backend:o,attrs:{shape:[D.batchSize,F/D.batchSize]}});H.push(Y),H.push(te);const ae=[D.batchSize,D.outerSize,F/D.batchSize,D.sliceSize];if(o.shouldExecuteOnCPU([c,f])||c.dtype==="string"){const Ge=o.bufferSync(te),Et=o.bufferSync(Y),vt=Eo(Et,Ge,ae);return H.forEach(jt=>o.disposeIntermediateTensorInfo(jt)),o.makeTensorInfo(D.outputShape,vt.dtype,vt.values)}const Ce=new xs(Y.shape,ae),Le=o.runWebGLProgram(Ce,[Y,te],Y.dtype);H.push(Le);const be=Ht({inputs:{x:Le},backend:o,attrs:{shape:D.outputShape}});return H.forEach(Ge=>o.disposeIntermediateTensorInfo(Ge)),be}const bs={kernelName:p.qi_,backendName:"webgl",kernelFunc:hs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zr=sr({opSnippet:"return float(a > b);",packedOpSnippet:`
  return vec4(greaterThan(a, b));
`,cpuKernelImpl:$r,dtype:"bool"}),ko={kernelName:p.iZT,backendName:"webgl",kernelFunc:Zr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ia=sr({opSnippet:"return float(a >= b);",packedOpSnippet:`
  return vec4(greaterThanEqual(a, b));
`,dtype:"bool",cpuKernelImpl:Bo}),Ea={kernelName:p.Acj,backendName:"webgl",kernelFunc:Ia};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qc(i){const{inputs:r,backend:o}=i,{input:l}=r;return Tu(l,!0,o)}const Wd={kernelName:p.Qg5,backendName:"webgl",kernelFunc:qc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ri=Bn({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),Qc={kernelName:p.avt,backendName:"webgl",kernelFunc:ri};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vd=Bn({opSnippet:"return float(isinf(x));",dtype:"bool"}),zd={kernelName:p.iWB,backendName:"webgl",kernelFunc:Vd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gd=Bn({opSnippet:"return float(isnan(x));",dtype:"bool"}),Hd={kernelName:p.r7n,backendName:"webgl",kernelFunc:Gd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jd=sr({opSnippet:"return float(a < b);",packedOpSnippet:`
  return vec4(lessThan(a, b));
`,cpuKernelImpl:ho,dtype:"bool"}),Kd={kernelName:p.vtC,backendName:"webgl",kernelFunc:jd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dd=sr({opSnippet:"return float(a <= b);",packedOpSnippet:`
  return vec4(lessThanEqual(a, b));
`,cpuKernelImpl:Ha,dtype:"bool"}),Xd={kernelName:p.CAk,backendName:"webgl",kernelFunc:dd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yd(i){const{backend:r,attrs:o}=i,{start:l,stop:c,num:f}=o,g=Ut(l,c,f);return r.makeTensorInfo([g.length],"float32",g)}const qd={kernelName:p.e7N,backendName:"webgl",kernelFunc:Yd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qd=ra+`
  return x < 0.0 ? 0./0. : log(x);
`,Zd=Bn({opSnippet:Qd,packedOpSnippet:`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,cpuKernelImpl:ta}),Jd={kernelName:p.ZbH,backendName:"webgl",kernelFunc:Zd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eh=ra+`
  return log(1.0 + x);
`,th=Bn({opSnippet:eh}),nh={kernelName:p.kU,backendName:"webgl",kernelFunc:th};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sh=sr({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,dtype:"bool"}),rh={kernelName:p.PYm,backendName:"webgl",kernelFunc:sh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oh=Bn({opSnippet:"return float(!(x >= 1.0));"}),ah={kernelName:p.VfG,backendName:"webgl",kernelFunc:oh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ih=sr({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,dtype:"bool"}),uh={kernelName:p.MZg,backendName:"webgl",kernelFunc:ih};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lh{constructor(r,o,l,c,f){this.variableNames=["x"],this.outputShape=[];const g=o,C=r[3]-1;this.outputShape=r;let v;const D=`float(${l}) + float(${c}) * sum`;f===.5?v=`inversesqrt(${D})`:f===1?v=`1.0/(${D})`:v=`exp(log(${D}) * float(-${f}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${g}; j <= ${g}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${C}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${v};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ch{constructor(r,o,l,c,f){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const g=o,C=r[3]-1;this.outputShape=r;let v;const D=`float(${l}) + float(${c}) * sum`;f===.5?v=`inversesqrt(${D})`:f===1?v=`1.0/(${D})`:v=`exp(log(${D}) * float(-${f}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${g};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${g}; j <= ${g}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${C}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${v};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dh=i=>{const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{depthRadius:f,bias:g,alpha:C,beta:v}=l,D=(0,p.OBj)().getBool("WEBGL_PACK_NORMALIZATION")?new ch(c.shape,f,g,C,v):new lh(c.shape,f,g,C,v);return o.runWebGLProgram(D,[c],c.dtype)},hh={kernelName:p.eZ0,backendName:"webgl",kernelFunc:dh};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ph{constructor(r,o,l,c,f){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=r,this.depth=r[3],this.depthRadius=o,this.bias=l,this.alpha=c,this.beta=f,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${o})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${o} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${c}) * norm + float(${l});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${c})
                * float(${f})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${f});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fh=i=>{const{inputs:r,backend:o,attrs:l}=i,{x:c,y:f,dy:g}=r,{depthRadius:C,bias:v,alpha:D,beta:F}=l,H=new ph(c.shape,C,v,D,F);return o.runWebGLProgram(H,[c,f,g],c.dtype)},mh={kernelName:p.Hhh,backendName:"webgl",kernelFunc:fh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gh(i,r,o,l){const c=p.D5U.sizeFromShape(r),g=p.D5U.sizeFromShape(i.shape)/c,C=Ht({inputs:{x:i},attrs:{shape:[g,c]},backend:l}),v=aa(C,i.dtype,"max",l),D=Ht({inputs:{x:v},attrs:{shape:o},backend:l});return l.disposeIntermediateTensorInfo(C),l.disposeIntermediateTensorInfo(v),D}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hd(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{reductionIndices:f,keepDims:g}=l,C=c.shape.length,v=p.D5U.parseAxisParam(f,c.shape);let D=v;const F=p.Wap.getAxesPermutation(D,C),H=F!=null,Y=o.shouldExecuteOnCPU([c]);let te=c;if(H){if(Y){const Et=o.texData.get(te.dataId).values,vt=new Array(C);for(let gn=0;gn<vt.length;gn++)vt[gn]=c.shape[F[gn]];const jt=Is(Et,c.shape,c.dtype,F,vt);te=o.makeTensorInfo(vt,c.dtype);const En=o.texData.get(te.dataId);En.values=jt}else te=Zt(c,F,o);D=p.Wap.getInnerMostAxes(D.length,C)}p.Wap.assertAxesAreInnerMostDims("max",D,C);const[ae,Ce]=p.Wap.computeOutAndReduceShapes(te.shape,D);let Le=ae;g&&(Le=p.Wap.expandShapeToKeepDim(ae,v));let be;if(Y){const Et=o.texData.get(te.dataId).values,vt=To(Et,p.D5U.sizeFromShape(Ce),Le,c.dtype);be=o.makeTensorInfo(Le,c.dtype);const jt=o.texData.get(be.dataId);jt.values=vt}else be=gh(te,Ce,Le,o);return H&&o.disposeIntermediateTensorInfo(te),be}const yh={kernelName:p.YoZ,backendName:"webgl",kernelFunc:hd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xh=$n+`
  return max(a, b);
`,pd=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Vs+`
  return result;
`,bh=sr({opSnippet:xh,packedOpSnippet:pd,cpuKernelImpl:ma}),wh={kernelName:p.BMI,backendName:"webgl",kernelFunc:bh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vh(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r;mn(c,"maxPool");const{filterSize:f,strides:g,pad:C,dimRoundingMode:v}=l,D=1;p.D5U.assert(p.Wap.eitherStridesOrDilationsAreOne(g,D),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${g} and dilations '${D}'`);const F=p.Wap.computePool2DInfo(c.shape,f,g,D,C,v);if(F.filterWidth===1&&F.filterHeight===1&&p.D5U.arraysEqual(F.inShape,F.outShape))return rs({inputs:{x:c},backend:o});const H=new Pa(F,"max",!1);return o.runWebGLProgram(H,[c],c.dtype)}const Ch={kernelName:p.mTV,backendName:"webgl",kernelFunc:vh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sh(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{filterSize:f,strides:g,pad:C,dataFormat:v,dimRoundingMode:D}=l,F=[1,1,1],H=p.Wap.computePool3DInfo(c.shape,f,g,F,C,D,v),Y=new la(H,"max",!1);return o.runWebGLProgram(Y,[c],c.dtype)}const Ih={kernelName:p.OAf,backendName:"webgl",kernelFunc:Sh};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Eh{constructor(r){this.variableNames=["dy","maxPos"],this.outputShape=r.inShape;const o=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,f=r.effectiveFilterHeight,g=r.effectiveFilterWidth,C=f-1-r.padInfo.top,v=g-1-r.padInfo.left,D=f*g-1;this.userCode=`
      const ivec2 pads = ivec2(${C}, ${v});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${f};
          wR += ${c}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${r.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${g}; wC++) {
            float dyC = float(dyCCorner + wC) / ${l}.0;

            if (dyC < 0.0 || dyC >= ${r.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${D} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${g} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class Th{constructor(r){this.variableNames=["dy","maxPos"],this.outputShape=r.inShape;const o=r.strideDepth,l=r.strideHeight,c=r.strideWidth,f=r.dilationDepth,g=r.dilationHeight,C=r.dilationWidth,v=r.effectiveFilterDepth,D=r.effectiveFilterHeight,F=r.effectiveFilterWidth,H=v-1-r.padInfo.front,Y=D-1-r.padInfo.top,te=F-1-r.padInfo.left,ae=v*D*F-1;this.userCode=`
      const ivec3 pads = ivec3(${H}, ${Y}, ${te});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${v};
           wD += ${f}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${r.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${D};
              wR += ${g}) {
            float dyR = float(dyRCorner + wR) / ${l}.0;

            if (dyR < 0.0 || dyR >= ${r.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${F};
                wC += ${C}) {
              float dyC = float(dyCCorner + wC) / ${c}.0;

              if (dyC < 0.0 || dyC >= ${r.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${ae} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${D} * ${F} +
                  wR * ${F} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $h(i){const{inputs:r,backend:o,attrs:l}=i,{dy:c,input:f}=r,g=f,{filterSize:C,strides:v,pad:D,dimRoundingMode:F}=l,H=[1,1,1],Y=p.Wap.computePool3DInfo(g.shape,C,v,H,D,F),te=new la(Y,"max",!0),ae=o.runWebGLProgram(te,[g],g.dtype),Ce=new Th(Y),Le=o.runWebGLProgram(Ce,[c,ae],g.dtype);return o.disposeIntermediateTensorInfo(ae),Le}const Nh={kernelName:p.OU7,backendName:"webgl",kernelFunc:$h};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kh(i){const{inputs:r,backend:o,attrs:l}=i,{dy:c,input:f,output:g}=r,C=f;mn([f,g],"maxPoolGrad");const{filterSize:v,strides:D,pad:F,dimRoundingMode:H}=l,Y=p.Wap.computePool2DInfo(C.shape,v,D,1,F,H),te=!0,ae=new Pa(Y,"max",te),Ce=o.runWebGLProgram(ae,[C],C.dtype),Le=new Eh(Y),be=o.runWebGLProgram(Le,[c,Ce],C.dtype);return o.disposeIntermediateTensorInfo(Ce),be}const Rh={kernelName:p.OV7,backendName:"webgl",kernelFunc:kh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dh(i,r,o,l){let c=new Pa(o,"max",!1);const f=l.runWebGLProgram(c,[i],"float32");c=new Pa(o,"max",!0,!0,r);const g=l.runWebGLProgram(c,[i],"float32");return[f,g]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _h={kernelName:p.vFR,backendName:"webgl",kernelFunc:({inputs:i,attrs:r,backend:o})=>{const{x:l}=i,{filterSize:c,strides:f,pad:g,includeBatchInIndex:C}=r,v=o;p.D5U.assert(l.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.shape.length}.`);const D=[1,1];p.D5U.assert(p.Wap.eitherStridesOrDilationsAreOne(f,D),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${f} and dilations '${D}'`);const F=p.Wap.computePool2DInfo(l.shape,c,f,D,g),[H,Y]=Dh(l,C,F,v);return[H,Y]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ah(i,r,o,l){const c=p.D5U.sizeFromShape(r),g=p.D5U.sizeFromShape(i.shape)/c,C=Ht({inputs:{x:i},attrs:{shape:[g,c]},backend:l}),v=aa(C,"float32","mean",l),D=Ht({inputs:{x:v},attrs:{shape:o},backend:l});return l.disposeIntermediateTensorInfo(C),l.disposeIntermediateTensorInfo(v),D}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ph={kernelName:p.q2K,backendName:"webgl",kernelFunc:({inputs:i,attrs:r,backend:o})=>{const{x:l}=i,{keepDims:c,axis:f}=r,g=o,C=l.shape.length,v=p.D5U.parseAxisParam(f,l.shape);let D=v;const F=p.Wap.getAxesPermutation(D,C),H=F!=null,Y=g.shouldExecuteOnCPU([l]),te=[];let ae=l;if(H){if(Y){const vt=g.texData.get(ae.dataId).values,jt=new Array(C);for(let rn=0;rn<jt.length;rn++)jt[rn]=l.shape[F[rn]];const En=Is(vt,l.shape,l.dtype,F,jt);ae=g.makeTensorInfo(jt,l.dtype);const gn=g.texData.get(ae.dataId);gn.values=En}else ae=Zt(l,F,g);te.push(ae),D=p.Wap.getInnerMostAxes(D.length,C)}p.Wap.assertAxesAreInnerMostDims("sum",D,C);const[Ce,Le]=p.Wap.computeOutAndReduceShapes(ae.shape,D);let be=Ce;c&&(be=p.Wap.expandShapeToKeepDim(Ce,v));const Ge=Ah(ae,Le,be,g);for(const Et of te)g.disposeIntermediateTensorInfo(Et);return Ge}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oh(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{axis:f,keepDims:g}=l,C=c.shape.length,v=p.D5U.parseAxisParam(f,c.shape);let D=v;const F=p.Wap.getAxesPermutation(D,C);let H=c;F!=null&&(H=dr({inputs:{x:c},backend:o,attrs:{perm:F}}),D=p.Wap.getInnerMostAxes(D.length,c.shape.length)),p.Wap.assertAxesAreInnerMostDims("min",D,C);const[Y,te]=p.Wap.computeOutAndReduceShapes(H.shape,D),ae=p.D5U.sizeFromShape(te),Ce=Ht({inputs:{x:H},backend:o,attrs:{shape:[-1,ae]}}),Le=aa(Ce,Ce.dtype,"min",o);let be;if(g){const Ge=p.Wap.expandShapeToKeepDim(Y,v);be=Ht({inputs:{x:Le},backend:o,attrs:{shape:Ge}})}else be=Ht({inputs:{x:Le},backend:o,attrs:{shape:Y}});return o.disposeIntermediateTensorInfo(Ce),o.disposeIntermediateTensorInfo(Le),F!=null&&o.disposeIntermediateTensorInfo(H),be}const Fh={kernelName:p.c17,backendName:"webgl",kernelFunc:Oh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bh=$n+`
  return min(a, b);
`,Lh=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Vs+`
  return result;
`,Uh=sr({opSnippet:Bh,packedOpSnippet:Lh,cpuKernelImpl:Gt}),Mh={kernelName:p.q8u,backendName:"webgl",kernelFunc:Uh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wh{constructor(r,o,l){this.variableNames=["x"],this.outputShape=o.map((F,H)=>F[0]+r[H]+F[1]);const c=r.length,f=An(c),g=o.map(F=>F[0]).join(","),C=o.map((F,H)=>F[0]+r[H]).join(","),v=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,c),D=l==="reflect"?0:1;if(c===1){this.userCode=`
        int start = ${g};
        int end = ${C};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${D};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${D};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${f} start = ${f}(${g});
      ${f} end = ${f}(${C});

      void main() {
        ${f} outC = getOutputCoords();
        for (int i = 0; i < ${c}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${D};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${D};
          }
        }
        ${f} coords = outC - start;
        setOutput(getX(${v}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vh{constructor(r,o,l){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o.map((ae,Ce)=>ae[0]+r[Ce]+ae[1]);const c=r.length,f=An(c),g=o.map(ae=>ae[0]).join(","),C=o.map((ae,Ce)=>ae[0]+r[Ce]).join(","),v=os("rc",c),D=os("source",c),F=`${v[c-1]} < ${this.outputShape[c-1]}`,H=c===1?"source":`vec2(${D.slice(-2).join()})`,Y=l==="reflect"?0:1;let te="";if(c===1){const ae=`
        ${f} source = rc;
        if (source < start) {
          source = start * 2 - source - ${Y};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${Y};
        }
        source -= start;
      `;te=`
        ${f} rc = outputLoc;
        ${ae}
        result[0] = getChannel(getX(${D.join()}), ${H});
        ${v[c-1]} += 1;
        if(${F}) {
          ${ae}
          result[1] = getChannel(getX(${D.join()}), ${H});
        }
      `}else{const ae=`
        ${f} source = rc;
        ${f} lt = ${f}(lessThan(source, start));
        ${f} gte = ${f}(greaterThanEqual(source, end));
        ${f} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${Y}) +
                gte * ((end - 1) * 2 - source + ${Y});
        source -= start;
      `;te=`
        ${f} rc = outputLoc;
        ${ae}
        result[0] = getChannel(getX(${D.join()}), ${H});
        ${v[c-1]} += 1;
        if(${F}) {
          ${ae}
          result[1] = getChannel(getX(${D.join()}), ${H});
        }
        rc = outputLoc;
        ${v[c-2]} += 1;
        if(${v[c-2]} < ${this.outputShape[c-2]}) {
          ${ae}
          result[2] = getChannel(getX(${D.join()}), ${H});
          ${v[c-1]} += 1;
          if(${F}) {
            ${ae}
            result[3] = getChannel(getX(${D.join()}), ${H});
          }
        }
      `}this.userCode=`
      const ${f} start = ${f}(${g});
      const ${f} end = ${f}(${C});

      void main() {
        ${f} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${te}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zh=({inputs:i,backend:r,attrs:o})=>{const{x:l}=i,{paddings:c,mode:f}=o,g=(0,p.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Vh(l.shape,c,f):new Wh(l.shape,c,f);return r.runWebGLProgram(g,[l],l.dtype)},Gh={kernelName:p.jQs,backendName:"webgl",kernelFunc:zh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hh=`if (b == 0.0) return NAN;
  return mod(a, b);`,jh=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Vs+`
  return result;
`,Kh=sr({opSnippet:Hh,packedOpSnippet:jh}),Xh={kernelName:p.Vbg,backendName:"webgl",kernelFunc:Kh};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yh{constructor(r,o,l){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[r,l],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${o-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${o-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fd=sr({opSnippet:`
if (a == b) {
  return 1.0;
};
return a / b;`,packedOpSnippet:`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,checkOutOfBounds:!0}),Qh={kernelName:p.oHH,backendName:"webgl",kernelFunc:fd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const md="return a - b;",gd=sr({opSnippet:md,packedOpSnippet:md,supportsComplex:!0,cpuKernelImpl:Yn}),Zh={kernelName:p.Tr8,backendName:"webgl",kernelFunc:gd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yd(i){const{inputs:r,backend:o,attrs:l}=i,{logits:c}=r,{dim:f}=l,g=p.D5U.parseAxisParam([f],c.shape),C=hd({inputs:{x:c},backend:o,attrs:{reductionIndices:g,keepDims:!1}}),v=p.Wap.expandShapeToKeepDim(C.shape,g),D=Ht({inputs:{x:C},backend:o,attrs:{shape:v}}),F=gd({inputs:{a:c,b:D},backend:o}),H=Su({inputs:{x:F},backend:o}),Y=ia({inputs:{x:H},backend:o,attrs:{axis:g,keepDims:!1}}),te=Ht({inputs:{x:Y},backend:o,attrs:{shape:v}}),ae=fd({inputs:{a:H,b:te},backend:o});return o.disposeIntermediateTensorInfo(C),o.disposeIntermediateTensorInfo(D),o.disposeIntermediateTensorInfo(F),o.disposeIntermediateTensorInfo(H),o.disposeIntermediateTensorInfo(Y),o.disposeIntermediateTensorInfo(te),ae}const Jh={kernelName:p.Gcp,backendName:"webgl",kernelFunc:yd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ep(i){const{inputs:r,backend:o,attrs:l}=i,{logits:c}=r,{numSamples:f,seed:g,normalized:C}=l,v=C?c:yd({inputs:{logits:c},backend:o,attrs:{dim:c.shape.length-1}}),D=v.shape[0],F=v.shape[1],H=new Yh(D,F,f),Y=[[g]],te=o.runWebGLProgram(H,[v],"int32",Y);return C||o.disposeIntermediateTensorInfo(v),te}const tp={kernelName:p.NZg,backendName:"webgl",kernelFunc:ep};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const np=yr+`
  return -x;
`,sp=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function $u(i){const{inputs:r,backend:o}=i,{x:l}=r;if(o.shouldExecuteOnCPU([l])){const f=o.texData.get(l.dataId),[g,C]=ga(f.values,l.shape,l.dtype);return o.makeTensorInfo(C,l.dtype,g)}let c;return(0,p.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?c=new E(l.shape,sp):c=new Yr(l.shape,np),o.runWebGLProgram(c,[l],l.dtype)}const rp={kernelName:p.kuV,backendName:"webgl",kernelFunc:$u};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xd=p.GDt.nonMaxSuppressionV3Impl;function op(i){p.Wap.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:r,backend:o,attrs:l}=i,{boxes:c,scores:f}=r,{maxOutputSize:g,iouThreshold:C,scoreThreshold:v}=l,D=o.readSync(c.dataId),F=o.readSync(f.dataId),{selectedIndices:H}=xd(D,F,g,C,v);return o.makeTensorInfo([H.length],"int32",new Int32Array(H))}const ap={kernelName:p.uv1,backendName:"webgl",kernelFunc:op};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ip=p.GDt.nonMaxSuppressionV4Impl;function bd(i){p.Wap.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:r,backend:o,attrs:l}=i,{boxes:c,scores:f}=r,{maxOutputSize:g,iouThreshold:C,scoreThreshold:v,padToMaxOutputSize:D}=l,F=o.readSync(c.dataId),H=o.readSync(f.dataId),{selectedIndices:Y,validOutputs:te}=ip(F,H,g,C,v,D);return[o.makeTensorInfo([Y.length],"int32",new Int32Array(Y)),o.makeTensorInfo([],"int32",new Int32Array([te]))]}const up={kernelName:p.cye,backendName:"webgl",kernelFunc:bd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lp=p.GDt.nonMaxSuppressionV5Impl;function cp(i){p.Wap.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:r,backend:o,attrs:l}=i,{boxes:c,scores:f}=r,{maxOutputSize:g,iouThreshold:C,scoreThreshold:v,softNmsSigma:D}=l,F=o.readSync(c.dataId),H=o.readSync(f.dataId),Y=g,te=C,ae=v,Ce=D,{selectedIndices:Le,selectedScores:be}=lp(F,H,Y,te,ae,Ce);return[o.makeTensorInfo([Le.length],"int32",new Int32Array(Le)),o.makeTensorInfo([be.length],"float32",new Float32Array(be))]}const dp={kernelName:p.W0H,backendName:"webgl",kernelFunc:cp};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hp{constructor(r,o,l,c){this.variableNames=["indices"],this.outputShape=[r,o],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${c}), float(${l}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pp=i=>{const{inputs:r,backend:o,attrs:l}=i,{indices:c}=r,{dtype:f,depth:g,onValue:C,offValue:v}=l,D=p.D5U.sizeFromShape(c.shape),F=new hp(D,g,C,v),H=Ht({inputs:{x:c},backend:o,attrs:{shape:[D]}}),Y=o.runWebGLProgram(F,[H],f);o.disposeIntermediateTensorInfo(H);const te=[...c.shape,g],ae=Ht({inputs:{x:Y},backend:o,attrs:{shape:te}});return o.disposeIntermediateTensorInfo(Y),ae},fp={kernelName:p.we_,backendName:"webgl",kernelFunc:pp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nu(i){const{inputs:r,backend:o}=i,{x:l}=r;if(l.dtype==="complex64"){const c=Ca({inputs:{input:l},backend:o}),f=Nu({inputs:{x:c},backend:o}),g=ti({inputs:{input:l},backend:o}),C=Nu({inputs:{x:g},backend:o}),v=po({inputs:{real:f,imag:C},backend:o});return o.disposeIntermediateTensorInfo(c),o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(g),o.disposeIntermediateTensorInfo(C),v}else return I({attrs:{shape:l.shape,dtype:l.dtype,value:l.dtype==="string"?"":0},backend:o})}const mp={kernelName:p.RuY,backendName:"webgl",kernelFunc:Nu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wd(i){const{inputs:r,backend:o}=i,{x:l}=r;if(l.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(l.dtype==="complex64"){const c=Ca({inputs:{input:l},backend:o}),f=wd({inputs:{x:c},backend:o}),g=ti({inputs:{input:l},backend:o}),C=Nu({inputs:{x:g},backend:o}),v=po({inputs:{real:f,imag:C},backend:o});return o.disposeIntermediateTensorInfo(c),o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(g),o.disposeIntermediateTensorInfo(C),v}else return I({attrs:{shape:l.shape,dtype:l.dtype,value:1},backend:o})}const gp={kernelName:p.qWM,backendName:"webgl",kernelFunc:wd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yp(i){const{inputs:r,backend:o,attrs:l}=i,{axis:c}=l;if(r.length===1)return Pi({inputs:{input:r[0]},backend:o,attrs:{dim:c}});const f=r[0].shape,g=r[0].dtype;r.forEach(F=>{p.D5U.assertShapesMatch(f,F.shape,"All tensors passed to stack must have matching shapes"),p.D5U.assert(g===F.dtype,()=>"All tensors passed to stack must have matching dtypes")});const C=[],v=r.map(F=>{const H=Pi({inputs:{input:F},backend:o,attrs:{dim:c}});return C.push(H),H}),D=Ri({inputs:v,backend:o,attrs:{axis:c}});return C.forEach(F=>o.disposeIntermediateTensorInfo(F)),D}const xp={kernelName:p.QiL,backendName:"webgl",kernelFunc:yp};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bp{constructor(r,o,l){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=o.map((D,F)=>D[0]+r[F]+D[1]);const c=r.length,f=An(c),g=o.map(D=>D[0]).join(","),C=o.map((D,F)=>D[0]+r[F]).join(","),v=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,c);if(c===1){this.userCode=`
        int start = ${g};
        int end = ${C};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${f} start = ${f}(${g});
      ${f} end = ${f}(${C});

      void main() {
        ${f} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${f} coords = outC - start;
          setOutput(getX(${v}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wp{constructor(r,o,l){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=o.map((Ce,Le)=>Ce[0]+r[Le]+Ce[1]);const c=r.length,f=An(c),g=o.map(Ce=>Ce[0]).join(","),C=o.map((Ce,Le)=>Ce[0]+r[Le]).join(","),v=os("rc",c),D=os("source",c),F=`${v[c-1]} < ${this.outputShape[c-1]}`,H=c===1?"source":`vec2(${D.slice(-2).join()})`,Y=[`${f} rc = outputLoc;`,`${v[c-1]} += 1;
       if(${F}) {
      `,c===1?"":`}
       rc = outputLoc;
       ${v[c-2]} += 1;
       if(${v[c-2]} < ${this.outputShape[c-2]}) {`,c===1?"":`  ${v[c-1]} += 1;
         if(${F}) {`],te=c===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let ae="";for(let Ce=0,Le=c===1?2:4;Ce<Le;Ce++)ae+=`
        ${Y[Ce]}
        if (${te}) {
          result[${Ce}] = float(value);
        } else {
          ${f} source = rc - start;
          result[${Ce}] = getChannel(getX(${D.join()}), ${H});
        }
      `;ae+=c===1?"} ":"}}",this.userCode=`
      const ${f} start = ${f}(${g});
      const ${f} end = ${f}(${C});

      void main() {
        ${f} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${ae}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vd=i=>{const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{paddings:f,constantValue:g}=l;if(p.D5U.sizeFromShape(c.shape)===0){const D=f.map((F,H)=>F[0]+c.shape[H]+F[1]);return I({backend:o,attrs:{shape:D,value:g,dtype:c.dtype}})}const C=(0,p.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new wp(c.shape,f,g):new bp(c.shape,f,g),v=[[g]];return o.runWebGLProgram(C,[c],c.dtype,v)},vp={kernelName:p.lyA,backendName:"webgl",kernelFunc:vd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cp=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Sp=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Vs+`
  return result;
`,Ip=sr({opSnippet:Cp,packedOpSnippet:Sp}),Ep={kernelName:p.pe_,backendName:"webgl",kernelFunc:Ip};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tp(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{axis:f,keepDims:g}=l,C=c.shape.length,v=[],D=p.D5U.parseAxisParam(f,c.shape);let F=D;const H=p.Wap.getAxesPermutation(F,C);let Y=c;H!=null&&(Y=dr({inputs:{x:c},backend:o,attrs:{perm:H}}),F=p.Wap.getInnerMostAxes(F.length,C),v.push(Y)),p.Wap.assertAxesAreInnerMostDims("prod",F,C);let te;if(o.shouldExecuteOnCPU([Y])){const ae=o.texData.get(Y.dataId).values,{outVals:Ce,outShape:Le,outDtype:be}=gr(Y.shape,Y.dtype,ae,F);te=o.makeTensorInfo(Le,be,Ce)}else{const[ae,Ce]=p.Wap.computeOutAndReduceShapes(Y.shape,F),Le=p.D5U.sizeFromShape(Ce),be=Ht({inputs:{x:Y},backend:o,attrs:{shape:[-1,Le]}}),Ge=(0,p.z4k)(c.dtype),Et=aa(be,Ge,"prod",o);te=Ht({inputs:{x:Et},backend:o,attrs:{shape:ae}}),v.push(be),v.push(Et)}if(g){v.push(te);const ae=p.Wap.expandShapeToKeepDim(te.shape,D);te=Ht({inputs:{x:te},backend:o,attrs:{shape:ae}})}return v.forEach(ae=>o.disposeIntermediateTensorInfo(ae)),te}const $p={kernelName:p.DlI,backendName:"webgl",kernelFunc:Tp};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Np(i){const{inputs:r,backend:o,attrs:l}=i,{paramsNestedSplits:c,paramsDenseValues:f,indices:g}=r,{outputRaggedRank:C}=l,v=c.map(be=>o.readSync(be.dataId)),D=c.map(be=>be.shape),F=o.readSync(f.dataId),H=o.readSync(g.dataId),[Y,te,ae]=na(v,D,F,f.shape,f.dtype,H,g.shape,C),Ce=Y.map(be=>o.makeTensorInfo([be.length],"int32",be)),Le=o.makeTensorInfo(ae,f.dtype,te);return Ce.concat([Le])}const kp={kernelName:p.dDz,backendName:"webgl",kernelFunc:Np};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rp(i){const{inputs:r,backend:o}=i,{starts:l,limits:c,deltas:f}=r,g=o.readSync(l.dataId),C=o.readSync(c.dataId),v=o.readSync(f.dataId),[D,F]=h(g,l.shape,l.dtype,C,c.shape,v,f.shape),H=o.makeTensorInfo([D.length],"int32",D),Y=o.makeTensorInfo([F.length],l.dtype,F);return[H,Y]}const Dp={kernelName:p.CQl,backendName:"webgl",kernelFunc:Rp};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _p(i){const{inputs:r,backend:o,attrs:l}=i,{shape:c,values:f,defaultValue:g,rowPartitionTensors:C}=r,{rowPartitionTypes:v}=l,D=o.readSync(c.dataId),F=o.readSync(f.dataId),H=o.readSync(g.dataId),Y=C.map(Le=>o.readSync(Le.dataId)),te=C.map(Le=>Le.shape),[ae,Ce]=N(D,c.shape,F,f.shape,f.dtype,H,g.shape,Y,te,v);return o.makeTensorInfo(ae,f.dtype,Ce)}const Ap={kernelName:p.BiW,backendName:"webgl",kernelFunc:_p};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cd=i=>{const{backend:r,attrs:o}=i,{start:l,stop:c,step:f,dtype:g}=o,C=A(l,c,f,g);return r.makeTensorInfo([C.length],g,C)},Pp={kernelName:p.e6w,backendName:"webgl",kernelFunc:Cd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Op=Bn({opSnippet:"return 1.0 / x;"}),Fp={kernelName:p.$HU,backendName:"webgl",kernelFunc:Op};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bp=yr+`
  return (x < 0.0) ? 0.0 : x;
`,Lp=Bn({opSnippet:Bp,packedOpSnippet:`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`}),Up={kernelName:p.qkr,backendName:"webgl",kernelFunc:Lp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mp=yr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Oi=Bn({opSnippet:Mp,packedOpSnippet:`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`}),Wp={kernelName:p.SbG,backendName:"webgl",kernelFunc:Oi};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vp{constructor(r,o,l,c,f){this.variableNames=["A"],this.outputShape=[];const[g,C,v,D]=r;this.outputShape=[g,o,l,D];const F=[c&&o>1?C-1:C,c&&l>1?v-1:v],H=[c&&o>1?o-1:o,c&&l>1?l-1:l];let Y;f?Y="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":Y="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${F[0]/H[0]},
          ${F[1]/H[1]});
      const vec2 inputShapeRC = vec2(${C}.0, ${v}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${Y};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zp{constructor(r,o,l,c,f){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[g,C,v,D]=r;this.outputShape=[g,o,l,D];const F=[c&&o>1?C-1:C,c&&l>1?v-1:v],H=[c&&o>1?o-1:o,c&&l>1?l-1:l];let Y;f?Y="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":Y="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${F[0]/H[0]},
          ${F[1]/H[1]},
          ${F[1]/H[1]});
      const vec3 inputShapeRC = vec3(${C}.0, ${v}.0,
                                     ${v}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${Y};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${D-1};
        bool hasNextRow = coords.z < ${l-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gp(i){const{inputs:r,backend:o,attrs:l}=i,{images:c}=r,{alignCorners:f,halfPixelCenters:g,size:C}=l,[v,D]=C,F=(0,p.OBj)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new zp(c.shape,v,D,f,g):new Vp(c.shape,v,D,f,g);return o.runWebGLProgram(F,[c],"float32")}const Hp={kernelName:p._Yw,backendName:"webgl",kernelFunc:Gp};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jp{constructor(r,o,l){this.variableNames=["dy"],this.outputShape=[],this.outputShape=o;const[,c,f]=o,[,g,C]=r,v=[l&&g>1?c-1:c,l&&C>1?f-1:f],D=[l&&g>1?g-1:g,l&&C>1?C-1:C],F=v[0]/D[0],H=v[1]/D[1],Y=1/F,te=1/H,ae=Math.ceil(Y)*2+2,Ce=Math.ceil(te)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${F});
        const float widthScale = float(${H});

        const float invHeightScale = float(${Y});
        const float invWidthScale = float(${te});

        const int winHeight = int(${ae});
        const int winWidth = int(${Ce});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${g}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${C}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${c-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${f-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kp(i){const{inputs:r,backend:o,attrs:l}=i,{images:c,dy:f}=r,{alignCorners:g}=l,C=new jp(f.shape,c.shape,g);return o.runWebGLProgram(C,[f],f.dtype)}const Xp={kernelName:p.zbQ,backendName:"webgl",kernelFunc:Kp};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yp{constructor(r,o,l,c,f){this.variableNames=["A"],this.outputShape=[];const[g,C,v,D]=r;this.outputShape=[g,o,l,D];const F=[c&&o>1?C-1:C,c&&l>1?v-1:v],H=[c&&o>1?o-1:o,c&&l>1?l-1:l],Y=c?"0.5":"0.0";let te;f?te="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":te="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${F[0]/H[0]},
          ${F[1]/H[1]});
      const vec2 inputShapeRC = vec2(${C}.0, ${v}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${te};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${Y})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qp{constructor(r,o,l,c,f){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[g,C,v,D]=r;this.outputShape=[g,o,l,D];const F=[c&&o>1?C-1:C,c&&l>1?v-1:v],H=[c&&o>1?o-1:o,c&&l>1?l-1:l],Y=c?"0.5":"0.0";let te;f?te="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":te="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${F[0]/H[0]},
          ${F[1]/H[1]},
          ${F[1]/H[1]});
      const vec3 inputShapeRC = vec3(${C}.0, ${v}.0,
                                     ${v}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${te};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${Y})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${D-1};
        bool hasNextRow = coords.z < ${l-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qp(i){const{inputs:r,backend:o,attrs:l}=i,{images:c}=r,{alignCorners:f,halfPixelCenters:g,size:C}=l,[v,D]=C,F=(0,p.OBj)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new qp(c.shape,v,D,f,g):new Yp(c.shape,v,D,f,g);return o.runWebGLProgram(F,[c],c.dtype)}const Zp={kernelName:p.dpD,backendName:"webgl",kernelFunc:Qp};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jp{constructor(r,o,l){this.variableNames=["dy"],this.outputShape=[],this.outputShape=o;const[,c,f]=o,[,g,C]=r,v=[l&&g>1?c-1:c,l&&C>1?f-1:f],D=[l&&g>1?g-1:g,l&&C>1?C-1:C],F=v[0]/D[0],H=v[1]/D[1],Y=1/F,te=1/H,ae=Math.ceil(Y)*2+2,Ce=Math.ceil(te)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${F});
        const float widthScale = float(${H});

        const float invHeightScale = float(${Y});
        const float invWidthScale = float(${te});

        const int winHeight = int(${ae});
        const int winWidth = int(${Ce});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${g}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${C}) {
              continue;
            }

            float sourceFracRow =
              float(${v[0]}) *
                (float(dyR) / float(${D[0]}));

            float sourceFracCol =
                float(${v[1]}) *
                  (float(dyC) / float(${D[1]}));

            int sourceNearestRow = int(min(
                float(int(${c}) - 1),
                ${l} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${f}) - 1),
                ${l} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ef(i){const{inputs:r,backend:o,attrs:l}=i,{images:c,dy:f}=r,{alignCorners:g}=l,C=new Jp(f.shape,c.shape,g);return o.runWebGLProgram(C,[f],f.dtype)}const tf={kernelName:p.Hmb,backendName:"webgl",kernelFunc:ef};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nf{constructor(r,o){this.variableNames=["x"];const l=r.length;if(l>4)throw new Error(`WebGL backend: Reverse of rank-${l} tensor is not yet supported`);if(this.outputShape=r,l===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${r[0]} - coord - 1));
        }
      `;return}const c=C=>o.indexOf(C)!==-1&&r[C]!==1?`${r[C]} - coords[${C}] - 1`:`coords[${C}]`,f=r.map((C,v)=>c(v)).join(","),g=An(l);this.userCode=`
      void main() {
        ${g} coords = getOutputCoords();
        setOutput(getX(${f}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sf{constructor(r,o){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const l=r.length;if(l>4)throw new Error(`WebGL backend: Reverse of rank-${l} tensor is not yet supported`);this.outputShape=r;const c=os("rc",l),f=`${c[l-1]} + 1 < ${this.outputShape[l-1]}`,g=`${c[l-2]} + 1 < ${this.outputShape[l-2]}`,C=An(l);l===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${r[0]} - rc - 1),
            ${r[0]} - rc - 1);
          if(${f}){
              result.g = getChannel(getX(${r[0]} - (rc  + 1) - 1),
                ${r[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${C} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${v(c.slice())};
          if(${f}){
            result.g = ${D(c.slice())};
          }
          if(${g}) {
            result.b = ${F(c.slice())};
            if(${f}) {
              result.a = ${H(c.slice())};
            }
          }
          setOutput(result);
        }
    `;function v(ae){return Y(ae)}function D(ae){return ae[l-1]="("+ae[l-1]+" + 1)",Y(ae)}function F(ae){return ae[l-2]="("+ae[l-2]+" + 1)",Y(ae)}function H(ae){return ae[l-1]="("+ae[l-1]+" + 1)",ae[l-2]="("+ae[l-2]+" + 1)",Y(ae)}function Y(ae){const Ce=r.map((Ge,Et)=>te(Et,ae)),Le=Ce.join(","),be=Ce.slice(-2).join(",");return`getChannel(getX(${Le}), vec2(${be}))`}function te(ae,Ce){return o.indexOf(ae)!==-1&&r[ae]!==1?`${r[ae]} - ${Ce[ae]} - 1`:`${Ce[ae]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rf(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{dims:f}=l,g=c.shape.length,C=p.D5U.parseAxisParam(f,c.shape);if(g===0)return rs({inputs:{x:c},backend:o});const v=(0,p.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new sf(c.shape,C):new nf(c.shape,C);return o.runWebGLProgram(v,[c],c.dtype)}const of={kernelName:p.mKl,backendName:"webgl",kernelFunc:rf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class af{constructor(r,o){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const l=r[1],c=r[2];this.outputShape=r;let f="";typeof o=="number"?f=`float outputValue = ${o.toFixed(2)};`:f=`
        vec3 fill = vec3(${o.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${f}
          if(coordX >= 0 && coordX < ${c} && coordY >= 0 && coordY < ${l}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uf={kernelName:p.b9H,backendName:"webgl",kernelFunc:({inputs:i,attrs:r,backend:o})=>{const{image:l}=i,{radians:c,fillValue:f,center:g}=r,C=o,v=new af(l.shape,f),[D,F]=p.Wap.getImageCenter(g,l.shape[1],l.shape[2]),H=[[D,F,Math.sin(c),Math.cos(c)]];return C.runWebGLProgram(v,[l],l.dtype,H)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lf=Bn({opSnippet:`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`}),cf={kernelName:p.e07,backendName:"webgl",kernelFunc:lf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const df=Bn({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Q}),Sd={kernelName:p.bV0,backendName:"webgl",kernelFunc:df};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zc{constructor(r,o,l,c,f,g,C=!0,v=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=g;const D=An(f.length),F=An(g.length);let H="";l===1?H="i":l===2&&(H="i, j");const Y=`getIndices(${H})`;let te="";c===1?te="i":c===2&&(te="i, coords[1]");const ae=`getUpdates(${te})`;let Ce="";v&&(Ce="coords[0], coords[1]");const Le=`getDefaultValue(${Ce})`,be=o>1?"strides[j]":"strides";this.userCode=`
        ${D} strides = ${D}(${f});

        void main() {
          ${F} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${r}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${o}; j++) {
              int index = round(${Y});
              flattenedIndex += index * ${be};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${ae};
              found = true;
            }
          }
          setOutput(mix(${Le}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hf{constructor(r,o,l,c,f,g,C=!0,v=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=g;const D=An(f.length),F=An(g.length);let H="";l===1?H="i":l===2&&(H="i, j");const Y=`getIndices(${H})`;let te="";c===1?te="i":c===2&&(te="i, coords[1]");const ae=`getUpdates(${te})`;let Ce="";v&&(Ce="coords[0], coords[1]");const Le=`getDefaultValue(${Ce})`,be=o>1?"strides[j]":"strides",Ge=o>1?"strides[j + 1]":"strides";this.userCode=`
        ${D} strides = ${D}(${f});

        void main() {
          ${F} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${r}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${o}; j+=2) {
              ivec4 index = round(${Y});
              flattenedIndex += index.xz * ${be};
              if (j + 1 < ${o}) {
                flattenedIndex += index.yw * ${Ge};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${ae};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${Le}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pf(i){const{inputs:r,backend:o,attrs:l}=i,{indices:c,updates:f}=r,{shape:g}=l,{sliceRank:C,numUpdates:v,sliceSize:D,strides:F,outputSize:H}=p.Wap.calculateShapes(f,c,g),Y=[H/D,D];if(H===0)return o.makeTensorInfo(g,c.dtype);const te=Ht({inputs:{x:c},backend:o,attrs:{shape:[v,C]}}),ae=Ht({inputs:{x:f},backend:o,attrs:{shape:[v,D]}}),Ce=o.makeTensorInfo([],"float32",new Float32Array([0]));let Le;(0,p.OBj)().getBool("WEBGL_PACK")?Le=new hf(v,C,te.shape.length,ae.shape.length,F,Y):Le=new Zc(v,C,te.shape.length,ae.shape.length,F,Y);const be=o.runWebGLProgram(Le,[ae,te,Ce],ae.dtype),Ge=Ht({inputs:{x:be},backend:o,attrs:{shape:g}});return o.disposeIntermediateTensorInfo(te),o.disposeIntermediateTensorInfo(ae),o.disposeIntermediateTensorInfo(be),o.disposeIntermediateTensorInfo(Ce),Ge}const ff={kernelName:p.xQA,backendName:"webgl",kernelFunc:pf};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mf{constructor(r,o,l,c){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[r,l];const f="while (left < right) {",g=`for (int i = 0; i < ${Math.ceil(Math.log2(o+1))}; ++i) { if (left >= right) break;`,C=(0,p.OBj)().getNumber("WEBGL_VERSION")===2?f:g,v=c==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${C}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${v} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gf(i){const{inputs:r,backend:o,attrs:l}=i,{sortedSequence:c,values:f}=r,{side:g}=l,C=new mf(c.shape[0],c.shape[1],f.shape[1],g),v=[[c.shape[1]]];return o.runWebGLProgram(C,[c,f],"int32",v)}const Jc={kernelName:p.nr8,backendName:"webgl",kernelFunc:gf};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yf{constructor(r,o,l){this.variableNames=["c","a","b"],this.outputShape=o;let c,f;if(l>4)throw Error(`Where for rank ${l} is not yet supported`);if(l===1)f="resRC",c="resRC";else{const C=["resRC.x","resRC.y","resRC.z","resRC.w"],v=[],D=[];for(let F=0;F<o.length;F++)D.push(`${C[F]}`),F<r&&v.push(`${C[F]}`);c=v.join(),f=D.join()}const g=An(l);this.userCode=`
      void main() {
        ${g} resRC = getOutputCoords();
        float cVal = getC(${c});
        if (cVal >= 1.0) {
          setOutput(getA(${f}));
        } else {
          setOutput(getB(${f}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xf(i){const{inputs:r,backend:o}=i,{condition:l,t:c,e:f}=r,g=new yf(l.shape.length,c.shape,c.shape.length);return o.runWebGLProgram(g,[l,c,f],(0,p.x8V)(c.dtype,f.dtype))}const bf={kernelName:p.PhF,backendName:"webgl",kernelFunc:xf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wf=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${p.Wap.SELU_SCALEALPHA};
  float scale = ${p.Wap.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,vf=Bn({opSnippet:wf}),Cf={kernelName:p.oFR,backendName:"webgl",kernelFunc:vf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sf=ra+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,If=Bn({opSnippet:Sf,packedOpSnippet:`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cpuKernelImpl:ke}),Ef={kernelName:p.a5O,backendName:"webgl",kernelFunc:If};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tf=Bn({opSnippet:`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`}),$f={kernelName:p.i5y,backendName:"webgl",kernelFunc:Tf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nf=ra+`
  return sin(x);
`,kf=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Vs}
  return result;
`,Rf=Bn({opSnippet:Nf,packedOpSnippet:kf}),Df={kernelName:p.RQH,backendName:"webgl",kernelFunc:Rf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _f=Bn({opSnippet:`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`}),Af={kernelName:p.wYB,backendName:"webgl",kernelFunc:_f};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pf=Bn({opSnippet:`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`}),Of={kernelName:p.MRv,backendName:"webgl",kernelFunc:Pf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ff=i=>{const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{blockShape:f,paddings:g}=l;p.D5U.assert(c.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const C=f.reduce((be,Ge)=>be*Ge),v=[[0,0]];v.push(...g);for(let be=1+f.length;be<c.shape.length;++be)v.push([0,0]);const D=[],F=vd({inputs:{x:c},backend:o,attrs:{paddings:v,constantValue:0}}),H=p.Wap.getReshaped(F.shape,f,C,!1),Y=p.Wap.getPermuted(H.length,f.length,!1),te=p.Wap.getReshapedPermuted(F.shape,f,C,!1),ae=Ht({inputs:{x:F},backend:o,attrs:{shape:H}}),Ce=dr({inputs:{x:ae},backend:o,attrs:{perm:Y}}),Le=Ht({inputs:{x:Ce},backend:o,attrs:{shape:te}});return D.push(F),D.push(ae),D.push(Ce),D.forEach(be=>o.disposeIntermediateTensorInfo(be)),Le},Bf={kernelName:p.TQc,backendName:"webgl",kernelFunc:Ff};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lf(i){const{inputs:r,backend:o}=i,{indices:l,values:c,denseShape:f,defaultValue:g}=r;if(f.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${f.shape}`);if(l.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${l.shape}`);if(c.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${c.shape}`);if(g.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${g.shape}`);const C=o.readSync(l.dataId),v=o.readSync(c.dataId),D=o.readSync(f.dataId),F=o.readSync(g.dataId)[0],[H,Y,te,ae,Ce]=lt(C,l.shape,l.dtype,v,c.dtype,D,F);return[o.makeTensorInfo(Y,l.dtype,H),o.makeTensorInfo([Y[0]],c.dtype,te),o.makeTensorInfo([ae.length],"bool",new Uint8Array(ae.map(Le=>Number(Le)))),o.makeTensorInfo([Ce.length],l.dtype,new Int32Array(Ce))]}const Uf={kernelName:p.O3z,backendName:"webgl",kernelFunc:Lf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oi(i){const{inputs:r,backend:o}=i,{inputIndices:l,inputShape:c,newShape:f}=r;if(l.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${l.shape}`);if(c.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${c.shape}`);if(f.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${f.shape}`);const g=Array.from(o.readSync(c.dataId)),C=o.readSync(l.dataId),v=Array.from(o.readSync(f.dataId)),[D,F,H]=Rt(C,l.shape,l.dtype,g,v);return[o.makeTensorInfo(F,l.dtype,D),o.makeTensorInfo([H.length],f.dtype,new Int32Array(H))]}const Id={kernelName:p.nhH,backendName:"webgl",kernelFunc:oi};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mf(i){const{inputs:r,backend:o}=i,{data:l,indices:c,segmentIds:f}=r;if(l.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(c.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${c.shape}`);if(f.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${f.shape}`);const g=o.readSync(l.dataId),C=o.readSync(c.dataId),v=o.readSync(f.dataId),[D,F]=zt(g,l.shape,l.dtype,C,v,!0);return o.makeTensorInfo(F,l.dtype,D)}const Wf={kernelName:p.w3H,backendName:"webgl",kernelFunc:Mf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vf(i){const{inputs:r,backend:o}=i,{data:l,indices:c,segmentIds:f}=r;if(l.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(c.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${c.shape}`);if(f.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${f.shape}`);const g=o.readSync(l.dataId),C=o.readSync(c.dataId),v=o.readSync(f.dataId),[D,F]=zt(g,l.shape,l.dtype,C,v);return o.makeTensorInfo(F,l.dtype,D)}const zf={kernelName:p.ZjV,backendName:"webgl",kernelFunc:Vf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gf(i){const{inputs:r,backend:o,attrs:l}=i,{sparseIndices:c,sparseValues:f,defaultValue:g}=r,{outputShape:C}=l,{sliceRank:v,numUpdates:D,sliceSize:F,strides:H,outputSize:Y}=p.Wap.calculateShapes(f,c,C),te=!1;if(f.dtype==="string"){const be=o.bufferSync(c),Ge=o.bufferSync(f),Et=p.D5U.decodeString(o.readSync(g.dataId)[0]),vt=ge(be,Ge,C,Y,F,D,v,H,Et,te);return o.makeTensorInfo(C,vt.dtype,vt.values)}const ae=new Zc(D,v,c.shape.length,f.shape.length,H,[Y,1],te),Ce=o.runWebGLProgram(ae,[f,c,g],f.dtype),Le=Ht({inputs:{x:Ce},backend:o,attrs:{shape:C}});return o.disposeIntermediateTensorInfo(Ce),Le}const Hf={kernelName:p.D2d,backendName:"webgl",kernelFunc:Gf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jf(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{numOrSizeSplits:f,axis:g}=l,C=p.D5U.parseAxisParam(g,c.shape)[0],v=p.Wap.prepareSplitSize(c,f,C),D=c.shape.length,F=new Array(D).fill(0),H=c.shape.slice();return v.map(Y=>{const te=[...H];te[C]=Y;const ae=va({inputs:{x:c},backend:o,attrs:{begin:F,size:te}});return F[C]+=Y,ae})}const Kf={kernelName:p.L8s,backendName:"webgl",kernelFunc:jf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ed="return sqrt(x);",Xf=Bn({opSnippet:Ed,packedOpSnippet:Ed,cpuKernelImpl:yn}),Yf={kernelName:p.FKq,backendName:"webgl",kernelFunc:Xf};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Td=Bn({opSnippet:"return x * x;"}),is={kernelName:p.bK0,backendName:"webgl",kernelFunc:Td};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zn="return (a - b) * (a - b);",jn=sr({opSnippet:zn,packedOpSnippet:zn}),Va={kernelName:p._tC,backendName:"webgl",kernelFunc:jn};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qo(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r;if(c.dtype!=="string")throw new Error("Input must be of datatype string");const f=o.readSync(c.dataId),g=p.Wap.fromUint8ToStringArray(f),C=an(g,"string",l);return o.makeTensorInfo(c.shape,"string",C)}const Fi={kernelName:p.e0R,backendName:"webgl",kernelFunc:Qo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qf({inputs:i,attrs:r,backend:o}){const{x:l}=i,c=yr+`
    return x > 0.0 ? 1.0 : float(${r.alpha});
  `,f=new Yr(l.shape,c);return o.runWebGLProgram(f,[l],l.dtype)}const Zf={kernelName:p.h8e,backendName:"webgl",kernelFunc:Qf};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jf{constructor(r,o,l){this.variableNames=["x"],this.outputShape=l;const c=l.length,f=An(l.length),g=An(l.length);let C="";if(c===1)C="coords * strides + begin";else{let v=0;C=l.map((D,F)=>(v++,l.length===1?`coords * strides[${F}] + begin[${F}]`:`coords[${v-1}] * strides[${F}] + begin[${F}]`)).join(",")}this.userCode=`
      ${f} begin = ${f}(${r});
      ${f} strides = ${f}(${o});

      void main() {
        ${g} coords = getOutputCoords();
        setOutput(getX(${C}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function em(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{begin:f,end:g,strides:C,beginMask:v,endMask:D,ellipsisMask:F,newAxisMask:H,shrinkAxisMask:Y}=l,{finalShapeSparse:te,finalShape:ae,isIdentity:Ce,sliceDim0:Le,isSimpleSlice:be,begin:Ge,end:Et,strides:vt}=p.kuN.sliceInfo(c.shape,f,g,C,v,D,F,H,Y);let jt;if(Ce)jt=Ht({inputs:{x:c},backend:o,attrs:{shape:ae}});else if(Le||be){p.D5U.assert(c.shape.length>=1,()=>`Input must have rank at least 1, got: ${c.shape.length}`);const gn=p.kuN.computeOutShape(Ge,Et,vt),rn=va({inputs:{x:c},backend:o,attrs:{begin:Ge,size:gn}});jt=Ht({inputs:{x:rn},backend:o,attrs:{shape:ae}}),o.disposeIntermediateTensorInfo(rn)}else if(o.shouldExecuteOnCPU([c])){const rn=o.readSync(c.dataId),Gn=(0,p.f3b)(c.shape,c.dtype,rn),_n=Xt(te,Gn,vt,Ge);jt=o.makeTensorInfo(ae,c.dtype,_n.values)}else{const rn=new Jf(Ge,vt,te);jt=o.runWebGLProgram(rn,[c],c.dtype)}const En=Ht({inputs:{x:jt},backend:o,attrs:{shape:ae}});return o.disposeIntermediateTensorInfo(jt),En}const ku={kernelName:p.jQk,backendName:"webgl",kernelFunc:em};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $d(i){const{inputs:r,backend:o,attrs:l}=i,{separator:c,nGramWidths:f,leftPad:g,rightPad:C,padWidth:v,preserveShortSequences:D}=l,{data:F,dataSplits:H}=r,Y=o.readSync(F.dataId),te=o.readSync(H.dataId),[ae,Ce]=xn(Y,te,c,f,g,C,v,D);return[o.makeTensorInfo([ae.length],"string",ae),o.makeTensorInfo(H.shape,"int32",Ce)]}const Nd={kernelName:p._JP,backendName:"webgl",kernelFunc:$d};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tm(i){const{inputs:r,backend:o,attrs:l}=i,{skipEmpty:c}=l,{input:f,delimiter:g}=r;if(f.dtype!=="string")throw new Error("Input must be of datatype string");if(f.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${f.shape}`);if(g.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${g.shape}`);const C=o.readSync(f.dataId),v=o.readSync(g.dataId)[0],[D,F,H]=Tn(C,v,c),Y=F.length;return[o.makeTensorInfo([Y,2],"int32",D),o.makeTensorInfo([Y],"string",F),o.makeTensorInfo([2],"int32",new Int32Array(H))]}const kd={kernelName:p.s1s,backendName:"webgl",kernelFunc:tm};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bi(i){const{inputs:r,backend:o,attrs:l}=i,{numBuckets:c}=l,{input:f}=r;if(f.dtype!=="string")throw new Error("Input must be of datatype string");if(c<=0)throw new Error("Number of buckets must be at least 1");const g=o.readSync(f.dataId),C=ss(g,c);return o.makeTensorInfo(f.shape,"int32",C)}const nm={kernelName:p.XkS,backendName:"webgl",kernelFunc:Bi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sm=Bn({opSnippet:"return tan(x);"}),rm={kernelName:p.sEM,backendName:"webgl",kernelFunc:sm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rd=Bn({opSnippet:`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`}),ed={kernelName:p.MIZ,backendName:"webgl",kernelFunc:Rd};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dd(i){const{inputs:r,backend:o,attrs:l}=i,{tensor:c,indices:f,updates:g}=r,{}=l,{sliceRank:C,numUpdates:v,sliceSize:D,strides:F,outputSize:H}=p.Wap.calculateShapes(g,f,c.shape),Y=[H/D,D];if(H===0)return o.makeTensorInfo(c.shape,f.dtype);const te=Ht({inputs:{x:f},backend:o,attrs:{shape:[v,C]}}),ae=Ht({inputs:{x:g},backend:o,attrs:{shape:[v,D]}}),Ce=Ht({inputs:{x:c},backend:o,attrs:{shape:Y}}),Le=new Zc(v,C,te.shape.length,ae.shape.length,F,Y,!1,!0),be=o.runWebGLProgram(Le,[ae,te,Ce],Ce.dtype),Ge=Ht({inputs:{x:be},backend:o,attrs:{shape:c.shape}});return o.disposeIntermediateTensorInfo(te),o.disposeIntermediateTensorInfo(ae),o.disposeIntermediateTensorInfo(Ce),o.disposeIntermediateTensorInfo(be),Ge}const td={kernelName:p.SIB,backendName:"webgl",kernelFunc:Dd};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nd{constructor(r,o){this.variableNames=["A"];const l=new Array(r.length);for(let g=0;g<l.length;g++)l[g]=r[g]*o[g];this.outputShape=l,this.rank=l.length;const c=An(this.rank),f=_d(r);this.userCode=`
      void main() {
        ${c} resRC = getOutputCoords();
        setOutput(getA(${f}));
      }
    `}}function _d(i){const r=i.length;if(r>5)throw Error(`Tile for rank ${r} is not yet supported`);if(r===1)return`imod(resRC, ${i[0]})`;const o=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],l=[];for(let c=0;c<i.length;c++)l.push(`imod(${o[c]}, ${i[c]})`);return l.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ru(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{reps:f}=l;if(c.dtype==="string"||c.shape.length>5){const v=o.readSync(c.dataId),D=c.dtype==="string"?v.map(Y=>p.D5U.decodeString(Y)):v,F=(0,p.f3b)(c.shape,c.dtype,D),H=gs(F,f);return o.makeTensorInfo(H.shape,H.dtype,H.values)}const g=new nd(c.shape,f);return o.runWebGLProgram(g,[c],c.dtype)}const Rr={kernelName:p.n9L,backendName:"webgl",kernelFunc:Ru};class Ad{constructor(r){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=r,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class Pd{constructor(r){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=r,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pa(i,r){r!==null&&i.disposeIntermediateTensorInfo(r)}function sd(i){let r=1;for(;r<i;)r*=2;return r}function om(i){const{inputs:r,backend:o,attrs:l}=i,{x:c}=r,{k:f,sorted:g}=l,C=(0,p.OBj)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),v=(0,p.OBj)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),D=c.shape,F=D[D.length-1];if(o.shouldExecuteOnCPU([c])||F<C||f>v){const _n=o.readSync(c.dataId),[_s,Ls]=cr(_n,D,c.dtype,f,g);return[o.makeTensorInfo(_s.shape,_s.dtype,_s.values),o.makeTensorInfo(Ls.shape,Ls.dtype,Ls.values)]}if(f===0)return D[D.length-1]=0,[o.makeTensorInfo(D,c.dtype,[]),o.makeTensorInfo(D,"int32",[])];if(F===1)return[c,I({attrs:{shape:D,dtype:"int32",value:0},backend:o})];const H=o.texData.get(c.dataId),Y=H!==null&&H.isPacked,te=Y?o.unpackTensor(c):c,Ce=p.D5U.sizeFromShape(D)/F,Le=Ht({inputs:{x:te},attrs:{shape:[Ce,F]},backend:o});Y&&pa(o,te);const be=sd(f),Ge=sd(F);let Et=null;const vt=()=>Et===null?[Le,Le]:[Le,Et],jt=(_n,_s,Ls)=>{const Zo=vt(),Xs=new Ad(Ls),yo=[[F],[Et===null?1:0],[Number.NEGATIVE_INFINITY],[_n],[_s]],Mo=Et;Et=o.runWebGLProgram(Xs,Zo,"int32",yo),pa(o,Mo)};for(let _n=1;_n<be;_n*=2){const _s=_n*2;for(let Ls=_n;Ls>=1;Ls/=2)jt(_s,Ls,[Ce,Ge])}for(let _n=Ge;_n>be;_n/=2){const _s=vt(),Ls=new Pd([Ce,_n/2]),Xs=[[F],[Et===null?1:0],[be]],us=Et;Et=o.runWebGLProgram(Ls,_s,"int32",Xs),pa(o,us);const yo=be/2,Mo=yo*2;for(let Dr=yo;Dr>=1;Dr/=2)jt(Mo,Dr,Et.shape)}let En=Et;Et=va({inputs:{x:Et},backend:o,attrs:{begin:0,size:[Ce,f]}}),pa(o,En);let gn=hs({inputs:{x:Le,indices:Et},backend:o,attrs:{axis:1,batchDims:1}});pa(o,Le);const rn=D.slice(0,-1);rn.push(f),En=Et,Et=Ht({inputs:{x:Et},attrs:{shape:rn},backend:o}),pa(o,En);const Gn=gn;return gn=Ht({inputs:{x:gn},attrs:{shape:rn},backend:o}),pa(o,Gn),[gn,Et]}const Od={kernelName:p.cWu,backendName:"webgl",kernelFunc:om};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fd{constructor(r,o,l,c,f,g){this.variableNames=["Image","Transforms"],this.outputShape=g;const C=l==="nearest"?1:2;let v;switch(c){case"constant":v=1;break;case"reflect":v=2;break;case"wrap":v=3;break;case"nearest":v=4;break;default:v=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${v} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${v} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${v} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${r} && 0 <= coordX && coordX < ${o}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${f});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${f});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${o}));
                float mapY = mapCoord(inY, float(${r}));

                if (${C} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function am(i){const{inputs:r,backend:o,attrs:l}=i,{image:c,transforms:f}=r,{interpolation:g,fillMode:C,fillValue:v,outputShape:D}=l,[F,H,Y,te]=c.shape,[ae,Ce]=D??[H,Y],Le=[F,ae,Ce,te],be=new Fd(H,Y,g,C,v,Le);return o.runWebGLProgram(be,[c,f],"float32")}const Bd={kernelName:p.wx7,backendName:"webgl",kernelFunc:am};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function im(i){const{inputs:r,attrs:o,backend:l}=i,{axis:c}=o,{x:f}=r;mn(f,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const g=l.readSync(f.dataId),{outputValues:C,outputShape:v,indices:D}=Fn(g,c,f.shape,f.dtype);return[l.makeTensorInfo(v,f.dtype,C),l.makeTensorInfo([D.length],"int32",D)]}const Ld={kernelName:p.kpP,backendName:"webgl",kernelFunc:im};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function um(i){const{inputs:r,backend:o,attrs:l}=i,{value:c}=r;let{axis:f}=l;f<0&&(f+=c.shape.length);const g=c,C=g.shape.length,v=c.shape[f],D=new Array(C-1);let F=0;for(let Ce=0;Ce<C;Ce++)Ce!==f&&(D[F++]=g.shape[Ce]);const H=[],Y=new Array(C).fill(0),te=g.shape.slice();te[f]=1;const ae=new Array(v);for(let Ce=0;Ce<ae.length;Ce++){Y[f]=Ce;const Le=va({inputs:{x:g},backend:o,attrs:{begin:Y,size:te}}),be=Ht({inputs:{x:Le},backend:o,attrs:{shape:D}});ae[Ce]=be,H.push(Le)}return H.forEach(Ce=>o.disposeIntermediateTensorInfo(Ce)),ae}const lm={kernelName:p.ToN,backendName:"webgl",kernelFunc:um};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cm{constructor(r,o){this.variableNames=["x","segmentIds"];const l=r.windowSize,c=r.batchSize,f=r.inSize,g=r.numSegments,C=g*Math.ceil(f/l);this.outputShape=[c,C];const v="0.0",D="sumValue",F=Math.floor(l/4)*4,H=l%4,Y=`
        sumValue += dot(values, segFilter);
    `;let te="";f%l>0&&(te=`
        if (inIdx < 0 || inIdx >= ${f}) {
          return initializationValue;
        }
      `);let ae="";f%l>0&&(ae=`
        if (inIdx < 0 || inIdx >= ${f}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${v};

      float getValue(int batch, int inIdx) {
        ${te}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${ae}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${g})) * float(${l}));
        int currentSeg = int(mod(float(outIdx), float(${g})));

        float sumValue = 0.0;

        for (int i = 0; i < ${F}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${Y}
        }

        int inIdx = inOffset + ${F};
        if (${H===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${Y}
        } else if (${H===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${Y}
        } else if (${H===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${Y}
        }
        setOutput(${D});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dm(i){const{inputs:r,backend:o,attrs:l}=i,{x:c,segmentIds:f}=r,{numSegments:g}=l,C=c.shape.length,v=[];let D=0;const F=p.Wap.getAxesPermutation([D],C);let H=c;F!=null&&(H=dr({inputs:{x:c},backend:o,attrs:{perm:F}}),v.push(H),D=p.Wap.getInnerMostAxes(1,C)[0]);const Y=p.Wap.segment_util.computeOutShape(H.shape,D,g),te=p.D5U.sizeFromShape([H.shape[D]]),ae=Ht({inputs:{x:H},backend:o,attrs:{shape:[-1,te]}});v.push(ae);const Ce=(0,p.z4k)(c.dtype),Le=(vt,jt,En,gn,rn)=>{const Gn=vt.shape[0],_n=vt.shape[1],_s=p.Wap.segment_util.segOpComputeOptimalWindowSize(_n,rn),Ls={windowSize:_s,inSize:_n,batchSize:Gn,numSegments:rn},Zo=new cm(Ls,jt),Xs=o.compileAndRun(Zo,[vt,En],gn);if(v.push(Xs),Xs.shape[1]===rn)return Xs;const us=Cd({backend:o,attrs:{start:0,stop:rn,step:1,dtype:"float32"}}),yo=Ru({inputs:{x:us},backend:o,attrs:{reps:[_n/_s]}});return v.push(us),v.push(yo),Le(Xs,jt,yo,gn,rn)},be=Le(ae,"unsortedSegmentSum",f,Ce,g),Ge=Ht({inputs:{x:be},backend:o,attrs:{shape:Y}});let Et=Ge;if(F!=null){v.push(Ge);const vt=p.Wap.getUndoAxesPermutation(F);Et=dr({inputs:{x:Et},backend:o,attrs:{perm:vt}})}return v.forEach(vt=>o.disposeIntermediateTensorInfo(vt)),Et}const hm={kernelName:p.Qvg,backendName:"webgl",kernelFunc:dm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ud=[ua,Vn,Wu,zu,Hu,Xu,qu,Zu,nl,rl,il,Ja,cl,dl,wi,fl,gl,Ds,xl,ca,Cl,Nl,kl,su,Fa,Fl,Ll,au,Ra,ki,jl,du,ec,sc,rc,Sa,ac,uc,cc,hc,fc,gc,xc,vc,xr,Ec,$c,Rc,xu,wu,Pc,Lc,vu,Wc,zc,Gc,jc,Xc,w,$,j,qe,Yt,Ks,$s,ys,bs,ko,Ea,qa,Wd,Gl,Qc,zd,Hd,Da,Kd,Xd,qd,Jd,nh,rh,ah,uh,hh,mh,yh,wh,Ch,Ih,Nh,Rh,_h,Ph,Fh,Mh,Gh,Xh,tp,_u,rp,ap,up,dp,Ti,fp,gp,xp,vp,Ep,Lo,$p,kp,Dp,Ap,Pp,Pl,Qh,Fp,Up,Wp,Pu,Hp,Xp,Zp,tf,of,uf,cf,Sd,ff,Jc,bf,Cf,Ef,$f,Df,Af,Tl,Jh,Of,Bf,Uf,Id,Wf,zf,Hf,Kf,Yf,is,Va,Fi,Zf,ku,Nd,kd,nm,Zh,yi,rm,ed,td,Rr,Od,Bd,ji,Ld,lm,hm,mp];for(const i of Ud)(0,p.wCN)(i);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},3993:function(Wt,dt,L){"use strict";L.d(dt,{JL:()=>Z,Zu:()=>ie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p=1e-7,ze=1e-4;class Z{constructor(pe,ee){this.backend=pe,this.dataMover=ee,this.data=new WeakMap,this.dataIdsCount=0}get(pe){return this.data.has(pe)||this.dataMover.moveData(this.backend,pe),this.data.get(pe)}set(pe,ee){this.dataIdsCount++,this.data.set(pe,ee)}has(pe){return this.data.has(pe)}delete(pe){return this.dataIdsCount--,this.data.delete(pe)}numDataIds(){return this.dataIdsCount}}class ie{refCount(pe){return P("refCount")}incRef(pe){return P("incRef")}timerAvailable(){return!0}time(pe){return P("time")}read(pe){return P("read")}readSync(pe){return P("readSync")}readToGPU(pe,ee){return P("readToGPU")}numDataIds(){return P("numDataIds")}disposeData(pe,ee){return P("disposeData")}write(pe,ee,we){return P("write")}move(pe,ee,we,xe,K){return P("move")}createTensorFromGPUData(pe,ee,we){return P("createTensorFromGPUData")}memory(){return P("memory")}floatPrecision(){return P("floatPrecision")}epsilon(){return this.floatPrecision()===32?p:ze}dispose(){return P("dispose")}}function P(W){throw new Error(`'${W}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},8135:function(Wt,dt,L){"use strict";L.d(dt,{GP:()=>P,pA:()=>pe,qP:()=>W});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p(_,De,Fe){const Ke=ze(_,De,Fe),rt=Ke<0?-(Ke+1):Ke;_.splice(rt,0,De)}function ze(_,De,Fe){return ie(_,De,Fe||Z)}function Z(_,De){return _>De?1:_<De?-1:0}function ie(_,De,Fe){let Ke=0,rt=_.length,ht=0,Vt=!1;for(;Ke<rt;){ht=Ke+(rt-Ke>>>1);const on=Fe(De,_[ht]);on>0?Ke=ht+1:(rt=ht,Vt=!on)}return Vt?Ke:-Ke-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P(_,De,Fe,Ke,rt){return ee(_,De,Fe,Ke,rt,0)}function W(_,De,Fe,Ke,rt,ht){return ee(_,De,Fe,Ke,rt,0,!1,ht,!0)}function pe(_,De,Fe,Ke,rt,ht){return ee(_,De,Fe,Ke,rt,ht,!0)}function ee(_,De,Fe,Ke,rt,ht,Vt=!1,on=!1,$t=!1){const ve=[];for(let Be=0;Be<De.length;Be++)De[Be]>rt&&ve.push({score:De[Be],boxIndex:Be,suppressBeginIndex:0});ve.sort(K);const y=ht>0?-.5/ht:0,Qe=[],V=[];for(;Qe.length<Fe&&ve.length>0;){const Be=ve.pop(),{score:at,boxIndex:S,suppressBeginIndex:nt}=Be;if(at<rt)break;let ne=!1;for(let Ne=Qe.length-1;Ne>=nt;--Ne){const Ve=we(_,S,Qe[Ne]);if(Ve>=Ke){ne=!0;break}if(Be.score=Be.score*xe(Ke,y,Ve),Be.score<=rt)break}Be.suppressBeginIndex=Qe.length,ne||(Be.score===at?(Qe.push(S),V.push(Be.score)):Be.score>rt&&p(ve,Be,K))}const re=Qe.length,G=Fe-re;on&&G>0&&(Qe.push(...new Array(G).fill(0)),V.push(...new Array(G).fill(0)));const Re={selectedIndices:Qe};return Vt&&(Re.selectedScores=V),$t&&(Re.validOutputs=re),Re}function we(_,De,Fe){const Ke=_.subarray(De*4,De*4+4),rt=_.subarray(Fe*4,Fe*4+4),ht=Math.min(Ke[0],Ke[2]),Vt=Math.min(Ke[1],Ke[3]),on=Math.max(Ke[0],Ke[2]),$t=Math.max(Ke[1],Ke[3]),ve=Math.min(rt[0],rt[2]),y=Math.min(rt[1],rt[3]),Qe=Math.max(rt[0],rt[2]),V=Math.max(rt[1],rt[3]),re=(on-ht)*($t-Vt),G=(Qe-ve)*(V-y);if(re<=0||G<=0)return 0;const Re=Math.max(ht,ve),Be=Math.max(Vt,y),at=Math.min(on,Qe),S=Math.min($t,V),nt=Math.max(at-Re,0)*Math.max(S-Be,0);return nt/(re+G-nt)}function xe(_,De,Fe){const Ke=Math.exp(De*Fe*Fe);return Fe<=_?Ke:0}function K(_,De){return _.score-De.score||_.score===De.score&&De.boxIndex-_.boxIndex}},9560:function(Wt,dt,L){"use strict";L.d(dt,{Z:()=>ze});var p=L(4865);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ze(Z,ie){const P=[];for(let ee=0;ee<ie.length;ee++)ie[ee]&&P.push(ee);const W=(0,p.f)(Z,"int32"),pe=(0,p.f)([P.length,Z.length],"int32");for(let ee=0;ee<P.length;ee++){const we=W.indexToLoc(P[ee]),xe=ee*Z.length;pe.values.set(we,xe)}return pe.toTensor()}},6201:function(Wt,dt,L){"use strict";L.d(dt,{BV:()=>ve,wv:()=>$t});var p=L(3993),ze=L(6650),Z=L(2360),ie=L(4403),P=L(5042),W=L(3386),pe=L(2891),ee=L(9024);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class we{constructor(V,re){this.backendTimer=V,this.logger=re,re==null&&(this.logger=new K)}profileKernel(V,re,G){let Re;const Be=()=>{Re=G()};let at;const S=pe.now();if(this.backendTimer.timerAvailable())at=this.backendTimer.time(Be);else{Be();for(const ne of Re)ne.dataSync();at=Promise.resolve({kernelMs:pe.now()-S})}if((0,ze.OB)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let ne=0;ne<Re.length;ne++){const Ne=Re[ne];Ne.data().then(Ve=>{xe(Ve,Ne.dtype,V)})}return{kernelName:V,outputs:Re,inputs:re,timeMs:at.then(ne=>ne.kernelMs),extraInfo:at.then(ne=>ne.getExtraProfileInfo!=null?ne.getExtraProfileInfo():"")}}logKernelProfile(V){const{kernelName:re,outputs:G,timeMs:Re,inputs:Be,extraInfo:at}=V;G.forEach(S=>{Promise.all([S.data(),Re,at]).then(nt=>{this.logger.logKernelProfile(re,S,nt[0],nt[1],Be,nt[2])})})}}function xe(Qe,V,re){if(V!=="float32")return!1;for(let G=0;G<Qe.length;G++){const Re=Qe[G];if(isNaN(Re)||!isFinite(Re))return console.warn(`Found ${Re} in the result of '${re}'`),!0}return!1}class K{logKernelProfile(V,re,G,Re,Be,at){const S=typeof Re=="number"?ee.oj(`${Re}ms`,9):Re.error,nt=ee.oj(V,25),ne=re.rank,Ne=re.size,Ve=ee.oj(re.shape.toString(),14);let ce="";for(const me in Be){const pt=Be[me];if(pt!=null){const ct=pt.shape||re.shape,Lt=ct.length;ce+=`${me}: ${Lt}D ${Lt>0?ct:""} `}}console.log(`%c${nt}	%c${S}	%c${ne}D ${Ve}	%c${Ne}	%c${ce}	%c${at}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _(Qe,V,re){const G={},Re={};for(let nt=0;nt<V.length;nt++)G[V[nt].id]=!0;for(let nt=0;nt<Qe.length;nt++){const ne=Qe[nt],Ne=ne.inputs;for(const Ve in Ne){const ce=Ne[Ve];let me=!1;for(let pt=0;pt<V.length;pt++)if(G[ce.id]){ne.outputs.forEach(ct=>G[ct.id]=!0),me=!0,Re[ne.id]=!0;break}if(me)break}}const Be={};Be[re.id]=!0;const at={};for(let nt=Qe.length-1;nt>=0;nt--){const ne=Qe[nt],Ne=ne.inputs;for(let Ve=0;Ve<ne.outputs.length;Ve++)if(Be[ne.outputs[Ve].id]){for(const ce in Ne)Be[Ne[ce].id]=!0,at[ne.id]=!0;break}}const S=[];for(let nt=0;nt<Qe.length;nt++){const ne=Qe[nt];if(Re[ne.id]&&at[ne.id]){const Ne={};for(const ce in ne.inputs){const me=ne.inputs[ce];G[me.id]&&(Ne[ce]=me)}const Ve=Object.assign({},ne);Ve.inputs=Ne,Ve.outputs=ne.outputs,S.push(Ve)}}return S}function De(Qe,V,re,G){for(let Re=V.length-1;Re>=0;Re--){const Be=V[Re],at=[];if(Be.outputs.forEach(nt=>{const ne=Qe[nt.id];ne!=null?at.push(ne):at.push(null)}),Be.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${Be.kernelName}.`);const S=Be.gradient(at);for(const nt in Be.inputs){if(!(nt in S))throw new Error(`Cannot backprop through input ${nt}. Available gradients found: ${Object.keys(S)}.`);const ne=re(()=>S[nt]());if(ne.dtype!=="float32")throw new Error(`Error in gradient for op ${Be.kernelName}. The gradient of input ${nt} must have 'float32' dtype, but has '${ne.dtype}'`);const Ne=Be.inputs[nt];if(!ee.cO(ne.shape,Ne.shape))throw new Error(`Error in gradient for op ${Be.kernelName}. The gradient of input '${nt}' has shape '${ne.shape}', which does not match the shape of the input '${Ne.shape}'`);if(Qe[Ne.id]==null)Qe[Ne.id]=ne;else{const Ve=Qe[Ne.id];Qe[Ne.id]=G(Ve,ne),Ve.dispose()}}}}var Fe=L(8990),Ke=L(6802);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rt(Qe){return Qe.kernelName!=null}class ht{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(V=>V.name)))}}}dispose(){for(const V in this.registeredVariables)this.registeredVariables[V].dispose()}}class Vt{constructor(V){this.ENV=V,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new ht}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const V=this.getSortedBackends();for(let re=0;re<V.length;re++){const G=V[re];if(await this.initializeBackend(G).success){await this.setBackend(G);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:V,asyncInit:re}=this.initializeBackendsAndReturnBest();if(re)throw new Error(`The highest priority backend '${V}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(V)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(V){if(!(V in this.registry))if(V in this.registryFactory){const{asyncInit:re}=this.initializeBackend(V);if(re)return null}else return null;return this.registry[V]}findBackendFactory(V){return V in this.registryFactory?this.registryFactory[V].factory:null}registerBackend(V,re,G=1){return V in this.registryFactory?(W.Z(`${V} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[V]={factory:re,priority:G},!0)}async setBackend(V){if(this.registryFactory[V]==null)throw new Error(`Backend name '${V}' not found in registry`);if(this.backendName=V,this.registry[V]==null){this.backendInstance=null;const{success:re,asyncInit:G}=this.initializeBackend(V);if(!(G?await re:re))return!1}return this.backendInstance=this.registry[V],this.setupRegisteredKernels(),this.profiler=new we(this.backendInstance),!0}setupRegisteredKernels(){(0,P.tr)(this.backendName).forEach(re=>{re.setupFunc!=null&&re.setupFunc(this.backendInstance)})}disposeRegisteredKernels(V){(0,P.tr)(V).forEach(G=>{G.disposeFunc!=null&&G.disposeFunc(this.registry[V])})}initializeBackend(V){const re=this.registryFactory[V];if(re==null)throw new Error(`Cannot initialize backend ${V}, no registration found.`);try{const G=re.factory();if(G&&!(G instanceof p.Zu)&&typeof G.then=="function"){const Re=++this.pendingBackendInitId,Be=G.then(at=>Re<this.pendingBackendInitId?!1:(this.registry[V]=at,this.pendingBackendInit=null,!0)).catch(at=>(Re<this.pendingBackendInitId||(this.pendingBackendInit=null,W.Z(`Initialization of backend ${V} failed`),W.Z(at.stack||at.message)),!1));return this.pendingBackendInit=Be,{success:Be,asyncInit:!0}}else return this.registry[V]=G,{success:!0,asyncInit:!1}}catch(G){return W.Z(`Initialization of backend ${V} failed`),W.Z(G.stack||G.message),{success:!1,asyncInit:!1}}}removeBackend(V){if(!(V in this.registryFactory))throw new Error(`${V} backend not found in registry`);this.backendName===V&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,V in this.registry&&(this.disposeRegisteredKernels(V),this.registry[V].dispose(),delete this.registry[V]),delete this.registryFactory[V],this.backendName===V&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((V,re)=>this.registryFactory[re].priority-this.registryFactory[V].priority)}initializeBackendsAndReturnBest(){const V=this.getSortedBackends();for(let re=0;re<V.length;re++){const G=V[re],{success:Re,asyncInit:Be}=this.initializeBackend(G);if(Be||Re)return{name:G,asyncInit:Be}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(V,re){const G=this.state.tensorInfo.get(re),Re=G.backend,Be=this.readSync(re),at=Re.refCount(re);Re.disposeData(re,!0),G.backend=V,V.move(re,Be,G.shape,G.dtype,at),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(V,re){let G=null;if(re==null){if(typeof V!="function")throw new Error("Please provide a function to tidy()");re=V}else{if(typeof V!="string"&&!(V instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof re!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");G=V}let Re;return this.scopedRun(()=>this.startScope(G),()=>this.endScope(Re),()=>(Re=re(),Re instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),Re))}scopedRun(V,re,G){V();try{const Re=G();return re(),Re}catch(Re){throw re(),Re}}nextTensorId(){return Vt.nextTensorId++}nextVariableId(){return Vt.nextVariableId++}clone(V){const re=ve.runKernel(ie.iJz,{x:V}),G={x:V},Re=at=>({x:()=>{const S="float32",nt={x:at},ne={dtype:S};return ve.runKernel(ie.RFZ,nt,ne)}}),Be=[];return this.addTapeNode(this.state.activeScope.name,G,[re],Re,Be,{}),re}runKernel(V,re,G){if(this.backendName==null&&this.backend,!((0,P.pI)(V,this.backendName)!=null))throw new Error(`Kernel '${V}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:V,inputs:re,attrs:G})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(V,re,G){const Re=this.backend.numDataIds();let Be=0;G.forEach(nt=>{Be+=nt.dtype==="complex64"?3:1});const at=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],S=Re-re-Be-at;if(S>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${S} data ids) after running '${V}'`)}runKernelFunc(V){let re,G=[];const Re=this.isTapeOn(),Be=this.state.numBytes,at=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let S;this.backendName==null&&this.backend;let nt;const ne=rt(V)?V.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(rt(V)){const{kernelName:pt,inputs:ct,attrs:Lt}=V;this.backendName==null&&this.backend;const Nt=(0,P.pI)(pt,this.backendName);ee.hu(Nt!=null,()=>`Cannot find registered kernel '${pt}' for backend '${this.backendName}'`),S=()=>{const ln=this.backend.numDataIds();nt=Nt.kernelFunc({inputs:ct,attrs:Lt,backend:this.backend});const Sn=Array.isArray(nt)?nt:[nt];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(pt,ln,Sn);const tn=Sn.map(kn=>kn.rank!=null?kn:this.makeTensorFromTensorInfo(kn));if(Re){const kn=this.getTensorsForGradient(pt,ct,tn);G=this.saveTensorsForBackwardMode(kn)}return tn}}else{const{forwardFunc:pt}=V,ct=Lt=>{Re&&(G=Lt.map(Nt=>this.keep(this.clone(Nt))))};S=()=>{const Lt=this.backend.numDataIds();nt=this.tidy(()=>pt(this.backend,ct));const Nt=Array.isArray(nt)?nt:[nt];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(ne,Lt,Nt),Nt}}const{inputs:Ne,attrs:Ve}=V,ce=rt(V)?null:V.backwardsFunc;let me;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?re=S():(me=this.profiler.profileKernel(ne,Ne,()=>S()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(me),re=me.outputs)}),Re&&this.addTapeNode(ne,Ne,re,ce,G,Ve),this.state.profiling&&this.state.activeProfile.kernels.push({name:ne,bytesAdded:this.state.numBytes-Be,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-at,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(Ne).map(pt=>Ne[pt]!=null?Ne[pt].shape:null),outputShapes:re.map(pt=>pt.shape),kernelTimeMs:me.timeMs,extraInfo:me.extraInfo}),Array.isArray(nt)?re:re[0]}saveTensorsForBackwardMode(V){return V.map(G=>this.keep(this.clone(G)))}getTensorsForGradient(V,re,G){const Re=(0,P.uk)(V);if(Re!=null){const Be=Re.inputsToSave||[],at=Re.outputsToSave||[];let S;Re.saveAllInputs?(ee.hu(Array.isArray(re),()=>"saveAllInputs is true, expected inputs to be an array."),S=Object.keys(re).map(ne=>re[ne])):S=Be.map(ne=>re[ne]);const nt=G.filter((ne,Ne)=>at[Ne]);return S.concat(nt)}return[]}makeTensor(V,re,G,Re){if(V==null)throw new Error("Values passed to engine.makeTensor() are null");G=G||"float32",Re=Re||this.backend;let Be=V;G==="string"&&ee.HD(V[0])&&(Be=V.map(nt=>pe.encodeString(nt)));const at=Re.write(Be,re,G),S=new Fe.es(re,G,at,this.nextTensorId());if(this.trackTensor(S,Re),G==="string"){const nt=this.state.tensorInfo.get(at),ne=(0,ee.Ub)(Be);this.state.numBytes+=ne-nt.bytes,nt.bytes=ne}return S}makeTensorFromDataId(V,re,G,Re){G=G||"float32";const Be={dataId:V,shape:re,dtype:G};return this.makeTensorFromTensorInfo(Be,Re)}makeTensorFromTensorInfo(V,re){const{dataId:G,shape:Re,dtype:Be}=V,at=new Fe.es(Re,Be,G,this.nextTensorId());return this.trackTensor(at,re),at}makeVariable(V,re=!0,G,Re){G=G||this.nextVariableId().toString(),Re!=null&&Re!==V.dtype&&(V=V.cast(Re));const Be=new Fe._w(V,re,G,this.nextTensorId());if(this.state.registeredVariables[Be.name]!=null)throw new Error(`Variable with name ${Be.name} was already registered`);return this.state.registeredVariables[Be.name]=Be,this.incRef(Be,this.backend),Be}trackTensor(V,re){this.state.numTensors++,V.dtype==="string"&&this.state.numStringTensors++;let G=0;V.dtype!=="complex64"&&V.dtype!=="string"&&(G=V.size*ee.bT(V.dtype)),this.state.numBytes+=G,this.state.tensorInfo.has(V.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(V.dataId,{backend:re||this.backend,dtype:V.dtype,shape:V.shape,bytes:G})),V instanceof Fe._w||this.track(V)}incRef(V,re){this.trackTensor(V,re),this.backend.incRef(V.dataId)}removeDataId(V,re){this.state.tensorInfo.has(V)&&this.state.tensorInfo.get(V).backend===re&&(this.state.tensorInfo.delete(V),this.state.numDataBuffers--)}disposeTensor(V){if(!this.state.tensorInfo.has(V.dataId))return;const re=this.state.tensorInfo.get(V.dataId);if(this.state.numTensors--,V.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=re.bytes),V.dtype!=="complex64"&&V.dtype!=="string"){const G=V.size*ee.bT(V.dtype);this.state.numBytes-=G}re.backend.disposeData(V.dataId)&&this.removeDataId(V.dataId,re.backend)}disposeVariables(){for(const V in this.state.registeredVariables){const re=this.state.registeredVariables[V];this.disposeVariable(re)}}disposeVariable(V){this.disposeTensor(V),this.state.registeredVariables[V.name]!=null&&delete this.state.registeredVariables[V.name]}memory(){const V=this.backend.memory();return V.numTensors=this.state.numTensors,V.numDataBuffers=this.state.numDataBuffers,V.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(V.unreliable=!0,V.reasons==null&&(V.reasons=[]),V.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),V}async profile(V){this.state.profiling=!0;const re=this.state.numBytes,G=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await V(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(Re=>Re.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-re,this.state.activeProfile.newTensors=this.state.numTensors-G;for(const Re of this.state.activeProfile.kernels)Re.kernelTimeMs=await Re.kernelTimeMs,Re.extraInfo=await Re.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(V,re,G,Re,Be,at){const S={id:this.state.nextTapeNodeId++,kernelName:V,inputs:re,outputs:G,saved:Be},nt=(0,P.uk)(V);nt!=null&&(Re=nt.gradFunc),Re!=null&&(S.gradient=ne=>(ne=ne.map((Ne,Ve)=>{if(Ne==null){const ce=G[Ve],me=ee.wT(ce.size,ce.dtype);return this.makeTensor(me,ce.shape,ce.dtype)}return Ne}),Re(ne.length>1?ne:ne[0],Be,at))),this.state.activeTape.push(S)}keep(V){return V.kept=!0,V}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(V){const re={track:[],name:"unnamed scope",id:this.state.nextScopeId++};V&&(re.name=V),this.state.scopeStack.push(re),this.state.activeScope=re}endScope(V){const re=(0,Ke.Vu)(V),G=new Set(re.map(Be=>Be.id));for(let Be=0;Be<this.state.activeScope.track.length;Be++){const at=this.state.activeScope.track[Be];!at.kept&&!G.has(at.id)&&at.dispose()}const Re=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],re.forEach(Be=>{!Be.kept&&Be.scopeId===Re.id&&this.track(Be)})}gradients(V,re,G,Re=!1){if(ee.hu(re.length>0,()=>"gradients() received an empty list of xs."),G!=null&&G.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${G.dtype}'`);const Be=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",V));ee.hu(Be instanceof Fe.es,()=>"The result y returned by f() must be a tensor.");const at=_(this.state.activeTape,re,Be);if(!Re&&at.length===0&&re.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const S={};S[Be.id]=G??on(Be.shape),De(S,at,ne=>this.tidy(ne),y);const nt=re.map(ne=>S[ne.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(ne=>{for(const Ne of ne.saved)Ne.dispose()}),this.state.activeTape=null),{value:Be,grads:nt}})}customGrad(V){return ee.hu(ee.mf(V),()=>"The f passed in customGrad(f) must be a function."),(...re)=>{ee.hu(re.every(S=>S instanceof Fe.es),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let G;const Re={};re.forEach((S,nt)=>{Re[nt]=S});const Be=(S,nt)=>(G=V(...re,nt),ee.hu(G.value instanceof Fe.es,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),ee.hu(ee.mf(G.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),G.value),at=(S,nt)=>{const ne=G.gradFunc(S,nt),Ne=Array.isArray(ne)?ne:[ne];ee.hu(Ne.length===re.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),ee.hu(Ne.every(ce=>ce instanceof Fe.es),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const Ve={};return Ne.forEach((ce,me)=>{Ve[me]=()=>ce}),Ve};return this.runKernelFunc({forwardFunc:Be,backwardsFunc:at,inputs:Re})}}readSync(V){return this.state.tensorInfo.get(V).backend.readSync(V)}read(V){return this.state.tensorInfo.get(V).backend.read(V)}readToGPU(V,re){return this.state.tensorInfo.get(V).backend.readToGPU(V,re)}async time(V){const re=(0,pe.now)(),G=await this.backend.time(V);return G.wallMs=(0,pe.now)()-re,G}track(V){return this.state.activeScope!=null&&(V.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(V)),V}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new ht;for(const V in this.registry)this.disposeRegisteredKernels(V),this.registry[V].dispose(),delete this.registry[V];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Vt.nextTensorId=0,Vt.nextVariableId=0;function on(Qe){const V=(0,ee.p8)((0,ee.NA)(Qe),"float32");return ve.makeTensor(V,Qe,"float32")}function $t(){const Qe=(0,Z.D)();if(Qe._tfengine==null){const V=new ze.qA(Qe);Qe._tfengine=new Vt(V)}return(0,ze.iG)(Qe._tfengine.ENV),(0,Fe.Vi)(()=>Qe._tfengine),Qe._tfengine}const ve=$t();function y(Qe,V){const re={a:Qe,b:V};return ve.runKernel(ie.mm_,re)}},6650:function(Wt,dt,L){"use strict";L.d(dt,{OB:()=>pe,iG:()=>we,qA:()=>Z});var p=L(9024);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ze="tfjsflags";class Z{constructor(K){this.global=K,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=ie,this.populateURLFlags()}setPlatform(K,_){this.platform!=null&&(pe().getBool("IS_TEST")||pe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${K}.`)),this.platformName=K,this.platform=_}registerFlag(K,_,De){if(this.flagRegistry[K]={evaluationFn:_,setHook:De},this.urlFlags[K]!=null){const Fe=this.urlFlags[K];pe().getBool("IS_TEST")||pe().getBool("PROD")||console.warn(`Setting feature override from URL ${K}: ${Fe}.`),this.set(K,Fe)}}async getAsync(K){return K in this.flags?this.flags[K]:(this.flags[K]=await this.evaluateFlag(K),this.flags[K])}get(K){if(K in this.flags)return this.flags[K];const _=this.evaluateFlag(K);if((0,p.tI)(_))throw new Error(`Flag ${K} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[K]=_,this.flags[K]}getNumber(K){return this.get(K)}getBool(K){return this.get(K)}getString(K){return this.get(K)}getFlags(){return this.flags}get features(){return this.flags}set(K,_){if(this.flagRegistry[K]==null)throw new Error(`Cannot set flag ${K} as it has not been registered.`);this.flags[K]=_,this.flagRegistry[K].setHook!=null&&this.flagRegistry[K].setHook(_)}evaluateFlag(K){if(this.flagRegistry[K]==null)throw new Error(`Cannot evaluate flag '${K}': no evaluation function found.`);return this.flagRegistry[K].evaluationFn()}setFlags(K){this.flags=Object.assign({},K)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const K=this.getQueryParams(this.global.location.search);ze in K&&K[ze].split(",").forEach(De=>{const[Fe,Ke]=De.split(":");this.urlFlags[Fe]=W(Fe,Ke)})}}function ie(xe){const K={};return xe.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(_,...De)=>(P(K,De[0],De[1]),De.join("="))),K}function P(xe,K,_){xe[decodeURIComponent(K)]=decodeURIComponent(_||"")}function W(xe,K){const _=K.toLowerCase();return _==="true"||_==="false"?_==="true":`${+_}`===_?+_:K}function pe(){return ee}let ee=null;function we(xe){ee=xe}},2360:function(Wt,dt,L){"use strict";L.d(dt,{D:()=>ze,R:()=>ie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let p;function ze(){if(p==null){let P;if(typeof window<"u")P=window;else if(typeof L.g<"u")P=L.g;else if(typeof process<"u")P=process;else if(typeof self<"u")P=self;else throw new Error("Could not find a global object");p=P}return p}function Z(){const P=ze();return P._tfGlobals==null&&(P._tfGlobals=new Map),P._tfGlobals}function ie(P,W){const pe=Z();if(pe.has(P))return pe.get(P);{const ee=W();return pe.set(P,ee),pe.get(P)}}},4531:function(Wt,dt,L){"use strict";L.d(dt,{B9:()=>Fe,CQ:()=>ht,Cn:()=>Ke,N_:()=>on,SR:()=>xe,jq:()=>Qe,lu:()=>De,y3:()=>V});var p=L(6201),ze=L(6650),Z=L(8990),ie=L(6802);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P(){env().set("PROD",!0)}function W(){env().set("DEBUG",!0)}function pe(){env().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function ee(G){(0,ze.OB)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(G+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}(0,Z.FZ)(ee);function we(){ENGINE.disposeVariables()}function xe(){return p.BV}function K(){return ENGINE.memory()}function _(G){return ENGINE.profile(G)}function De(G,Re){return p.BV.tidy(G,Re)}function Fe(G){(0,ie.Vu)(G).forEach(Be=>Be.dispose())}function Ke(G){return p.BV.keep(G)}function rt(G){return ENGINE.time(G)}function ht(G){return p.BV.setBackend(G)}function Vt(){return ENGINE.ready()}function on(){return p.BV.backendName}function $t(G){ENGINE.removeBackend(G)}function ve(G){return ENGINE.findBackend(G)}function y(G){return ENGINE.findBackendFactory(G)}function Qe(G,Re,Be=1){return p.BV.registerBackend(G,Re,Be)}function V(){return p.BV.backend}function re(G,Re){env().setPlatform(G,Re)}},4233:function(Wt,dt,L){"use strict";L.d(dt,{cb:()=>we,pn:()=>ee});var p=L(6201),ze=L(8990),Z=L(9024);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ie(K){return util.assert(util.isFunction(K),()=>"The f passed in grad(f) must be a function"),(_,De)=>{const Fe=convertToTensor(_,"x","tf.grad","string_or_numeric"),Ke=De!=null?convertToTensor(De,"dy","tf.grad"):null;return ENGINE.tidy(()=>{const{value:rt,grads:ht}=ENGINE.gradients(()=>K(Fe),[Fe],Ke);return Ke!=null&&util.assertShapesMatch(rt.shape,Ke.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),xe(ht),ht[0]})}}function P(K){return util.assert(util.isFunction(K),()=>"The f passed in grads(f) must be a function"),(_,De)=>{util.assert(Array.isArray(_),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const Fe=convertToTensorArray(_,"args","tf.grads","string_or_numeric"),Ke=De!=null?convertToTensor(De,"dy","tf.grads"):null;return ENGINE.tidy(()=>{const{value:rt,grads:ht}=ENGINE.gradients(()=>K(...Fe),Fe,Ke);return Ke!=null&&util.assertShapesMatch(rt.shape,Ke.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),xe(ht),ht})}}function W(K){return util.assert(util.isFunction(K),()=>"The f passed in valueAndGrad(f) must be a function"),(_,De)=>{util.assert(_ instanceof Tensor,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),util.assert(De==null||De instanceof Tensor,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:Fe,value:Ke}=ENGINE.gradients(()=>K(_),[_],De);return xe(Fe),{grad:Fe[0],value:Ke}}}function pe(K){return util.assert(util.isFunction(K),()=>"The f passed in valueAndGrads(f) must be a function"),(_,De)=>{util.assert(Array.isArray(_)&&_.every(Ke=>Ke instanceof Tensor),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),util.assert(De==null||De instanceof Tensor,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const Fe=ENGINE.gradients(()=>K(..._),_,De);return De!=null&&util.assertShapesMatch(Fe.value.shape,De.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),xe(Fe.grads),Fe}}function ee(K,_){Z.hu(Z.mf(K),()=>"The f passed in variableGrads(f) must be a function"),Z.hu(_==null||Array.isArray(_)&&_.every($t=>$t instanceof ze._w),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const De=_!=null;if(!De){_=[];for(const $t in p.BV.registeredVariables)_.push(p.BV.registeredVariables[$t])}const Fe=De?_.filter($t=>!$t.trainable):null,Ke=_.length;_=_.filter($t=>$t.trainable),Z.hu(_.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${Ke} variables is trainable.`);const rt=!0,{value:ht,grads:Vt}=p.BV.gradients(K,_,null,rt);Z.hu(Vt.some($t=>$t!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),Z.hu(ht.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${ht.rank} tensor`);const on={};return _.forEach(($t,ve)=>{Vt[ve]!=null&&(on[$t.name]=Vt[ve])}),Fe?.forEach($t=>on[$t.name]=null),{value:ht,grads:on}}function we(K){return p.BV.customGrad(K)}function xe(K){if(K.filter(De=>De==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}},9677:function(Wt,dt,L){"use strict";L.d(dt,{GBy:()=>Ye.GBy,VdP:()=>Wn.VdP,lub:()=>mn.lu,XD2:()=>Wn.XD2,h62:()=>Wn.h62,y7R:()=>Ye.y7R,CAk:()=>Ye.CAk,Zz9:()=>Ye.Zz9,iD$:()=>Wn.iD$,glt:()=>Fo,Oyi:()=>Ye.Oyi,dC7:()=>Wn.dC7,hdR:()=>Ye.hdR,qi_:()=>Ye.qi_,eZ0:()=>Ye.eZ0,zvY:()=>Ye.zvY,XeE:()=>Wn.XeE,cye:()=>Ye.cye,zws:()=>Ye.zws,J$2:()=>Ye.J$2,y3$:()=>mn.y3,HHK:()=>Wn.HHK,RuY:()=>Ye.RuY,zbQ:()=>Ye.zbQ,esB:()=>Ps.es,OU7:()=>Ye.OU7,tPi:()=>Wn.tPi,B90:()=>mn.B9,Qqt:()=>Wn.Qqt,aJk:()=>Ye.aJk,Xze:()=>Ye.Xze,Jyw:()=>Mr,ZbH:()=>Ye.ZbH,IHx:()=>Wn.IHx,z4k:()=>zr.z4,JLz:()=>Ya.JL,SRH:()=>mn.SR,D5U:()=>co,vtC:()=>Ye.vtC,avt:()=>Ye.avt,iHb:()=>Ye.iHb,luU:()=>Wn.luU,kuN:()=>ie,d9v:()=>Wn.d9v,Hmb:()=>Ye.Hmb,sEM:()=>Ye.sEM,usg:()=>Ye.usg,kU:()=>Ye.kU,hCO:()=>Ye.hCO,XLW:()=>Ye.XLW,dpD:()=>Ye.dpD,$g6:()=>Ye.$g6,qkr:()=>Ye.qkr,xJR:()=>Ye.xJR,qWM:()=>Ye.qWM,CnY:()=>mn.Cn,oT6:()=>Ye.oT6,bV0:()=>Ye.bV0,DlI:()=>Ye.DlI,T0n:()=>Ye.T0n,luS:()=>Ye.luS,XkS:()=>Ye.XkS,vFR:()=>Ye.vFR,Wap:()=>W,SX0:()=>Ye.SX0,dt4:()=>Wn.dt4,zoF:()=>Wn.zoF,$HU:()=>Ye.$HU,$w:()=>Ye.$w,Hhh:()=>Ye.Hhh,LTh:()=>Wn.LTh,x8V:()=>zr.x8,_JP:()=>Ye._JP,VGw:()=>Ye.VGw,Zuw:()=>Ya.Zu,L8s:()=>Ye.L8s,xnO:()=>Ye.xnO,C2$:()=>p,MIZ:()=>Ye.MIZ,q8u:()=>Ye.q8u,vwp:()=>Ye.vwp,L9e:()=>Wn.L9e,wCN:()=>Ir.wC,oFR:()=>Ye.oFR,GDt:()=>pe,Byc:()=>Ye.Byc,e7N:()=>Ye.e7N,O3z:()=>Ye.O3z,NEP:()=>Ye.NEP,pju:()=>Wn.pju,RRF:()=>Wn.RRF,Y0y:()=>Ye.Y0y,OV7:()=>Ye.OV7,FKq:()=>Ye.FKq,JhU:()=>Ye.JhU,NZg:()=>Ye.NZg,cWu:()=>Ye.cWu,mc4:()=>Ye.mc4,Xhn:()=>Z,SpW:()=>Ye.SpW,lyA:()=>Ye.lyA,HZH:()=>Ye.HZH,UFq:()=>Wn.UFq,Gcp:()=>Ye.Gcp,hGc:()=>Ye.hGc,_k9:()=>Ye._k9,ROF:()=>Ye.ROF,eEB:()=>Ye.eEB,i5y:()=>Ye.i5y,q1x:()=>Ye.q1x,c17:()=>Ye.c17,dDz:()=>Ye.dDz,knu:()=>Wn.knu,YDk:()=>Ps.YD,kpP:()=>Ye.kpP,PYm:()=>Ye.PYm,p2w:()=>Ye.p2w,XLQ:()=>Wn.XLQ,jqO:()=>mn.jq,jQs:()=>Ye.jQs,e6w:()=>Ye.e6w,qw7:()=>Ye.qw7,YoZ:()=>Ye.YoZ,oHH:()=>Ye.oHH,odF:()=>Wn.odF,sHE:()=>Ye.sHE,o2y:()=>Ye.o2y,iWB:()=>Ye.iWB,q2K:()=>Ye.q2K,CQl:()=>Ye.CQl,w3H:()=>Ye.w3H,h8e:()=>Ye.h8e,RFZ:()=>Ye.RFZ,MZg:()=>Ye.MZg,iJz:()=>Ye.iJz,VfG:()=>Ye.VfG,QiL:()=>Ye.QiL,SIB:()=>Ye.SIB,iZT:()=>Ye.iZT,_Yw:()=>Ye._Yw,HEU:()=>Ye.HEU,Qg5:()=>Ye.Qg5,sJF:()=>Ye.sJF,gJX:()=>Ye.gJX,SYM:()=>Ye.SYM,yQU:()=>Ye.yQU,TR1:()=>Ye.TR1,Omj:()=>Ye.Omj,OR:()=>Ye.OR,W0H:()=>Ye.W0H,Vbg:()=>Ye.Vbg,Acj:()=>Ye.Acj,n9L:()=>Ye.n9L,BMI:()=>Ye.BMI,r7n:()=>Ye.r7n,ik2:()=>Ye.ik2,_V0:()=>Ye._V0,PhF:()=>Ye.PhF,jeX:()=>Ye.jeX,wYn:()=>Ye.wYn,bK0:()=>Ye.bK0,kuV:()=>Ye.kuV,vku:()=>Wn.vku,io:()=>ze,N_N:()=>mn.N_,lls:()=>Wn.lls,MRv:()=>Ye.MRv,SbG:()=>Ye.SbG,iUl:()=>Wn.iUl,xQA:()=>Ye.xQA,TQc:()=>Ye.TQc,we_:()=>Ye.we_,b9H:()=>Ye.b9H,_tC:()=>Ye._tC,o0g:()=>Ye.o0g,CQI:()=>mn.CQ,e07:()=>Ye.e07,QCc:()=>Ye.QCc,VcC:()=>Ye.VcC,IMb:()=>Ye.IMb,Vn9:()=>Ye.Vn9,jMg:()=>Ye.jMg,G3Y:()=>Ye.G3Y,a5O:()=>Ye.a5O,nr8:()=>Ye.nr8,yj2:()=>Ye.yj2,IKK:()=>Ye.IKK,uv1:()=>Ye.uv1,OAf:()=>Ye.OAf,nhH:()=>Ye.nhH,Qvg:()=>Ye.Qvg,wx7:()=>Ye.wx7,deh:()=>Ye.deh,x12:()=>Ye.x12,hiC:()=>Wn.hiC,s1s:()=>Ye.s1s,NqF:()=>Wn.NqF,YFo:()=>Ye.YFo,wm:()=>Ye.wm,BiW:()=>Ye.BiW,jQk:()=>Ye.jQk,ToN:()=>Ye.ToN,pe_:()=>Ye.pe_,Uyb:()=>Ye.Uyb,ekb:()=>Ye.ekb,Eh3:()=>Ye.Eh3,D2d:()=>Ye.D2d,p4S:()=>Ye.p4S,eBW:()=>Ye.eBW,J_u:()=>Ye.J_u,mm_:()=>Ye.mm_,M2y:()=>Ye.M2y,mTV:()=>Ye.mTV,BHj:()=>Wn.BHj,f3b:()=>Wn.f3b,wYB:()=>Ye.wYB,cie:()=>Ye.cie,mhS:()=>Ye.mhS,QRR:()=>Ye.QRR,ZjV:()=>Ye.ZjV,e0R:()=>Ye.e0R,sL$:()=>Ye.sL$,mKl:()=>Ye.mKl,Tr8:()=>Ye.Tr8,OBj:()=>Fe.OB,wUP:()=>Ye.wUP,RQH:()=>Ye.RQH});var p={};L.r(p),L.d(p,{isBrowser:()=>De,isMobile:()=>_,mockIsMobile:()=>K});var ze={};L.r(ze),L.d(ze,{CompositeArrayBuffer:()=>y.w,browserFiles:()=>ms,browserHTTPRequest:()=>fs,concatenateArrayBuffers:()=>rt.JY,copyModel:()=>As,decodeWeights:()=>rt.dI,decodeWeightsStream:()=>rt.r,encodeWeights:()=>rt.yz,fromMemory:()=>ar,fromMemorySync:()=>nr,getLoadHandlers:()=>ve,getModelArtifactsForJSON:()=>rt.jN,getModelArtifactsForJSONSync:()=>rt.ji,getModelArtifactsInfoForJSON:()=>rt.Q,getSaveHandlers:()=>$t,getWeightSpecs:()=>rt.hu,http:()=>Ss,isHTTPScheme:()=>Lr,listModels:()=>Kn,loadWeights:()=>zo,moveModel:()=>_r,registerLoadRouter:()=>on,registerSaveRouter:()=>Vt,removeModel:()=>Us,weightsLoaderFactory:()=>vo,withSaveHandler:()=>ir,withSaveHandlerSync:()=>So});var Z={};L.r(Z),L.d(Z,{draw:()=>st,fromPixels:()=>ut,fromPixelsAsync:()=>Pe,toPixels:()=>Oe});var ie={};L.r(ie),L.d(ie,{assertParamsValid:()=>At,computeFlatOffset:()=>Tr,computeOutShape:()=>Qt,getNormalizedAxes:()=>fn,isSliceContinous:()=>kt,maskToAxes:()=>xt,parseSliceParams:()=>Vr,sliceInfo:()=>lo,startForAxis:()=>Cn,startIndicesWithElidedDims:()=>pn,stopForAxis:()=>Hn,stopIndicesWithElidedDims:()=>Pn,stridesForAxis:()=>Jt,stridesWithElidedDims:()=>gt});var P={};L.r(P),L.d(P,{collectGatherOpShapeInfo:()=>No,computeOutShape:()=>di,segOpComputeOptimalWindowSize:()=>ci});var W={};L.r(W),L.d(W,{ERF_A1:()=>ge,ERF_A2:()=>ke,ERF_A3:()=>Ie,ERF_A4:()=>He,ERF_A5:()=>lt,ERF_P:()=>Q,PARALLELIZE_THRESHOLD:()=>ta,RowPartitionType:()=>$r,SELU_SCALE:()=>A,SELU_SCALEALPHA:()=>N,applyActivation:()=>Eo.QH,assertAndGetBroadcastShape:()=>Mr.assertAndGetBroadcastShape,assertAxesAreInnerMostDims:()=>lr.lB,assertParamsConsistent:()=>Go,assignToTypedArray:()=>Tn,axesAreInnerMostDims:()=>lr.YB,calculateShapes:()=>h.SU,checkEinsumDimSizes:()=>Ta,checkPadOnDimRoundingMode:()=>Rs.m,combineLocations:()=>lr.Vh,combineRaggedTensorToTensorShapes:()=>Bo,complexWithEvenIndex:()=>an,complexWithOddIndex:()=>Xt,computeConv2DInfo:()=>Rs.Ix,computeConv3DInfo:()=>Rs.jw,computeDefaultPad:()=>Rs.aO,computeDilation2DInfo:()=>Rs.Rf,computeOptimalWindowSize:()=>To,computeOutAndReduceShapes:()=>lr.kz,computeOutShape:()=>Ho,computePool2DInfo:()=>Rs.Xw,computePool3DInfo:()=>Rs.pl,convertConv2DDataFormat:()=>Rs.sl,decodeEinsumEquation:()=>Es,eitherStridesOrDilationsAreOne:()=>Rs.jT,expandShapeToKeepDim:()=>lr.rv,exponent:()=>Yn,exponents:()=>ss,fromStringArrayToUint8:()=>Xa,fromUint8ToStringArray:()=>hi,getAxesPermutation:()=>lr.Q3,getBroadcastDims:()=>Mr.getBroadcastDims,getComplexWithIndex:()=>xn,getEinsumComputePath:()=>$a,getEinsumPermutation:()=>os,getFusedBiasGradient:()=>Eo.pf,getFusedDyActivation:()=>Eo.Fr,getImageCenter:()=>ma,getInnerMostAxes:()=>lr.sY,getPermuted:()=>Nr,getRaggedRank:()=>Ha,getReductionAxes:()=>Mr.getReductionAxes,getReshaped:()=>Gt,getReshapedPermuted:()=>ga,getRowPartitionTypesHelper:()=>ho,getSliceBeginCoords:()=>mr,getSliceSize:()=>gr,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>kr,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Ko,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>ii,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>ja,getSparseReshapeInputOutputMismatchErrorMessage:()=>yr,getSparseReshapeInputOutputMultipleErrorMessage:()=>Yr,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Na,getSparseReshapeNegativeOutputDimErrorMessage:()=>Ft,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>li,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>ui,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Ka,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Vi,getUndoAxesPermutation:()=>lr.LJ,isIdentityPermutation:()=>ya,log:()=>Rt.c,mergeRealAndImagArrays:()=>zt,prepareAndValidate:()=>na,prepareSplitSize:()=>$o,segment_util:()=>P,shouldFuse:()=>Eo.uy,slice_util:()=>ie,splitRealAndImagArrays:()=>yn,stridesOrDilationsArePositive:()=>Rs.U3,tupleValuesAreOne:()=>Rs.I0,upcastType:()=>zr.x8,validateDefaultValueShape:()=>Ut,validateInput:()=>h.b0,validateUpdateShape:()=>h.l5,warn:()=>Rt.Z});var pe={};L.r(pe),L.d(pe,{nonMaxSuppressionV3Impl:()=>ka.GP,nonMaxSuppressionV4Impl:()=>ka.qP,nonMaxSuppressionV5Impl:()=>ka.pA,whereImpl:()=>pi.Z});var ee=L(6201);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function we(){return typeof navigator<"u"&&navigator!=null}let xe;function K(U){xe=U}function _(U){if(xe!==void 0)return xe;if(U||we()){if(U||(U=navigator),U.product==="ReactNative")return!0;const E=U.userAgent||U.vendor||(typeof window<"u"?window.opera:"");if(!E){const z=U;return z.userAgentData&&z.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(E)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(E.substr(0,4))}return!1}function De(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var Fe=L(6650);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ke=(0,Fe.OB)();Ke.registerFlag("DEBUG",()=>!1,U=>{U&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),Ke.registerFlag("IS_BROWSER",()=>De()),Ke.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),Ke.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),Ke.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),Ke.registerFlag("PROD",()=>!1),Ke.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Ke.getBool("DEBUG")),Ke.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),Ke.registerFlag("IS_TEST",()=>!1),Ke.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Ke.getBool("DEBUG")),Ke.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),Ke.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),Ke.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);var rt=L(1146);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ht{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return ht.instance==null&&(ht.instance=new ht),ht.instance}static registerSaveRouter(E){ht.getInstance().saveRouters.push(E)}static registerLoadRouter(E){ht.getInstance().loadRouters.push(E)}static getSaveHandlers(E){return ht.getHandlers(E,"save")}static getLoadHandlers(E,z){return ht.getHandlers(E,"load",z)}static getHandlers(E,z,q){const se=[];return(z==="load"?ht.getInstance().loadRouters:ht.getInstance().saveRouters).forEach(Me=>{const et=Me(E,q);et!==null&&se.push(et)}),se}}const Vt=U=>ht.registerSaveRouter(U),on=U=>ht.registerLoadRouter(U),$t=U=>ht.getSaveHandlers(U),ve=(U,E)=>ht.getLoadHandlers(U,E);var y=L(4028);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qe="tensorflowjs",V=1,re="models_store",G="model_info_store";async function Re(){const U=Be();return new Promise((E,z)=>{const q=U.deleteDatabase(Qe);q.onsuccess=()=>E(),q.onerror=se=>z(se)})}function Be(){if(!(0,Fe.OB)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const U=typeof window>"u"?self:window,E=U.indexedDB||U.mozIndexedDB||U.webkitIndexedDB||U.msIndexedDB||U.shimIndexedDB;if(E==null)throw new Error("The current browser does not appear to support IndexedDB.");return E}function at(U){const E=U.result;E.createObjectStore(re,{keyPath:"modelPath"}),E.createObjectStore(G,{keyPath:"modelPath"})}class S{constructor(E){if(this.indexedDB=Be(),E==null||!E)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=E}async save(E){if(E.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,E)}async load(){return this.databaseAction(this.modelPath)}databaseAction(E,z){return new Promise((q,se)=>{const _e=this.indexedDB.open(Qe,V);_e.onupgradeneeded=()=>at(_e),_e.onsuccess=()=>{const Me=_e.result;if(z==null){const et=Me.transaction(re,"readonly"),It=et.objectStore(re).get(this.modelPath);It.onsuccess=()=>{if(It.result==null)return Me.close(),se(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));q(It.result.modelArtifacts)},It.onerror=sn=>(Me.close(),se(It.error)),et.oncomplete=()=>Me.close()}else{z.weightData=y.w.join(z.weightData);const et=(0,rt.Q)(z),bt=Me.transaction(G,"readwrite");let It=bt.objectStore(G),sn;try{sn=It.put({modelPath:this.modelPath,modelArtifactsInfo:et})}catch(Tt){return se(Tt)}let _t;sn.onsuccess=()=>{_t=Me.transaction(re,"readwrite");const Tt=_t.objectStore(re);let Kt;try{Kt=Tt.put({modelPath:this.modelPath,modelArtifacts:z,modelArtifactsInfo:et})}catch($n){return se($n)}Kt.onsuccess=()=>q({modelArtifactsInfo:et}),Kt.onerror=$n=>{It=bt.objectStore(G);const qn=It.delete(this.modelPath);qn.onsuccess=()=>(Me.close(),se(Kt.error)),qn.onerror=es=>(Me.close(),se(Kt.error))}},sn.onerror=Tt=>(Me.close(),se(sn.error)),bt.oncomplete=()=>{_t==null?Me.close():_t.oncomplete=()=>Me.close()}}},_e.onerror=Me=>se(_e.error)})}}S.URL_SCHEME="indexeddb://";const nt=U=>(0,Fe.OB)().getBool("IS_BROWSER")&&!Array.isArray(U)&&U.startsWith(S.URL_SCHEME)?ne(U.slice(S.URL_SCHEME.length)):null;ht.registerSaveRouter(nt),ht.registerLoadRouter(nt);function ne(U){return new S(U)}function Ne(U){return U.startsWith(S.URL_SCHEME)?U.slice(S.URL_SCHEME.length):U}class Ve{constructor(){this.indexedDB=Be()}async listModels(){return new Promise((E,z)=>{const q=this.indexedDB.open(Qe,V);q.onupgradeneeded=()=>at(q),q.onsuccess=()=>{const se=q.result,_e=se.transaction(G,"readonly"),et=_e.objectStore(G).getAll();et.onsuccess=()=>{const bt={};for(const It of et.result)bt[It.modelPath]=It.modelArtifactsInfo;E(bt)},et.onerror=bt=>(se.close(),z(et.error)),_e.oncomplete=()=>se.close()},q.onerror=se=>z(q.error)})}async removeModel(E){return E=Ne(E),new Promise((z,q)=>{const se=this.indexedDB.open(Qe,V);se.onupgradeneeded=()=>at(se),se.onsuccess=()=>{const _e=se.result,Me=_e.transaction(G,"readwrite"),et=Me.objectStore(G),bt=et.get(E);let It;bt.onsuccess=()=>{if(bt.result==null)return _e.close(),q(new Error(`Cannot find model with path '${E}' in IndexedDB.`));{const sn=et.delete(E),_t=()=>{It=_e.transaction(re,"readwrite");const Kt=It.objectStore(re).delete(E);Kt.onsuccess=()=>z(bt.result.modelArtifactsInfo),Kt.onerror=$n=>q(bt.error)};sn.onsuccess=_t,sn.onerror=Tt=>(_t(),_e.close(),q(bt.error))}},bt.onerror=sn=>(_e.close(),q(bt.error)),Me.oncomplete=()=>{It==null?_e.close():It.oncomplete=()=>_e.close()}},se.onerror=_e=>q(se.error)})}}var ce=L(9024);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const me="/",pt="tensorflowjs_models",ct="info",Lt="model_topology",Nt="weight_specs",ln="weight_data",Sn="model_metadata";function tn(){if(!env().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("purgeLocalStorageModels() cannot proceed because local storage is unavailable in the current environment.");const U=window.localStorage,E=[];for(let z=0;z<U.length;++z){const q=U.key(z),se=pt+me;if(q.startsWith(se)&&q.length>se.length){U.removeItem(q);const _e=nn(q);E.indexOf(_e)===-1&&E.push(_e)}}return E}function kn(U){return{info:[pt,U,ct].join(me),topology:[pt,U,Lt].join(me),weightSpecs:[pt,U,Nt].join(me),weightData:[pt,U,ln].join(me),modelMetadata:[pt,U,Sn].join(me)}}function bn(U){for(const E of Object.values(U))window.localStorage.removeItem(E)}function nn(U){const E=U.split(me);if(E.length<3)throw new Error(`Invalid key format: ${U}`);return E.slice(1,E.length-1).join(me)}function ps(U){return U.startsWith(Xn.URL_SCHEME)?U.slice(Xn.URL_SCHEME.length):U}class Xn{constructor(E){if(!(0,Fe.OB)().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,E==null||!E)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=E,this.keys=kn(this.modelPath)}async save(E){if(E.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const z=JSON.stringify(E.modelTopology),q=JSON.stringify(E.weightSpecs),se=(0,rt.Q)(E),_e=y.w.join(E.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(se)),this.LS.setItem(this.keys.topology,z),this.LS.setItem(this.keys.weightSpecs,q),this.LS.setItem(this.keys.weightData,(0,rt._n)(_e));const Me={format:E.format,generatedBy:E.generatedBy,convertedBy:E.convertedBy,signature:E.signature!=null?E.signature:void 0,userDefinedMetadata:E.userDefinedMetadata!=null?E.userDefinedMetadata:void 0,modelInitializer:E.modelInitializer!=null?E.modelInitializer:void 0,initializerSignature:E.initializerSignature!=null?E.initializerSignature:void 0,trainingConfig:E.trainingConfig!=null?E.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(Me)),{modelArtifactsInfo:se}}catch{throw bn(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${se.modelTopologyBytes}, weightSpecsBytes=${se.weightSpecsBytes}, weightDataBytes=${se.weightDataBytes}.`)}}}async load(){const E=JSON.parse(this.LS.getItem(this.keys.info));if(E==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(E.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const z={},q=JSON.parse(this.LS.getItem(this.keys.topology));if(q==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);z.modelTopology=q;const se=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(se==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);z.weightSpecs=se;const _e=this.LS.getItem(this.keys.modelMetadata);if(_e!=null){const et=JSON.parse(_e);z.format=et.format,z.generatedBy=et.generatedBy,z.convertedBy=et.convertedBy,et.signature!=null&&(z.signature=et.signature),et.userDefinedMetadata!=null&&(z.userDefinedMetadata=et.userDefinedMetadata),et.modelInitializer!=null&&(z.modelInitializer=et.modelInitializer),et.initializerSignature!=null&&(z.initializerSignature=et.initializerSignature),et.trainingConfig!=null&&(z.trainingConfig=et.trainingConfig)}const Me=this.LS.getItem(this.keys.weightData);if(Me==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return z.weightData=(0,rt.n7)(Me),z}}Xn.URL_SCHEME="localstorage://";const Te=U=>(0,Fe.OB)().getBool("IS_BROWSER")&&!Array.isArray(U)&&U.startsWith(Xn.URL_SCHEME)?Je(U.slice(Xn.URL_SCHEME.length)):null;ht.registerSaveRouter(Te),ht.registerLoadRouter(Te);function Je(U){return new Xn(U)}class ft{constructor(){(0,ce.hu)((0,Fe.OB)().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),(0,ce.hu)(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const E={},z=pt+me,q=me+ct;for(let se=0;se<this.LS.length;++se){const _e=this.LS.key(se);if(_e.startsWith(z)&&_e.endsWith(q)){const Me=nn(_e);E[Me]=JSON.parse(this.LS.getItem(_e))}}return E}async removeModel(E){E=ps(E);const z=kn(E);if(this.LS.getItem(z.info)==null)throw new Error(`Cannot find model at path '${E}'`);const q=JSON.parse(this.LS.getItem(z.info));return bn(z),q}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ot="://";class cn{constructor(){this.managers={}}static getInstance(){return cn.instance==null&&(cn.instance=new cn),cn.instance}static registerManager(E,z){(0,ce.hu)(E!=null,()=>"scheme must not be undefined or null."),E.endsWith(Ot)&&(E=E.slice(0,E.indexOf(Ot))),(0,ce.hu)(E.length>0,()=>"scheme must not be an empty string.");const q=cn.getInstance();(0,ce.hu)(q.managers[E]==null,()=>`A model store manager is already registered for scheme '${E}'.`),q.managers[E]=z}static getManager(E){const z=cn.getInstance().managers[E];if(z==null)throw new Error(`Cannot find model manager for scheme '${E}'`);return z}static getSchemes(){return Object.keys(cn.getInstance().managers)}}function Rn(U){if(U.indexOf(Ot)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${cn.getSchemes().join(",")}`);return{scheme:U.split(Ot)[0],path:U.split(Ot)[1]}}async function Un(U,E,z=!1){(0,ce.hu)(U!==E,()=>`Old path and new path are the same: '${U}'`);const q=ht.getLoadHandlers(U);(0,ce.hu)(q.length>0,()=>`Copying failed because no load handler is found for source URL ${U}.`),(0,ce.hu)(q.length<2,()=>`Copying failed because more than one (${q.length}) load handlers for source URL ${U}.`);const se=q[0],_e=ht.getSaveHandlers(E);(0,ce.hu)(_e.length>0,()=>`Copying failed because no save handler is found for destination URL ${E}.`),(0,ce.hu)(_e.length<2,()=>`Copying failed because more than one (${q.length}) save handlers for destination URL ${E}.`);const Me=_e[0],et=Rn(U).scheme,bt=Rn(U).path,It=et===Rn(U).scheme,sn=await se.load();z&&It&&await cn.getManager(et).removeModel(bt);const _t=await Me.save(sn);return z&&!It&&await cn.getManager(et).removeModel(bt),_t.modelArtifactsInfo}async function Kn(){const U=cn.getSchemes(),E={};for(const z of U){const q=await cn.getManager(z).listModels();for(const se in q){const _e=z+Ot+se;E[_e]=q[se]}}return E}async function Us(U){const E=Rn(U);return cn.getManager(E.scheme).removeModel(E.path)}async function As(U,E){return Un(U,E,!1)}async function _r(U,E){return Un(U,E,!0)}var Ar=L(5830);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ns{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(E,z){return fetch(E,z)}now(){return performance.now()}encode(E,z){if(z!=="utf-8"&&z!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${z}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(E)}decode(E,z){return new TextDecoder(z).decode(E)}setTimeoutCustom(E,z){if(typeof window>"u"||!(0,Fe.OB)().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(E,z);return}this.functionRefs.push(E),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},z),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",q=>{if(q.source===window&&q.data.name===this.messageName){q.stopPropagation();const se=this.functionRefs[q.data.index];se(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(E){return(0,Ar.j)(E)}}if((0,Fe.OB)().get("IS_BROWSER")){(0,Fe.OB)().setPlatform("browser",new Ns);try{cn.registerManager(Xn.URL_SCHEME,new ft)}catch{}try{cn.registerManager(S.URL_SCHEME,new Ve)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jr={importFetch:()=>L(1053)};let Ys;function eo(){Ys=null}function bo(U){Ys=U}function to(){return Ys}class ks{constructor(){this.util=L(6005),this.textEncoder=new this.util.TextEncoder}fetch(E,z){return(0,Fe.OB)().global.fetch!=null?(0,Fe.OB)().global.fetch(E,z):(Ys==null&&(Ys=Jr.importFetch()),Ys(E,z))}now(){const E=process.hrtime();return E[0]*1e3+E[1]/1e6}encode(E,z){if(z!=="utf-8"&&z!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${z}`);return this.textEncoder.encode(E)}decode(E,z){return E.length===0?"":new this.util.TextDecoder(z).decode(E)}isTypedArray(E){return this.util.types.isFloat32Array(E)||this.util.types.isInt32Array(E)||this.util.types.isUint8Array(E)||this.util.types.isUint8ClampedArray(E)}}(0,Fe.OB)().get("IS_NODE")&&!(0,Fe.OB)().get("IS_BROWSER")&&(0,Fe.OB)().setPlatform("node",new ks);var Gr=L(4865),hr=L(8341),br=L(8155),wr=L(2351),Ps=L(8990);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,ee.wv)();const pr={buffer:Gr.f,cast:hr.p,clone:br.d,print:wr.S};(0,Ps.Vp)(pr);var mn=L(4531),le=L(2364),Dn=L(8670),wn=L(2107),qs=L(9896),ws=L(414),ns=L(9146),Pr=L(4233),ls=L(528);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vr=new Map,Or=new Map;class Os{getClassName(){return this.constructor.className}static fromConfig(E,z){return new E(z)}}class Qs{constructor(){this.classNameMap={}}static getMap(){return Qs.instance==null&&(Qs.instance=new Qs),Qs.instance}static register(E){Qs.getMap().classNameMap[E.className]=[E,E.fromConfig]}}function Jo(U,E,z){(0,ce.hu)(U.className!=null,()=>"Class being registered does not have the static className property defined."),(0,ce.hu)(typeof U.className=="string",()=>"className is required to be a string, but got type "+typeof U.className),(0,ce.hu)(U.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof E>"u"&&(E="Custom"),typeof z>"u"&&(z=U.className);const q=z,se=E+">"+q;return Qs.register(U),vr.set(se,U),Or.set(U,se),U}function Zs(U){return Or.has(U)?Or.get(U):U.className}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ms extends Os{minimize(E,z=!1,q){const{value:se,grads:_e}=this.computeGradients(E,q);if(q!=null){const Me=q.map(et=>({name:et.name,tensor:_e[et.name]}));this.applyGradients(Me)}else this.applyGradients(_e);return(0,mn.B9)(_e),z?se:(se.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(E,z){return(0,Pr.pn)(E,z)}dispose(){this.iterations_!=null&&(0,mn.B9)(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:(0,ls.i)(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(E){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(E){return this.iterations_=(await E[0].tensor.data())[0],E.slice(1)}}Object.defineProperty(Ms,Symbol.hasInstance,{value:U=>U.minimize!=null&&U.computeGradients!=null&&U.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Js extends Ms{static get className(){return"Adadelta"}constructor(E,z,q=null){super(),this.learningRate=E,this.rho=z,this.epsilon=q,this.accumulatedGrads=[],this.accumulatedUpdates=[],q==null&&(this.epsilon=ee.BV.backend.epsilon())}applyGradients(E){(Array.isArray(E)?E.map(q=>q.name):Object.keys(E)).forEach((q,se)=>{const _e=ee.BV.registeredVariables[q],Me=!1;this.accumulatedGrads[se]==null&&(this.accumulatedGrads[se]={originalName:`${q}/accum_grad`,variable:(0,mn.lu)(()=>(0,ns.P)(_e).variable(Me))}),this.accumulatedUpdates[se]==null&&(this.accumulatedUpdates[se]={originalName:`${q}/accum_var`,variable:(0,mn.lu)(()=>(0,ns.P)(_e).variable(Me))});const et=Array.isArray(E)?E[se].tensor:E[q];if(et==null)return;const bt=this.accumulatedGrads[se].variable,It=this.accumulatedUpdates[se].variable;(0,mn.lu)(()=>{const sn=(0,le.I)((0,wn.d)(bt,this.rho),(0,wn.d)((0,ws.h)(et),1-this.rho)),_t=(0,wn.d)((0,Dn.h)((0,qs._)((0,le.I)(It,this.epsilon)),(0,qs._)((0,le.I)(bt,this.epsilon))),et),Tt=(0,le.I)((0,wn.d)(It,this.rho),(0,wn.d)((0,ws.h)(_t),1-this.rho));bt.assign(sn),It.assign(Tt);const Kt=(0,le.I)((0,wn.d)(_t,-this.learningRate),_e);_e.assign(Kt)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&((0,mn.B9)(this.accumulatedGrads.map(E=>E.variable)),(0,mn.B9)(this.accumulatedUpdates.map(E=>E.variable)))}async getWeights(){const E=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(E.map(z=>({name:z.originalName,tensor:z.variable})))}async setWeights(E){E=await this.extractIterations(E);const z=E.length/2,q=!1;this.accumulatedGrads=E.slice(0,z).map(se=>({originalName:se.name,variable:se.tensor.variable(q)})),this.accumulatedUpdates=E.slice(z,z*2).map(se=>({originalName:se.name,variable:se.tensor.variable(q)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(E,z){return new E(z.learningRate,z.rho,z.epsilon)}}var Fr=L(7809);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hr extends Ms{static get className(){return"Adagrad"}constructor(E,z=.1){super(),this.learningRate=E,this.initialAccumulatorValue=z,this.accumulatedGrads=[]}applyGradients(E){(Array.isArray(E)?E.map(q=>q.name):Object.keys(E)).forEach((q,se)=>{const _e=ee.BV.registeredVariables[q];this.accumulatedGrads[se]==null&&(this.accumulatedGrads[se]={originalName:`${q}/accumulator`,variable:(0,mn.lu)(()=>(0,Fr.h)(_e.shape,this.initialAccumulatorValue).variable(!1))});const Me=Array.isArray(E)?E[se].tensor:E[q];if(Me==null)return;const et=this.accumulatedGrads[se].variable;(0,mn.lu)(()=>{const bt=(0,le.I)(et,(0,ws.h)(Me));et.assign(bt);const It=(0,le.I)((0,wn.d)((0,Dn.h)(Me,(0,qs._)((0,le.I)(bt,ee.BV.backend.epsilon()))),-this.learningRate),_e);_e.assign(It)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&(0,mn.B9)(this.accumulatedGrads.map(E=>E.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(E=>({name:E.originalName,tensor:E.variable})))}async setWeights(E){E=await this.extractIterations(E);const z=!1;this.accumulatedGrads=E.map(q=>({originalName:q.name,variable:q.tensor.variable(z)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(E,z){return new E(z.learningRate,z.initialAccumulatorValue)}}var Zn=L(5650),vs=L(8712);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class no extends Ms{static get className(){return"Adam"}constructor(E,z,q,se=null){super(),this.learningRate=E,this.beta1=z,this.beta2=q,this.epsilon=se,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,mn.lu)(()=>{this.accBeta1=(0,ls.i)(z).variable(),this.accBeta2=(0,ls.i)(q).variable()}),se==null&&(this.epsilon=ee.BV.backend.epsilon())}applyGradients(E){const z=Array.isArray(E)?E.map(q=>q.name):Object.keys(E);(0,mn.lu)(()=>{const q=(0,vs.l)(1,this.accBeta1),se=(0,vs.l)(1,this.accBeta2);z.forEach((_e,Me)=>{const et=ee.BV.registeredVariables[_e],bt=!1;this.accumulatedFirstMoment[Me]==null&&(this.accumulatedFirstMoment[Me]={originalName:`${_e}/m`,variable:(0,mn.lu)(()=>(0,ns.P)(et).variable(bt))}),this.accumulatedSecondMoment[Me]==null&&(this.accumulatedSecondMoment[Me]={originalName:`${_e}/v`,variable:(0,mn.lu)(()=>(0,ns.P)(et).variable(bt))});const It=Array.isArray(E)?E[Me].tensor:E[_e];if(It==null)return;const sn=this.accumulatedFirstMoment[Me].variable,_t=this.accumulatedSecondMoment[Me].variable,Tt=(0,le.I)((0,wn.d)(sn,this.beta1),(0,wn.d)(It,1-this.beta1)),Kt=(0,le.I)((0,wn.d)(_t,this.beta2),(0,wn.d)((0,ws.h)(It),1-this.beta2)),$n=(0,Dn.h)(Tt,q),qn=(0,Dn.h)(Kt,se);sn.assign(Tt),_t.assign(Kt);const es=(0,le.I)((0,wn.d)((0,Dn.h)($n,(0,le.I)((0,qs._)(qn),this.epsilon)),-this.learningRate),et);et.assign(es)}),this.accBeta1.assign((0,wn.d)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,wn.d)(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&(0,mn.B9)(this.accumulatedFirstMoment.map(E=>E.variable)),this.accumulatedSecondMoment!=null&&(0,mn.B9)(this.accumulatedSecondMoment.map(E=>E.variable))}async getWeights(){const E=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(E.map(z=>({name:z.originalName,tensor:z.variable})))}async setWeights(E){E=await this.extractIterations(E),(0,mn.lu)(()=>{this.accBeta1.assign((0,Zn.s)(this.beta1,this.iterations_+1)),this.accBeta2.assign((0,Zn.s)(this.beta2,this.iterations_+1))});const z=E.length/2,q=!1;this.accumulatedFirstMoment=E.slice(0,z).map(se=>({originalName:se.name,variable:se.tensor.variable(q)})),this.accumulatedSecondMoment=E.slice(z,z*2).map(se=>({originalName:se.name,variable:se.tensor.variable(q)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(E,z){return new E(z.learningRate,z.beta1,z.beta2,z.epsilon)}}var Ro=L(5136),Cr=L(3624);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cs extends Ms{static get className(){return"Adamax"}constructor(E,z,q,se=null,_e=0){super(),this.learningRate=E,this.beta1=z,this.beta2=q,this.epsilon=se,this.decay=_e,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,mn.lu)(()=>{this.iteration=(0,ls.i)(0).variable(),this.accBeta1=(0,ls.i)(z).variable()}),se==null&&(this.epsilon=ee.BV.backend.epsilon())}applyGradients(E){const z=Array.isArray(E)?E.map(q=>q.name):Object.keys(E);(0,mn.lu)(()=>{const q=(0,vs.l)(1,this.accBeta1),se=(0,Dn.h)(-this.learningRate,(0,le.I)((0,wn.d)(this.iteration,this.decay),1));z.forEach((_e,Me)=>{const et=ee.BV.registeredVariables[_e],bt=!1;this.accumulatedFirstMoment[Me]==null&&(this.accumulatedFirstMoment[Me]={originalName:`${_e}/m`,variable:(0,ns.P)(et).variable(bt)}),this.accumulatedWeightedInfNorm[Me]==null&&(this.accumulatedWeightedInfNorm[Me]={originalName:`${_e}/v`,variable:(0,ns.P)(et).variable(bt)});const It=Array.isArray(E)?E[Me].tensor:E[_e];if(It==null)return;const sn=this.accumulatedFirstMoment[Me].variable,_t=this.accumulatedWeightedInfNorm[Me].variable,Tt=(0,le.I)((0,wn.d)(sn,this.beta1),(0,wn.d)(It,1-this.beta1)),Kt=(0,wn.d)(_t,this.beta2),$n=(0,Ro.W)(It),qn=(0,Cr.g)(Kt,$n);sn.assign(Tt),_t.assign(qn);const es=(0,le.I)((0,wn.d)((0,Dn.h)(se,q),(0,Dn.h)(Tt,(0,le.I)(qn,this.epsilon))),et);et.assign(es)}),this.iteration.assign((0,le.I)(this.iteration,1)),this.accBeta1.assign((0,wn.d)(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&(0,mn.B9)(this.accumulatedFirstMoment.map(E=>E.variable)),this.accumulatedWeightedInfNorm!=null&&(0,mn.B9)(this.accumulatedWeightedInfNorm.map(E=>E.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(E){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(E,z){return new E(z.learningRate,z.beta1,z.beta2,z.epsilon,z.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fr extends Ms{static get className(){return"SGD"}constructor(E){super(),this.learningRate=E,this.setLearningRate(E)}applyGradients(E){(Array.isArray(E)?E.map(q=>q.name):Object.keys(E)).forEach((q,se)=>{const _e=Array.isArray(E)?E[se].tensor:E[q];if(_e==null)return;const Me=ee.BV.registeredVariables[q];(0,mn.lu)(()=>{const et=(0,le.I)((0,wn.d)(this.c,_e),Me);Me.assign(et)})}),this.incrementIterations()}setLearningRate(E){this.learningRate=E,this.c!=null&&this.c.dispose(),this.c=(0,mn.Cn)((0,ls.i)(-E))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(E){if(E=await this.extractIterations(E),E.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(E,z){return new E(z.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sr extends fr{static get className(){return"Momentum"}constructor(E,z,q=!1){super(E),this.learningRate=E,this.momentum=z,this.useNesterov=q,this.accumulations=[],this.m=(0,ls.i)(this.momentum)}applyGradients(E){(Array.isArray(E)?E.map(q=>q.name):Object.keys(E)).forEach((q,se)=>{const _e=ee.BV.registeredVariables[q];this.accumulations[se]==null&&(this.accumulations[se]={originalName:`${q}/momentum`,variable:(0,mn.lu)(()=>(0,ns.P)(_e).variable(!1))});const Me=this.accumulations[se].variable,et=Array.isArray(E)?E[se].tensor:E[q];et!=null&&(0,mn.lu)(()=>{let bt;const It=(0,le.I)((0,wn.d)(this.m,Me),et);this.useNesterov?bt=(0,le.I)((0,wn.d)(this.c,(0,le.I)(et,(0,wn.d)(It,this.m))),_e):bt=(0,le.I)((0,wn.d)(this.c,It),_e),Me.assign(It),_e.assign(bt)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&(0,mn.B9)(this.accumulations.map(E=>E.variable))}setMomentum(E){this.momentum=E}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(E=>({name:E.originalName,tensor:E.variable})))}async setWeights(E){E=await this.extractIterations(E);const z=!1;this.accumulations=E.map(q=>({originalName:q.name,variable:q.tensor.variable(z)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(E,z){return new E(z.learningRate,z.momentum,z.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class so extends Ms{static get className(){return"RMSProp"}constructor(E,z=.9,q=0,se=null,_e=!1){if(super(),this.learningRate=E,this.decay=z,this.momentum=q,this.epsilon=se,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=_e,se==null&&(this.epsilon=ee.BV.backend.epsilon()),E==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(E){(Array.isArray(E)?E.map(q=>q.name):Object.keys(E)).forEach((q,se)=>{const _e=ee.BV.registeredVariables[q],Me=!1;this.accumulatedMeanSquares[se]==null&&(this.accumulatedMeanSquares[se]={originalName:`${q}/rms`,variable:(0,mn.lu)(()=>(0,ns.P)(_e).variable(Me))}),this.accumulatedMoments[se]==null&&(this.accumulatedMoments[se]={originalName:`${q}/momentum`,variable:(0,mn.lu)(()=>(0,ns.P)(_e).variable(Me))}),this.accumulatedMeanGrads[se]==null&&this.centered&&(this.accumulatedMeanGrads[se]={originalName:`${q}/mg`,variable:(0,mn.lu)(()=>(0,ns.P)(_e).variable(Me))});const et=Array.isArray(E)?E[se].tensor:E[q];if(et==null)return;const bt=this.accumulatedMeanSquares[se].variable,It=this.accumulatedMoments[se].variable;(0,mn.lu)(()=>{const sn=(0,le.I)((0,wn.d)(bt,this.decay),(0,wn.d)((0,ws.h)(et),1-this.decay));if(this.centered){const _t=this.accumulatedMeanGrads[se].variable,Tt=(0,le.I)((0,wn.d)(_t,this.decay),(0,wn.d)(et,1-this.decay)),Kt=(0,Dn.h)((0,wn.d)(et,this.learningRate),(0,qs._)((0,vs.l)(sn,(0,le.I)((0,ws.h)(Tt),this.epsilon)))),$n=(0,le.I)((0,wn.d)(It,this.momentum),Kt);bt.assign(sn),_t.assign(Tt),It.assign($n);const qn=(0,vs.l)(_e,$n);_e.assign(qn)}else{const _t=(0,le.I)((0,wn.d)(bt,this.decay),(0,wn.d)((0,ws.h)(et),1-this.decay)),Tt=(0,le.I)((0,wn.d)(It,this.momentum),(0,Dn.h)((0,wn.d)(et,this.learningRate),(0,qs._)((0,le.I)(_t,this.epsilon))));bt.assign(_t),It.assign(Tt);const Kt=(0,vs.l)(_e,Tt);_e.assign(Kt)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&(0,mn.B9)(this.accumulatedMeanSquares.map(E=>E.variable)),this.accumulatedMeanGrads!=null&&this.centered&&(0,mn.B9)(this.accumulatedMeanGrads.map(E=>E.variable)),this.accumulatedMoments!=null&&(0,mn.B9)(this.accumulatedMoments.map(E=>E.variable))}async getWeights(){const E=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&E.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(E.map(z=>({name:z.originalName,tensor:z.variable})))}async setWeights(E){E=await this.extractIterations(E);const z=this.centered?E.length/3:E.length/2,q=!1;this.accumulatedMeanSquares=E.slice(0,z).map(se=>({originalName:se.name,variable:se.tensor.variable(q)})),this.accumulatedMoments=E.slice(z,z*2).map(se=>({originalName:se.name,variable:se.tensor.variable(q)})),this.centered&&(this.accumulatedMeanGrads=E.slice(z*2,z*3).map(se=>({originalName:se.name,variable:se.tensor.variable(q)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(E,z){return new E(z.learningRate,z.decay,z.momentum,z.epsilon,z.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ro=[Js,Hr,no,Cs,Sr,so,fr];function wo(){for(const U of ro)Jo(U)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oo="model",js=".json",er=".weights.bin";function Br(U){return new Promise(E=>setTimeout(E)).then(U)}class tr{constructor(E){if(!(0,Fe.OB)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");E.startsWith(tr.URL_SCHEME)&&(E=E.slice(tr.URL_SCHEME.length)),(E==null||E.length===0)&&(E=oo),this.modelJsonFileName=E+js,this.weightDataFileName=E+er}async save(E){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const z=y.w.join(E.weightData),q=window.URL.createObjectURL(new Blob([z],{type:"application/octet-stream"}));if(E.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const se=[{paths:["./"+this.weightDataFileName],weights:E.weightSpecs}],_e=(0,rt.Yd)(E,se),Me=window.URL.createObjectURL(new Blob([JSON.stringify(_e)],{type:"application/json"})),et=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(et.download=this.modelJsonFileName,et.href=Me,await Br(()=>et.dispatchEvent(new MouseEvent("click"))),E.weightData!=null){const bt=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;bt.download=this.weightDataFileName,bt.href=q,await Br(()=>bt.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:(0,rt.Q)(E)}}}}tr.URL_SCHEME="downloads://";class Do{constructor(E){if(E==null||E.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${E}`);this.jsonFile=E[0],this.weightsFiles=E.slice(1)}async load(){return new Promise((E,z)=>{const q=new FileReader;q.onload=se=>{const _e=JSON.parse(se.target.result),Me=_e.modelTopology;if(Me==null){z(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(_e.weightsManifest==null){z(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){E({modelTopology:Me});return}const bt=(0,rt.jN)(_e,It=>this.loadWeights(It));E(bt)},q.onerror=se=>z(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),q.readAsText(this.jsonFile)})}loadWeights(E){const z=[],q=[];for(const Me of E)z.push(...Me.weights),q.push(...Me.paths);const se=this.checkManifestAndWeightFiles(E),_e=q.map(Me=>this.loadWeightsFile(Me,se[Me]));return Promise.all(_e).then(Me=>[z,Me])}loadWeightsFile(E,z){return new Promise((q,se)=>{const _e=new FileReader;_e.onload=Me=>{const et=Me.target.result;q(et)},_e.onerror=Me=>se(`Failed to weights data from file of path '${E}'.`),_e.readAsArrayBuffer(z)})}checkManifestAndWeightFiles(E){const z=[],q=this.weightsFiles.map(_e=>(0,rt.EZ)(_e.name)),se={};for(const _e of E)_e.paths.forEach(Me=>{const et=(0,rt.EZ)(Me);if(z.indexOf(et)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${et}'`);if(z.push(et),q.indexOf(et)===-1)throw new Error(`Weight file with basename '${et}' is not provided.`);se[Me]=this.weightsFiles[q.indexOf(et)]});if(z.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${z.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return se}}const _o=U=>(0,Fe.OB)().getBool("IS_BROWSER")&&!Array.isArray(U)&&U.startsWith(tr.URL_SCHEME)?ao(U.slice(tr.URL_SCHEME.length)):null;ht.registerSaveRouter(_o);function ao(U="model"){return new tr(U)}function ms(U){return new Do(U)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ao(U,E,z,q){Me(U),z=z??0,q=q??1,et(z,q);let se=0;const _e=bt=>(bt.then(It=>{const sn=z+ ++se/U.length*(q-z);return E(sn),It}),bt);function Me(bt){(0,ce.hu)(bt!=null&&Array.isArray(bt)&&bt.length>0,()=>"promises must be a none empty array")}function et(bt,It){(0,ce.hu)(bt>=0&&bt<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${bt}`),(0,ce.hu)(It>=0&&It<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${It}`),(0,ce.hu)(It>=bt,()=>`startFraction must be no more than endFraction, but got startFraction ${bt} and endFraction ${It}`)}return Promise.all(U.map(_e))}var jr=L(1864);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Ws(U,E){E==null&&(E={});const z=E.fetchFunc==null?(0,Fe.OB)().platform.fetch:E.fetchFunc,q=U.map(_t=>z(_t,E.requestInit,{isBinary:!0})),et=(E.onProgress==null?await Promise.all(q):await Ao(q,E.onProgress,0,.5)).map(_t=>_t.arrayBuffer());return E.onProgress==null?await Promise.all(et):await Ao(et,E.onProgress,.5,1)}function Kr(U,E){var z;const q=E.fetchFunc==null?(0,Fe.OB)().platform.fetch:E.fetchFunc;let se=0,_e;return(z=E.onProgress)===null||z===void 0||z.call(E,0),new ReadableStream({pull:async Me=>{for(var et;se<U.length;){_e||(_e=(await q(U[se],E.requestInit,{isBinary:!0})).body.getReader());const{done:bt,value:It}=await _e.read();if(bt){se++,_e=void 0,(et=E.onProgress)===null||et===void 0||et.call(E,se/U.length);continue}Me.enqueue(It);return}Me.close()}})}async function zo(U,E="",z,q){return vo(Me=>Ws(Me,{requestInit:q}))(U,E,z)}function vo(U){return async(E,z="",q)=>{const se=E.map(()=>!1),_e={},Me=q!=null?q.map(()=>!1):[],et=[];if(E.forEach((Kt,$n)=>{let qn=0;Kt.weights.forEach(es=>{const Vs="quantization"in es?es.quantization.dtype:es.dtype,xa=jr.J[Vs]*ce.NA(es.shape),un=()=>{se[$n]=!0,_e[$n]==null&&(_e[$n]=[]),_e[$n].push({manifestEntry:es,groupOffset:qn,sizeBytes:xa})};q!=null?q.forEach((Ts,rs)=>{Ts===es.name&&(un(),Me[rs]=!0)}):un(),et.push(es.name),qn+=xa})}),!Me.every(Kt=>Kt)){const Kt=q.filter(($n,qn)=>!Me[qn]);throw new Error(`Could not find weights in manifest with names: ${Kt.join(", ")}. 
Manifest JSON has weights with names: ${et.join(", ")}.`)}const bt=se.reduce((Kt,$n,qn)=>($n&&Kt.push(qn),Kt),[]),It=[];bt.forEach(Kt=>{E[Kt].paths.forEach($n=>{const qn=z+(z.endsWith("/")?"":"/")+$n;It.push(qn)})});const sn=await U(It),_t={};let Tt=0;return bt.forEach(Kt=>{const $n=E[Kt].paths.length,qn=new y.w(sn.slice(Tt,Tt+$n));_e[Kt].forEach(Vs=>{const xa=qn.slice(Vs.groupOffset,Vs.groupOffset+Vs.sizeBytes),un=(0,rt.dI)(xa,[Vs.manifestEntry]);for(const Ts in un)_t[Ts]=un[Ts]}),Tt+=$n}),_t}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Po="application/octet-stream",cs="application/json";class as{constructor(E,z){if(this.DEFAULT_METHOD="POST",z==null&&(z={}),this.weightPathPrefix=z.weightPathPrefix,this.weightUrlConverter=z.weightUrlConverter,z.fetchFunc!=null?((0,ce.hu)(typeof z.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=z.fetchFunc):this.fetch=(0,Fe.OB)().platform.fetch,(0,ce.hu)(E!=null&&E.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(E)&&(0,ce.hu)(E.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${E.length}).`),this.path=E,z.requestInit!=null&&z.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=z.requestInit||{},this.loadOptions=z}async save(E){if(E.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const z=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);z.body=new FormData;const q=[{paths:["./model.weights.bin"],weights:E.weightSpecs}],se=(0,rt.Yd)(E,q);if(z.body.append("model.json",new Blob([JSON.stringify(se)],{type:cs}),"model.json"),E.weightData!=null){const Me=y.w.join(E.weightData);z.body.append("model.weights.bin",new Blob([Me],{type:Po}),"model.weights.bin")}const _e=await this.fetch(this.path,z);if(_e.ok)return{modelArtifactsInfo:(0,rt.Q)(E),responses:[_e]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${_e.status}.`)}async loadModelJSON(){const E=await this.fetch(this.path,this.requestInit);if(!E.ok)throw new Error(`Request to ${this.path} failed with status code ${E.status}. Please verify this URL points to the model JSON of the model to load.`);let z;try{z=await E.json()}catch{let Me=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?Me+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":Me+=" Please make sure the server is serving valid JSON for this request.",new Error(Me)}const q=z.modelTopology,se=z.weightsManifest;if(q==null&&se==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return z}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const E=await this.loadModelJSON();return(0,rt.jN)(E,z=>this.loadWeights(z))}async loadStream(){const E=await this.loadModelJSON(),z=await this.getWeightUrls(E.weightsManifest),q=(0,rt.hu)(E.weightsManifest),se=()=>Kr(z,this.loadOptions);return Object.assign(Object.assign({},E),{weightSpecs:q,getWeightStream:se})}async getWeightUrls(E){const z=Array.isArray(this.path)?this.path[1]:this.path,[q,se]=Oo(z),_e=this.weightPathPrefix||q,Me=[],et=[];for(const bt of E)for(const It of bt.paths)this.weightUrlConverter!=null?et.push(this.weightUrlConverter(It)):Me.push(_e+It+se);return this.weightUrlConverter&&Me.push(...await Promise.all(et)),Me}async loadWeights(E){const z=await this.getWeightUrls(E),q=(0,rt.hu)(E),se=await Ws(z,this.loadOptions);return[q,se]}}as.URL_SCHEME_REGEX=/^https?:\/\//;function Oo(U){const E=U.lastIndexOf("/"),z=U.lastIndexOf("?"),q=U.substring(0,E),se=z>E?U.substring(z):"";return[q+"/",se]}function Lr(U){return U.match(as.URL_SCHEME_REGEX)!=null}const Co=(U,E)=>{if(typeof fetch>"u"&&(E==null||E.fetchFunc==null))return null;{let z=!0;if(Array.isArray(U)?z=U.every(q=>Lr(q)):z=Lr(U),z)return Ss(U,E)}return null};ht.registerSaveRouter(Co),ht.registerLoadRouter(Co);function Ss(U,E){return new as(U,E)}function fs(U,E){return Ss(U,E)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uo{constructor(E){this.modelArtifacts=E}load(){return this.modelArtifacts}}class An{constructor(E){this.saveHandler=E}save(E){return this.saveHandler(E)}}class Ur{constructor(E){E.load&&(this.load=()=>Promise.resolve(E.load())),E.save&&(this.save=z=>Promise.resolve(E.save(z)))}}function ar(U,E,z,q){const se=arguments;return new Ur(nr(...se))}function nr(U,E,z,q){return arguments.length===1?U.modelTopology!=null||U.weightSpecs!=null?new uo(U):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new uo({modelTopology:U})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new uo({modelTopology:U,weightSpecs:E,weightData:z,trainingConfig:q}))}function ir(U){return new An(U)}function So(U){return new An(U)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Mr=L(6255),Ye=L(4403),Ir=L(5042),Jn=L(6857),Er=L(7264),Wr=L(7158);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Fs,ur=!1;function Se(U,E=3){if(E>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(U==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let z=!1,q=!1,se=!1,_e=!1,Me=!1,et=!1;if(U.data instanceof Uint8Array)z=!0;else if(typeof ImageData<"u"&&U instanceof ImageData)q=!0;else if(typeof HTMLVideoElement<"u"&&U instanceof HTMLVideoElement)se=!0;else if(typeof HTMLImageElement<"u"&&U instanceof HTMLImageElement)_e=!0;else if(U.getContext!=null)Me=!0;else if(typeof ImageBitmap<"u"&&U instanceof ImageBitmap)et=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${U.constructor.name}`);if((0,Ir.pI)(Ye.eBW,ee.BV.backendName)!=null){const $n={pixels:U},qn={numChannels:E};return ee.BV.runKernel(Ye.eBW,$n,qn)}const[It,sn]=se?[U.videoWidth,U.videoHeight]:[U.width,U.height];let _t;if(Me)_t=U.getContext("2d").getImageData(0,0,It,sn).data;else if(q||z)_t=U.data;else if(_e||se||et){if(Fs==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Fs=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Fs=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Fs.canvas.width=It,Fs.canvas.height=sn,Fs.drawImage(U,0,0,It,sn),_t=Fs.getImageData(0,0,It,sn).data}let Tt;if(E===4)Tt=new Int32Array(_t);else{const $n=It*sn;Tt=new Int32Array($n*E);for(let qn=0;qn<$n;qn++)for(let es=0;es<E;++es)Tt[qn*E+es]=_t[qn*4+es]}const Kt=[sn,It,E];return(0,Wr.w)(Tt,Kt,"int32")}function fe(U){return U!=null&&U.data instanceof Uint8Array}function de(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function Ee(U){return U!=null&&U.width!==0&&U.height!==0}function Ae(U){return de()&&!(U instanceof ImageBitmap)&&Ee(U)&&!fe(U)}async function Pe(U,E=3){let z=null;if((0,Fe.OB)().getBool("WRAP_TO_IMAGEBITMAP")&&Ae(U)){let q;try{q=await createImageBitmap(U,{premultiplyAlpha:"none"})}catch{q=null}q!=null&&q.width===U.width&&q.height===U.height?z=q:z=U}else z=U;return Se(z,E)}function We(U){if(U.rank!==2&&U.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${U.rank}.`);const E=U.rank===2?1:U.shape[2];if(E>4||E===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${E}`);if(U.dtype!=="float32"&&U.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${U.dtype}. Please use float32 or int32 tensors.`)}function je(U){const E=U?.alpha||1;if(E>1||E<0)throw new Error(`Alpha value ${E} is suppoed to be in range [0 - 1].`)}async function Oe(U,E){let z=(0,Jn._1)(U,"img","toPixels");if(!(U instanceof Ps.es)){const It=z;z=(0,hr.p)(It,"int32"),It.dispose()}We(z);const[q,se]=z.shape.slice(0,2),_e=z.rank===2?1:z.shape[2],Me=await z.data(),et=z.dtype==="float32"?255:1,bt=new Uint8ClampedArray(se*q*4);for(let It=0;It<q*se;++It){const sn=[0,0,0,255];for(let Tt=0;Tt<_e;Tt++){const Kt=Me[It*_e+Tt];if(z.dtype==="float32"){if(Kt<0||Kt>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${Kt}.`)}else if(z.dtype==="int32"&&(Kt<0||Kt>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${Kt}.`);_e===1?(sn[0]=Kt*et,sn[1]=Kt*et,sn[2]=Kt*et):sn[Tt]=Kt*et}const _t=It*4;bt[_t+0]=Math.round(sn[0]),bt[_t+1]=Math.round(sn[1]),bt[_t+2]=Math.round(sn[2]),bt[_t+3]=Math.round(sn[3])}if(E!=null){ur||(0,Ir.pI)(Ye.hGc,ee.BV.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),ur=!0),E.width=se,E.height=q;const It=E.getContext("2d"),sn=new ImageData(bt,se,q);It.putImageData(sn,0,0)}return z!==U&&z.dispose(),bt}function st(U,E,z){let q=(0,Jn._1)(U,"img","draw");if(!(U instanceof Ps.es)){const Me=q;q=(0,hr.p)(Me,"int32"),Me.dispose()}We(q),je(z?.imageOptions);const se={image:q},_e={canvas:E,options:z};ee.BV.runKernel(Ye.hGc,se,_e)}const ut=(0,Er.op)({fromPixels_:Se});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tt=-2,yt=-1;function At(U,E,z){const q=U.shape.length;ce.hu(q===E.length,()=>`Error in slice${q}D: Length of begin ${E} must match the rank of the array (${q}).`),ce.hu(q===z.length,()=>`Error in slice${q}D: Length of size ${z} must match the rank of the array (${q}).`);for(let se=0;se<q;++se)ce.hu(E[se]+z[se]<=U.shape[se],()=>`Error in slice${q}D: begin[${se}] + size[${se}] (${E[se]+z[se]}) would overflow input.shape[${se}] (${U.shape[se]})`)}function xt(U){const E=[];let z=0;for(;U>0;)U&1&&E.push(z),U/=2,z++;return E}function Qt(U,E,z){const q=[];for(let se=0;se<U.length;se++)q[se]=Math.ceil((E[se]-U[se])/z[se]);return q}function gt(U,E,z,q){const se=[...U];for(let _e=se.length;_e<q.length;_e++)se.push(1);for(let _e=0;_e<z;_e++)_e===0?se[E]=1:(se.splice(E,0,1),se.pop());return se}function Ct(U,E,z){return z<=U?z:z-(E-1)}function Pt(U,E){const z=[];for(let q=0;q<U;q++)z.push(E+q);return z}function fn(U,E,z,q,se,_e,Me,et,bt){const It=U.length;let sn=new Array(It),_t=new Array(It),Tt=new Array(It);if(E.length&&z>0){const Kt=E[0],$n=z+1;sn=pn(Me,Kt,$n,q,U),_t=Pn(et,Kt,$n,se,U),Tt=gt(_e,Kt,$n,U)}else for(let Kt=0;Kt<It;Kt++)sn[Kt]=Cn(Me,q,_e,U,Kt,bt),_t[Kt]=Hn(et,se,_e,U,Kt,bt),Tt[Kt]=Jt(_e,Kt,bt);return{begin:sn,end:_t,strides:Tt}}function pn(U,E,z,q,se){const _e=[...se],Me=Pt(z,E);for(let et=0;et<_e.length;et++)if(Me.indexOf(et)>-1)_e[et]=0;else{const bt=Ct(E,z,et);let It=q[bt];U&1<<bt&&(It=0),_e[et]=It}return _e}function Pn(U,E,z,q,se){const _e=[...se],Me=Pt(z,E);for(let et=0;et<_e.length;et++)if(Me.indexOf(et)>-1)_e[et]=Number.MAX_SAFE_INTEGER;else{const bt=Ct(E,z,et);let It=q[bt];U&1<<bt&&(It=Number.MAX_SAFE_INTEGER),_e[et]=It}for(let et=0;et<_e.length;et++){const bt=se[et];_e[et]<0&&(_e[et]+=bt),_e[et]=ce.uZ(0,_e[et],se[et])}return _e}function Jt(U,E,z){let q=U[E];return(z&1<<E||q==null)&&(q=1),q}function Cn(U,E,z,q,se,_e){let Me=E[se];const et=z[se]||1;(U&1<<se||_e&1<<se||Me==null)&&(et>0?Me=Number.MIN_SAFE_INTEGER:Me=Number.MAX_SAFE_INTEGER);const bt=q[se];return Me<0&&(Me+=bt),Me=ce.uZ(0,Me,bt-1),Me}function Hn(U,E,z,q,se,_e){let Me=E[se];const et=z[se]||1;(U&1<<se||_e&1<<se||Me==null)&&(et>0?Me=Number.MAX_SAFE_INTEGER:Me=Number.MIN_SAFE_INTEGER);const bt=q[se];return Me<0&&(Me+=bt),et>0?Me=ce.uZ(0,Me,bt):Me=ce.uZ(-1,Me,bt-1),Me}function kt(U,E,z){let q=z.length;for(let se=0;se<z.length;se++)if(z[se]>1){q=se;break}for(let se=q+1;se<z.length;se++)if(E[se]>0||z[se]!==U[se])return!1;return!0}function Tr(U,E){let z=U.length>0?U[U.length-1]:1;for(let q=0;q<U.length-1;q++)z+=U[q]*E[q];return z}function Vr(U,E,z){let q;const se=U.shape.length;typeof E=="number"?q=[E,...new Array(se-1).fill(0)]:E.length<se?q=E.concat(new Array(se-E.length).fill(0)):q=E.slice(),q.forEach(Me=>{ce.hu(Me!==-1,()=>"slice() does not support negative begin indexing.")});let _e;return z==null?_e=new Array(se).fill(-1):typeof z=="number"?_e=[z,...new Array(se-1).fill(-1)]:z.length<se?_e=z.concat(new Array(se-z.length).fill(-1)):_e=z,_e=_e.map((Me,et)=>Me>=0?Me:(ce.hu(Me===-1,()=>`Negative size values should be exactly -1 but got ${Me} for the slice() size at index ${et}.`),U.shape[et]-q[et])),[q,_e]}function lo(U,E,z,q,se,_e,Me,et,bt){let It;if(q==null?(It=new Array(E.length),It.fill(1)):It=q,Me!=null&&(Me&Me-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let sn=!1;const _t={dims:It.length,numAddAxisAfterEllipsis:0,begin:E.slice(),end:z.slice(),strides:It.slice(),beginMask:se,endMask:_e,ellipsisMask:Me,newAxisMask:et,shrinkAxisMask:bt};for(let un=0;un<_t.dims;un++)sn&&(1<<un&et)!==0&&_t.numAddAxisAfterEllipsis++,1<<un&Me&&(sn=!0);sn||(_t.ellipsisMask|=1<<_t.dims,_t.dims++);const Tt={dims:U.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Xr(_t,Tt);let Kt=!0,$n=!0,qn=!0;const es=[],Vs=[];for(let un=0;un<U.length;++un){if(Tt.strides[un]===0)throw Error(`strides[${un}] must be non-zero`);const Ts=!!(Tt.shrinkAxisMask&1<<un),rs=U[un];if(rs===-1){es.push(Ts?1:-1);continue}const qa=[Tt.beginMask&1<<un,Tt.endMask&1<<un],po=[Tt.strides[un]>0?0:-1,Tt.strides[un]>0?rs:rs-1];if(Ts&&Tt.strides[un]<=0)throw Error("only stride 1 allowed on non-range indexing.");qn=qn&&Tt.strides[un]===1;const Ra=!!(Tt.beginMask&1<<un&&Tt.endMask&1<<un);if(Tt.beginValid&&Tt.endValid){if(Ts){const Da=Tt.begin[un]<0?rs+Tt.begin[un]:Tt.begin[un];if(Tt.begin[un]=Da,Tt.end[un]=Tt.begin[un]+1,Da<0||Da>=rs)throw Error(`slice index ${Tt.begin[un]} of dimension ${un} out of bounds.`)}else Tt.begin[un]=Io(Tt.begin[un],0,Tt.strides[un],rs,qa,po),Tt.end[un]=Io(Tt.end[un],1,Tt.strides[un],rs,qa,po);const Xo=Tt.strides[un]===1&&Tt.begin[un]===0&&Tt.end[un]===rs;Kt=Kt&&Xo,$n=$n&&(un===0&&Tt.strides[un]===1||Xo)}else Kt=Kt&&Tt.strides[un]===1&&Ra,$n=$n&&(un===0&&Tt.strides[un]===1||Ra);let fo,sa=!1;if(Tt.beginValid&&Tt.endValid?(fo=Tt.end[un]-Tt.begin[un],sa=!0):Ts?(fo=1,sa=!0):Ra&&rs>=0&&(Tt.strides[un]<0?fo=-rs:fo=rs,sa=!0),sa){let Xo;fo===0||fo<0!=Tt.strides[un]<0?Xo=0:Xo=Math.trunc(fo/Tt.strides[un])+(fo%Tt.strides[un]!==0?1:0),es.push(Xo)}else es.push(-1)}for(let un=0;un<Tt.finalShapeGatherIndices.length;++un){const Ts=Tt.finalShapeGatherIndices[un];Ts>=0?Vs.push(es[Ts]):Ts===tt&&Vs.push(1)}return{finalShapeSparse:Vs.filter((un,Ts)=>Tt.finalShapeGatherIndices[Ts]!==tt),finalShape:Vs,isIdentity:Kt,sliceDim0:$n,isSimpleSlice:qn,begin:Tt.begin,end:Tt.end,strides:Tt.strides}}function Xr(U,E){E.beginMask=0,E.endMask=0,E.shrinkAxisMask=0;let z=0;E.beginValid=U.begin!=null,E.endValid=U.end!=null,E.begin=new Array(E.dims),E.end=new Array(E.dims),E.strides=new Array(E.dims),E.finalShapeGatherIndices=[],E.finalShapeGatherIndicesSparse=[],E.inputShapeGatherIndicesSparse=new Array(E.dims);for(let q=0;q<U.dims;q++)if(1<<q&U.ellipsisMask){const se=Math.min(E.dims-(U.dims-q)+1+U.numAddAxisAfterEllipsis,E.dims);for(;z<se;z++)E.begin[z]=0,E.end[z]=0,E.strides[z]=1,E.beginMask|=1<<z,E.endMask|=1<<z,E.finalShapeGatherIndices.push(z),E.finalShapeGatherIndicesSparse.push(-1),E.inputShapeGatherIndicesSparse[z]=q}else if(1<<q&U.newAxisMask)E.finalShapeGatherIndices.push(tt),E.finalShapeGatherIndicesSparse.push(-1);else{if(z===E.begin.length)throw Error(`Index out of range using input dim ${z}; input has only ${E.dims} dims, ${E.begin.length}.`);U.begin!=null&&(E.begin[z]=U.begin[q]),U.end!=null&&(E.end[z]=U.end[q]),E.strides[z]=U.strides[q],U.beginMask&1<<q&&(E.beginMask|=1<<z),U.endMask&1<<q&&(E.endMask|=1<<z),U.shrinkAxisMask&1<<q?(E.finalShapeGatherIndices.push(yt),E.finalShapeGatherIndicesSparse.push(-1),E.shrinkAxisMask|=1<<z):(E.finalShapeGatherIndices.push(z),E.finalShapeGatherIndicesSparse.push(q)),E.inputShapeGatherIndicesSparse[z]=q,z++}}function Io(U,E,z,q,se,_e){if(se[E])return z>0?_e[E]:_e[E+1&1];{const Me=U<0?q+U:U;return Me<_e[0]?_e[0]:Me>_e[1]?_e[1]:Me}}var co=L(2891),zr=L(6154),Wn=L(4337);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ea=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:U=>U();function Fo(){return new Promise(U=>ea(()=>U()))}var lr=L(7199);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Go(U,E){const z=U[0].length;U.forEach((se,_e)=>{ce.hu(se.length===z,()=>`Error in concat${z}D: rank of tensors[${_e}] must be the same as the rank of the rest (${z})`)}),ce.hu(E>=0&&E<z,()=>`Error in concat${z}D: axis must be between 0 and ${z-1}.`);const q=U[0];U.forEach((se,_e)=>{for(let Me=0;Me<z;Me++)ce.hu(Me===E||se[Me]===q[Me],()=>`Error in concat${z}D: Shape of tensors[${_e}] (${se}) does not match the shape of the rest (${q}) along the non-concatenated axis ${_e}.`)})}function Ho(U,E){const z=U[0].slice();for(let q=1;q<U.length;q++)z[E]+=U[q][E];return z}var Rs=L(2132),Eo=L(3608);/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var $r;(function(U){U[U.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",U[U.VALUE_ROWIDS=1]="VALUE_ROWIDS",U[U.ROW_LENGTHS=2]="ROW_LENGTHS",U[U.ROW_SPLITS=3]="ROW_SPLITS",U[U.ROW_LIMITS=4]="ROW_LIMITS",U[U.ROW_STARTS=5]="ROW_STARTS"})($r||($r={}));function Bo(U,E,z){let q=new Array;if(z==null&&E==null)return q;if(E==null)for(;q.length<U+z.length;)q.push(-1);else q=E.slice();if(z==null)return q;if(U+z.length!==q.length)throw new Error(`rt input.shape and shape=${E} are incompatible: rt input.rank = ${U+z.length}, but shape.rank = ${q.length}`);for(let se=1;se<z.length;++se){const _e=z[se],Me=q[q.length-z.length+se],et=q[Me];if(_e>=0)if(et>=0){if(et!==_e)throw new Error(`rt input.shape and shape=${E} are incompatible: rt input.shape[${se+U}] = ${_e} but shape[${se+U}] = ${et}`)}else q[Me]=_e}return q}function ho(U){const E={FIRST_DIM_SIZE:$r.FIRST_DIM_SIZE,VALUE_ROWIDS:$r.VALUE_ROWIDS,ROW_LENGTHS:$r.ROW_LENGTHS,ROW_SPLITS:$r.ROW_SPLITS,ROW_LIMITS:$r.ROW_LIMITS,ROW_STARTS:$r.ROW_STARTS},z=[];for(const q of U)if(q in E)z.push(E[q]);else break;return z}function Ha(U){return U.length===0?0:U[0]===$r.FIRST_DIM_SIZE?U.length-1:U.length}function Ut(U,E){if(U==null||E==null)return;const z=U.length,q=E.length;if(z>=q)throw new Error(`defaultValue.shape=${U} and ragged tensor flatValues.shape=${E}, are incompatible: defaultValue.rank = ${z} must be less than ragged tensor input flatValues.rank = ${q})`);for(let se=0;se<Math.min(z,q-1);++se){const _e=U[se],Me=E[se+1];if(_e>=0&&Me>=0&&_e!==1&&_e!==Me)throw new Error(`defaultValue.shape=${U}, and ragged tensor input flatValues.shape=${E} are incompatible: defaultValue.shape[${se-U.length}] = ${_e} but ragged tensor input.flatValues.shape[${se-U.length}] = ${Me}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ta=30;function To(U){return U<=ta?U:(0,ce.jP)(U,Math.floor(Math.sqrt(U)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ma(U,E,z){const q=z*(typeof U=="number"?U:U[0]),se=E*(typeof U=="number"?U:U[1]);return[q,se]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gt(U,E,z,q=!0){let se=[];if(q)se=se.concat(E.slice(0)),se.push(U[0]/z),se=se.concat(U.slice(1));else{se=se.concat(U[0]);const _e=E.length;for(let Me=0;Me<_e;++Me)se=se.concat([U[Me+1]/E[Me],E[Me]]);se=se.concat(U.slice(_e+1))}return se}function Nr(U,E,z=!0){const q=[];if(z){q.push(E);for(let se=E+1;se<U;++se)se<=2*E?(q.push(se),q.push(se-(E+1))):q.push(se)}else{const se=[],_e=[];for(let Me=1;Me<U;++Me)Me>=E*2+1||Me%2===1?_e.push(Me):se.push(Me);q.push(...se),q.push(0),q.push(..._e)}return q}function ga(U,E,z,q=!0){const se=[];q?se.push(U[0]/z):se.push(U[0]*z);for(let _e=1;_e<U.length;++_e)_e<=E.length?q?se.push(E[_e-1]*U[_e]):se.push(U[_e]/E[_e-1]):se.push(U[_e]);return se}function mr(U,E){const z=[0];for(let q=0;q<E;++q)z.push(U[q][0]);return z}function gr(U,E,z){const q=U.slice(0,1);for(let se=0;se<z;++se)q.push(U[se+1]-E[se][0]-E[se][1]);return q}function na(U,E){const z=U.shape.length,q=E.shape.length;if(z<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${z}.`);if(q<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${q}.`);if(E.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${E.dtype}.`);if(E.shape[q-1]>z)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${E.shape[q-1]} vs. ${z}`);if((0,ce.NA)(U.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${U.shape}.`);const se=E.shape,_e=se[se.length-1];let Me=1;for(let _t=0;_t<se.length-1;++_t)Me*=se[_t];const et=U.shape,bt=se.slice();bt.pop();let It=1;for(let _t=_e;_t<z;++_t)It*=et[_t],bt.push(et[_t]);const sn=[...(0,ce.e3)(U.shape).map(_t=>_t/It),1].slice(0,_e);return[bt,Me,It,sn]}var h=L(1820);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N=1.7580993408473768,A=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q=.3275911,ge=.254829592,ke=-.284496736,Ie=1.421413741,He=-1.453152027,lt=1.061405429;var Rt=L(3386);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zt(U,E){if(U.length!==E.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${U.length}, imag: ${E.length}.`);const z=new Float32Array(U.length*2);for(let q=0;q<z.length;q+=2)z[q]=U[q/2],z[q+1]=E[q/2];return z}function yn(U){const E=new Float32Array(U.length/2),z=new Float32Array(U.length/2);for(let q=0;q<U.length;q+=2)E[q/2]=U[q],z[q/2]=U[q+1];return{real:E,imag:z}}function an(U){const E=Math.ceil(U.length/4),z=new Float32Array(E),q=new Float32Array(E);for(let se=0;se<U.length;se+=4)z[Math.floor(se/4)]=U[se],q[Math.floor(se/4)]=U[se+1];return{real:z,imag:q}}function Xt(U){const E=Math.floor(U.length/4),z=new Float32Array(E),q=new Float32Array(E);for(let se=2;se<U.length;se+=4)z[Math.floor(se/4)]=U[se],q[Math.floor(se/4)]=U[se+1];return{real:z,imag:q}}function xn(U,E){const z=U[E*2],q=U[E*2+1];return{real:z,imag:q}}function Tn(U,E,z,q){U[q*2]=E,U[q*2+1]=z}function ss(U,E){const z=new Float32Array(U/2),q=new Float32Array(U/2);for(let se=0;se<Math.ceil(U/2);se++){const _e=(E?2:-2)*Math.PI*(se/U);z[se]=Math.cos(_e),q[se]=Math.sin(_e)}return{real:z,imag:q}}function Yn(U,E,z){const q=(z?2:-2)*Math.PI*(U/E),se=Math.cos(q),_e=Math.sin(q);return{real:se,imag:_e}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gs="->",cr=/->/g,Is=",",Fn="...";function Es(U,E){U=U.replace(/\s/g,"");const z=(U.length-U.replace(cr,"").length)/gs.length;if(z<1)throw new Error("Equations without an arrow are not supported.");if(z>1)throw new Error(`Equation must contain exactly one arrow ("${gs}").`);const[q,se]=U.split(gs);(0,ce.hu)(q.indexOf(Fn)===-1,()=>`The ellipsis notation ("${Fn}") is not supported yet.`);const _e=q.split(Is),Me=_e.length;if(E!==Me)throw new Error(`Expected ${Me} input tensors, received ${E}`);if(Me>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const et=[];for(let Tt=0;Tt<se.length;++Tt){const Kt=se[Tt];if(!_e.some($n=>$n.indexOf(Kt)!==-1))throw new Error(`Output subscripts contain the label ${Kt} not present in the input subscripts.`);et.indexOf(Kt)===-1&&et.push(Kt)}for(let Tt=0;Tt<q.length;++Tt){const Kt=q[Tt];et.indexOf(Kt)===-1&&Kt!==Is&&et.push(Kt)}const bt=new Array(_e.length);for(let Tt=0;Tt<Me;++Tt){if(new Set(_e[Tt].split("")).size!==_e[Tt].length)throw new Error(`Found duplicate axes in input component ${_e[Tt]}. Support for duplicate axes in input is not implemented yet.`);bt[Tt]=[];for(let Kt=0;Kt<_e[Tt].length;++Kt)bt[Tt].push(et.indexOf(_e[Tt][Kt]))}const It=et.length,sn=se.length,_t=[];for(let Tt=sn;Tt<It;++Tt)_t.push(Tt);return{allDims:et,summedDims:_t,idDims:bt}}function os(U,E){let z=new Array(U);z.fill(-1);for(let se=0;se<E.length;++se)z[E[se]]=se;const q=[];for(let se=0;se<U;++se)z[se]===-1&&q.push(se);return z=z.filter(se=>se!==-1),{permutationIndices:z,expandDims:q}}function Ta(U,E,z){const q=new Array(U);for(let se=0;se<z.length;++se){const _e=z[se].shape;for(let Me=0;Me<E[se].length;++Me)q[E[se][Me]]===void 0?q[E[se][Me]]=_e[Me]:(0,ce.hu)(q[E[se][Me]]===_e[Me],()=>`Expected dimension ${q[E[se][Me]]} at axis ${Me} of input shaped ${JSON.stringify(_e)}, but got dimension ${_e[Me]}`)}}function $a(U,E){const z=U,q=[];let se=0;U.length===0&&z.push(-1),se=U.length+1;for(let Me=0;Me<se;++Me)q.push([]);const _e=[];for(let Me=0;Me<z.length;++Me){const et=z[Me],bt=jo(E,et);for(const It of bt)_e.indexOf(It)===-1&&(q[Me].push(It),_e.push(It))}return{path:z,steps:q}}function ya(U){return U.every((E,z)=>E===z)}function jo(U,E){const z=[];for(let q=0;q<U.length;++q)(U[q].length===0||U[q].indexOf(E)!==-1||E===-1)&&z.push(q);return z}function $o(U,E,z=0){let q=[];if(typeof E=="number")(0,ce.hu)(U.shape[z]%E===0,()=>"Number of splits must evenly divide the axis."),q=new Array(E).fill(U.shape[z]/E);else{const se=E.reduce((Me,et)=>(et===-1&&(Me+=1),Me),0);(0,ce.hu)(se<=1,()=>"There should be only one negative value in split array.");const _e=E.indexOf(-1);if(_e!==-1){const Me=E.reduce((et,bt)=>bt>0?et+bt:et);E[_e]=U.shape[z]-Me}(0,ce.hu)(U.shape[z]===E.reduce((Me,et)=>Me+et),()=>"The sum of sizes must match the size of the axis dimension."),q=E}return q}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kr(U){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${U}`}function Ko(U,E){return`indices(${U}, 0) is invalid: ${E} < 0`}function ii(U,E,z){return`indices(${U}, 0) is invalid: ${E} >= ${z}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Na(U,E){return`only one output dimension may be -1, not both ${U} and ${E}`}function Ft(U,E){return`size ${U} must be non-negative, not ${E}`}function ja(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Yr(U,E){const z=(0,ce.NA)(U),q=(0,ce.NA)(E);return`Input to reshape is a SparseTensor with ${z}
  dense values, but the requested shape requires a multiple of ${q}. inputShape=${U} outputShape= ${E}`}function yr(U,E){const z=(0,ce.NA)(U),q=(0,ce.NA)(E);return`Input to reshape is a tensor with ${z} dense values, but the requested shape has ${q}. inputShape=${U} outputShape=${E}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ui(){return"segment ids must be >= 0"}function Ka(){return"segment ids are not increasing"}function Vi(U,E){return`Segment id ${U} out of range [0, ${E}), possibly because segmentIds input is not sorted.`}function li(U,E,z){return`Bad: indices[${U}] == ${E} out of range [0, ${z})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ci(U,E){let z=!1,q;for(U<=ta?(q=U,z=!0):q=(0,ce.jP)(U,Math.floor(Math.sqrt(U)));!z;)q>E||q===U?z=!0:q=(0,ce.jP)(U,q+1);return q}function di(U,E,z){const q=[],se=U.length;for(let _e=0;_e<se;_e++)_e!==E?q.push(U[_e]):q.push(z);return q}function No(U,E,z,q){const se=E.shape.length,_e=U.shape.length;if(q!==0&&(q<-se||q>se))throw new Error(`Expect batchDims in the range of [-${se}, ${se}], but got ${q}`);if(q<0&&(q+=se),q>_e)throw new Error(`batchDims (${q}) must be less than rank(x) (
    ${_e}).`);if(z<q)throw new Error(`batchDims (${q}) must be less than or equal to axis (${z}).`);for(let _t=0;_t<q;++_t)if(U.shape[_t]!==E.shape[_t])throw new Error(`x.shape[${_t}]: ${U.shape[_t]} should be equal to indices.shape[${_t}]: ${E.shape[_t]}.`);const Me=U.shape[z],et=[];let bt=1,It=1,sn=1;for(let _t=0;_t<q;++_t)et.push(U.shape[_t]),bt*=U.shape[_t];for(let _t=q;_t<z;_t++)et.push(U.shape[_t]),It*=U.shape[_t];for(let _t=q;_t<se;_t++)et.push(E.shape[_t]);for(let _t=z+1;_t<_e;_t++)et.push(U.shape[_t]),sn*=U.shape[_t];return{batchSize:bt,sliceSize:sn,outerSize:It,dimSize:Me,outputShape:et}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hi(U){try{return U.map(E=>(0,co.decodeString)(E))}catch(E){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${E}`)}}function Xa(U){return U.map(E=>(0,co.encodeString)(E))}var ka=L(8135),pi=L(9560);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ya=L(3993);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */wo()},4028:function(Wt,dt,L){"use strict";L.d(dt,{w:()=>ze});var p=L(2891);class ze{static join(P){return new ze(P).slice()}constructor(P){if(this.shards=[],this.previousShardIndex=0,P==null||(P instanceof Array||(P=[P]),P=P.map(pe=>p.isTypedArray(pe)?pe.buffer:pe),P.length===0))return;this.bufferUniformSize=P[0].byteLength;let W=0;for(let pe=0;pe<P.length;pe++){const ee=P[pe];pe!==P.length-1&&ee.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const we=W+ee.byteLength;this.shards.push({buffer:ee,start:W,end:we}),W=we}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(P=0,W=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(P=isNaN(Number(P))?0:P,W=isNaN(Number(W))?0:W,P=Math.max(0,P),W=Math.min(this.byteLength,W),W<=P)return new ArrayBuffer(0);const pe=this.findShardForByte(P);if(pe===-1)throw new Error(`Could not find start shard for byte ${P}`);const ee=W-P,we=new ArrayBuffer(ee),xe=new Uint8Array(we);let K=0;for(let _=pe;_<this.shards.length;_++){const De=this.shards[_],Ke=P+K-De.start,rt=K,Vt=Math.min(W,De.end)-De.start,on=new Uint8Array(De.buffer,Ke,Vt-Ke);if(xe.set(on,rt),K+=on.length,W<De.end)break}return we}findShardForByte(P){if(this.shards.length===0||P<0||P>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(P/this.bufferUniformSize),this.previousShardIndex;function W(ee){return P<ee.start?-1:P>=ee.end?1:0}if(W(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const pe=Z(this.shards,W);return pe===-1?-1:(this.previousShardIndex=pe,this.previousShardIndex)}}function Z(ie,P){let W=0,pe=ie.length;for(;W<=pe;){const ee=Math.floor((pe-W)/2)+W,we=P(ie[ee]);if(we===0)return ee;we<0?pe=ee:W=ee+1}return-1}},1146:function(Wt,dt,L){"use strict";L.d(dt,{EZ:()=>y,JY:()=>ve,Q:()=>G,Yd:()=>Qe,_n:()=>on,dI:()=>xe,hu:()=>Re,jN:()=>re,ji:()=>V,n7:()=>$t,r:()=>Ke,yz:()=>we});var p=L(1788),ze=L(4594),Z=L(9024),ie=L(1864),P=L(4028),W=L(4531),pe=L(6650);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ee=4;async function we(ne,Ne){const Ve=[],ce=[],me=Array.isArray(ne)?ne.map(ct=>ct.name):Object.keys(ne);for(let ct=0;ct<me.length;++ct){const Lt=me[ct],Nt=Array.isArray(ne)?ne[ct].tensor:ne[Lt];if(Nt.dtype!=="float32"&&Nt.dtype!=="int32"&&Nt.dtype!=="bool"&&Nt.dtype!=="string"&&Nt.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${Lt}': ${Nt.dtype}`);const ln={name:Lt,shape:Nt.shape,dtype:Nt.dtype};if(Nt.dtype==="string"){const Sn=new Promise(async tn=>{const kn=await Nt.bytes(),bn=kn.reduce((Xn,Te)=>Xn+Te.length,0)+ee*kn.length,nn=new Uint8Array(bn);let ps=0;for(let Xn=0;Xn<kn.length;Xn++){const Te=kn[Xn],Je=new Uint8Array(new Uint32Array([Te.length]).buffer);nn.set(Je,ps),ps+=ee,nn.set(Te,ps),ps+=Te.length}tn(nn)});ce.push(Sn)}else ce.push(Nt.data());Ne!=null&&(ln.group=Ne),Ve.push(ln)}const pt=await Promise.all(ce);return{data:rt(pt),specs:Ve}}function xe(ne,Ne){const Ve=new P.w(ne),ce={};let me=0;for(const pt of Ne){const ct=K(pt,(Lt,Nt)=>Ve.slice(me+Lt,me+Nt));ce[pt.name]=De(pt,Ve.slice(me,me+ct)),me+=ct}return ce}function K(ne,Ne){const Ve=(0,Z.NA)(ne.shape);let ce;if("quantization"in ne){const me=ne.quantization;ce=ie.J[me.dtype]}else if(ne.dtype==="string"){let me=0;for(let pt=0;pt<Ve;pt++)me+=ee+new Uint32Array(Ne(me,me+ee))[0];return me}else ce=ie.J[ne.dtype];return Ve*ce}async function _(ne,Ne){const Ve=(0,Z.NA)(ne.shape);let ce;if("quantization"in ne){const me=ne.quantization;ce=ie.J[me.dtype]}else if(ne.dtype==="string"){let me=0;for(let pt=0;pt<Ve;pt++)me+=ee+new Uint32Array(await Ne(me,me+ee))[0];return me}else ce=ie.J[ne.dtype];return Ve*ce}function De(ne,Ne){const Ve=ne.name,ce=ne.dtype,me=ne.shape,pt=(0,Z.NA)(me);let ct,Lt=0;if("quantization"in ne){const Nt=ne.quantization;if(Nt.dtype==="uint8"||Nt.dtype==="uint16"){if(!("min"in Nt&&"scale"in Nt))throw new Error(`Weight ${ne.name} with quantization ${Nt.dtype} doesn't have corresponding metadata min and scale.`)}else if(Nt.dtype==="float16"){if(ce!=="float32")throw new Error(`Weight ${ne.name} is quantized with ${Nt.dtype} which only supports weights of type float32 not ${ce}.`)}else throw new Error(`Weight ${ne.name} has unknown quantization dtype ${Nt.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const ln=ie.J[Nt.dtype],Sn=Nt.dtype==="uint8"?new Uint8Array(Ne):new Uint16Array(Ne);if(ce==="float32")if(Nt.dtype==="uint8"||Nt.dtype==="uint16"){ct=new Float32Array(Sn.length);for(let tn=0;tn<Sn.length;tn++){const kn=Sn[tn];ct[tn]=kn*Nt.scale+Nt.min}}else if(Nt.dtype==="float16")ct=nt()(Sn);else throw new Error(`Unsupported quantization type ${Nt.dtype} for weight type float32.`);else if(ce==="int32"){if(Nt.dtype!=="uint8"&&Nt.dtype!=="uint16")throw new Error(`Unsupported quantization type ${Nt.dtype} for weight type int32.`);ct=new Int32Array(Sn.length);for(let tn=0;tn<Sn.length;tn++){const kn=Sn[tn];ct[tn]=Math.round(kn*Nt.scale+Nt.min)}}else throw new Error(`Unsupported dtype in weight '${Ve}': ${ce}`);Lt+=pt*ln}else if(ce==="string"){const Nt=(0,Z.NA)(ne.shape);ct=[];for(let ln=0;ln<Nt;ln++){const Sn=new Uint32Array(Ne.slice(Lt,Lt+ee))[0];Lt+=ee;const tn=new Uint8Array(Ne.slice(Lt,Lt+Sn));ct.push(tn),Lt+=Sn}}else{const Nt=ie.J[ce];if(ce==="float32")ct=new Float32Array(Ne);else if(ce==="int32")ct=new Int32Array(Ne);else if(ce==="bool")ct=new Uint8Array(Ne);else if(ce==="complex64"){ct=new Float32Array(Ne);const ln=new Float32Array(ct.length/2),Sn=new Float32Array(ct.length/2);for(let nn=0;nn<ln.length;nn++)ln[nn]=ct[nn*2],Sn[nn]=ct[nn*2+1];const tn=(0,ze.X)(ln,me,"float32"),kn=(0,ze.X)(Sn,me,"float32"),bn=(0,p.P)(tn,kn);return tn.dispose(),kn.dispose(),bn}else throw new Error(`Unsupported dtype in weight '${Ve}': ${ce}`);Lt+=pt*Nt}return(0,ze.X)(ct,me,ce)}async function Fe(ne,Ne,Ve){let ce=new Uint8Array(Ne);for(;ce.byteLength<Ve;){const{done:me,value:pt}=await ne.read();if(me&&pt==null){const Lt=Ve-ce.byteLength;throw new Error(`Reader is done but ${Lt} bytes are still expected`)}const ct=new Uint8Array(ce.length+pt.byteLength);ct.set(ce,0),ct.set(new Uint8Array(pt),ce.length),ce=ct}return ce.buffer}async function Ke(ne,Ne){const Ve={},ce=ne.getReader();let me=new ArrayBuffer(0);for(const pt of Ne){const ct=await _(pt,async(ln,Sn)=>(me=await Fe(ce,me,Sn),me.slice(ln,Sn)));me=await Fe(ce,me,ct);const Lt=me.slice(0,ct);me=me.slice(ct);const Nt=De(pt,Lt);if(Ve[pt.name]=Nt,(0,W.N_)()==="webgpu"){const ln=(0,W.y3)();"uploadToGPU"in ln&&(0,Z.NA)(Nt.shape)>=(0,pe.OB)().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&ln.uploadToGPU(Nt.dataId)}}return Ve}function rt(ne){if(ne===null)throw new Error(`Invalid input value: ${JSON.stringify(ne)}`);let Ne=0;const Ve=[];ne.forEach(pt=>{if(Ne+=pt.byteLength,Ve.push(pt.byteLength===pt.buffer.byteLength?pt:new pt.constructor(pt)),!(pt instanceof Float32Array||pt instanceof Int32Array||pt instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${pt.constructor.name}`)});const ce=new Uint8Array(Ne);let me=0;return Ve.forEach(pt=>{ce.set(new Uint8Array(pt.buffer),me),me+=pt.byteLength}),ce.buffer}const ht=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function Vt(ne){return ht?Buffer.byteLength(ne,"utf8"):new Blob([ne]).size}function on(ne){if(ht)return Buffer.from(ne).toString("base64");const Ne=new Uint8Array(ne);let Ve="";for(let ce=0,me=Ne.length;ce<me;ce++)Ve+=String.fromCharCode(Ne[ce]);return btoa(Ve)}function $t(ne){if(ht){const ce=Buffer.from(ne,"base64");return ce.buffer.slice(ce.byteOffset,ce.byteOffset+ce.byteLength)}const Ne=atob(ne),Ve=new Uint8Array(Ne.length);for(let ce=0;ce<Ne.length;++ce)Ve.set([Ne.charCodeAt(ce)],ce);return Ve.buffer}function ve(ne){return P.w.join(ne)}function y(ne){const Ne="/";for(ne=ne.trim();ne.endsWith(Ne);)ne=ne.slice(0,ne.length-1);const Ve=ne.split(Ne);return Ve[Ve.length-1]}function Qe(ne,Ne){const Ve={modelTopology:ne.modelTopology,format:ne.format,generatedBy:ne.generatedBy,convertedBy:ne.convertedBy,weightsManifest:Ne};return ne.signature!=null&&(Ve.signature=ne.signature),ne.userDefinedMetadata!=null&&(Ve.userDefinedMetadata=ne.userDefinedMetadata),ne.modelInitializer!=null&&(Ve.modelInitializer=ne.modelInitializer),ne.initializerSignature!=null&&(Ve.initializerSignature=ne.initializerSignature),ne.trainingConfig!=null&&(Ve.trainingConfig=ne.trainingConfig),Ve}function V(ne,Ne,Ve){const ce={modelTopology:ne.modelTopology,format:ne.format,generatedBy:ne.generatedBy,convertedBy:ne.convertedBy};if(ne.trainingConfig!=null&&(ce.trainingConfig=ne.trainingConfig),ne.weightsManifest!=null){if(!Ne)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!Ve)throw new Error("modelJSON has weightsManifest but weightData is null");ce.weightSpecs=Ne,ce.weightData=Ve}return ne.signature!=null&&(ce.signature=ne.signature),ne.userDefinedMetadata!=null&&(ce.userDefinedMetadata=ne.userDefinedMetadata),ne.modelInitializer!=null&&(ce.modelInitializer=ne.modelInitializer),ne.initializerSignature!=null&&(ce.initializerSignature=ne.initializerSignature),ce}async function re(ne,Ne){let Ve,ce;return ne.weightsManifest!=null&&([Ve,ce]=await Ne(ne.weightsManifest)),V(ne,Ve,ce)}function G(ne){if(ne.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:ne.modelTopology==null?0:Vt(JSON.stringify(ne.modelTopology)),weightSpecsBytes:ne.weightSpecs==null?0:Vt(JSON.stringify(ne.weightSpecs)),weightDataBytes:ne.weightData==null?0:new P.w(ne.weightData).byteLength}}function Re(ne){const Ne=[];for(const Ve of ne)Ne.push(...Ve.weights);return Ne}function Be(){const ne=Ve=>{let ce=Ve<<13,me=0;for(;(ce&8388608)===0;)me-=8388608,ce<<=1;return ce&=-8388609,me+=947912704,ce|me},Ne=new Uint32Array(2048);Ne[0]=0;for(let Ve=1;Ve<1024;Ve++)Ne[Ve]=ne(Ve);for(let Ve=1024;Ve<2048;Ve++)Ne[Ve]=939524096+(Ve-1024<<13);return Ne}function at(){const ne=new Uint32Array(64);ne[0]=0,ne[31]=1199570944,ne[32]=2147483648,ne[63]=3347054592;for(let Ne=1;Ne<31;Ne++)ne[Ne]=Ne<<23;for(let Ne=33;Ne<63;Ne++)ne[Ne]=2147483648+(Ne-32<<23);return ne}function S(){const ne=new Uint32Array(64);for(let Ne=0;Ne<64;Ne++)ne[Ne]=1024;return ne[0]=ne[32]=0,ne}function nt(){const ne=Be(),Ne=at(),Ve=S();return ce=>{const me=new ArrayBuffer(4*ce.length),pt=new Uint32Array(me);for(let ct=0;ct<ce.length;ct++){const Lt=ce[ct],Nt=ne[Ve[Lt>>10]+(Lt&1023)]+Ne[Lt>>10];pt[ct]=Nt}return new Float32Array(me)}}},1864:function(Wt,dt,L){"use strict";L.d(dt,{J:()=>p});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8}},4403:function(Wt,dt,L){"use strict";L.d(dt,{$HU:()=>Co,$g6:()=>cn,$w:()=>ps,Acj:()=>br,BMI:()=>Zn,BiW:()=>as,Byc:()=>Lt,CAk:()=>ws,CQl:()=>cs,D2d:()=>At,DlI:()=>vo,Eh3:()=>S,FKq:()=>Ae,G3Y:()=>Vr,GBy:()=>Pe,Gcp:()=>Oe,HEU:()=>Un,HZH:()=>fs,Hhh:()=>Js,Hmb:()=>An,IKK:()=>pe,IMb:()=>Vt,J$2:()=>wn,J_u:()=>pr,JhU:()=>Ke,L8s:()=>je,M2y:()=>xe,MIZ:()=>Cn,MRv:()=>Ee,MZg:()=>Os,NEP:()=>As,NZg:()=>oo,O3z:()=>st,OAf:()=>Ro,OR:()=>eo,OU7:()=>Cr,OV7:()=>no,Omj:()=>Kn,Oyi:()=>De,PYm:()=>vr,PhF:()=>Er,QCc:()=>Fe,QRR:()=>Sn,Qg5:()=>Ps,QiL:()=>Ao,Qvg:()=>Io,RFZ:()=>re,ROF:()=>rt,RQH:()=>ur,RuY:()=>zr,SIB:()=>Ir,SX0:()=>Rn,SYM:()=>p,SbG:()=>nr,SpW:()=>Z,T0n:()=>tn,TQc:()=>We,TR1:()=>ct,ToN:()=>Xr,Tr8:()=>Pn,Uyb:()=>Ys,VGw:()=>ze,Vbg:()=>wo,VcC:()=>ln,VfG:()=>Or,Vn9:()=>Je,W0H:()=>_o,XLW:()=>on,XkS:()=>pn,Xze:()=>P,Y0y:()=>Ar,YFo:()=>_r,YoZ:()=>Hr,ZbH:()=>Pr,ZjV:()=>yt,Zz9:()=>Be,_JP:()=>Pt,_V0:()=>Go,_Yw:()=>Ur,_k9:()=>ht,_tC:()=>xt,a5O:()=>de,aJk:()=>we,avt:()=>mn,b9H:()=>Fo,bK0:()=>Qt,bV0:()=>Mr,c17:()=>Sr,cWu:()=>kt,cie:()=>kn,cye:()=>Do,dDz:()=>Po,deh:()=>Jr,dpD:()=>uo,e07:()=>So,e0R:()=>gt,e6w:()=>Oo,e7N:()=>ns,eBW:()=>ea,eEB:()=>V,eZ0:()=>Ms,ekb:()=>Te,gJX:()=>G,h8e:()=>Wn,hCO:()=>y,hGc:()=>ft,hdR:()=>Us,i5y:()=>fe,iHb:()=>Nt,iJz:()=>wr,iWB:()=>le,iZT:()=>hr,ik2:()=>me,jMg:()=>_,jQk:()=>Ct,jQs:()=>ro,jeX:()=>bo,kU:()=>ls,kpP:()=>lo,kuV:()=>er,luS:()=>Ho,lyA:()=>jr,mKl:()=>ir,mTV:()=>vs,mc4:()=>pt,mhS:()=>nt,mm_:()=>ie,n9L:()=>Hn,nhH:()=>ut,nr8:()=>Jn,o0g:()=>zo,o2y:()=>ce,oFR:()=>Wr,oHH:()=>Ot,oT6:()=>W,p2w:()=>Fs,p4S:()=>Xn,pe_:()=>Kr,q1x:()=>Gr,q2K:()=>fr,q8u:()=>so,qWM:()=>ao,qi_:()=>ks,qkr:()=>Ss,qw7:()=>K,r7n:()=>Dn,s1s:()=>fn,sEM:()=>Jt,sHE:()=>to,sJF:()=>ee,sL$:()=>bn,usg:()=>lr,uv1:()=>tr,vFR:()=>Cs,vtC:()=>qs,vwp:()=>Ns,w3H:()=>tt,wUP:()=>ne,wYB:()=>Se,wYn:()=>js,we_:()=>ms,wm:()=>Ne,wx7:()=>Tr,x12:()=>Ve,xJR:()=>Lr,xQA:()=>Ye,xnO:()=>Re,y7R:()=>nn,yQU:()=>Br,yj2:()=>at,zbQ:()=>ar,zvY:()=>ve,zws:()=>$t});const p="Abs",ze="Acos",Z="Acosh",ie="Add",P="AddN",W="All",pe="Any",ee="ArgMax",we="ArgMin",xe="Asin",K="Asinh",_="Atan",De="Atanh",Fe="Atan2",Ke="AvgPool",rt="AvgPoolGrad",ht="AvgPool3D",Vt="AvgPool3DGrad",on="BatchMatMul",$t="BatchToSpaceND",ve="Bincount",y="BitwiseAnd",Qe="BroadcastTo",V="BroadcastArgs",re="Cast",G="Ceil",Re="ClipByValue",Be="Complex",at="ComplexAbs",S="Concat",nt="Conv2D",ne="Conv2DBackpropFilter",Ne="Conv2DBackpropInput",Ve="Conv3D",ce="Conv3DBackpropFilterV2",me="Conv3DBackpropInputV2",pt="Cos",ct="Cosh",Lt="Cumprod",Nt="Cumsum",ln="CropAndResize",Sn="DenseBincount",tn="DepthToSpace",kn="DepthwiseConv2dNative",bn="DepthwiseConv2dNativeBackpropFilter",nn="DepthwiseConv2dNativeBackpropInput",ps="Diag",Xn="Dilation2D",Te="Dilation2DBackpropInput",Je="Dilation2DBackpropFilter",ft="Draw",Ot="RealDiv",cn="Einsum",Rn="Elu",Un="EluGrad",Kn="Erf",Us="Equal",As="Exp",_r="ExpandDims",Ar="Expm1",Ns="FFT",Jr="Fill",Ys="FlipLeftRight",eo="Floor",bo="FloorDiv",to="FusedBatchNorm",ks="GatherV2",Gr="GatherNd",hr="Greater",br="GreaterEqual",wr="Identity",Ps="IFFT",pr="Imag",mn="IsFinite",le="IsInf",Dn="IsNan",wn="LeakyRelu",qs="Less",ws="LessEqual",ns="LinSpace",Pr="Log",ls="Log1p",vr="LogicalAnd",Or="LogicalNot",Os="LogicalOr",Qs="LogicalXor",Jo="LogSoftmax",Zs="LowerBound",Ms="LRN",Js="LRNGrad",Fr="MatrixBandPart",Hr="Max",Zn="Maximum",vs="MaxPool",no="MaxPoolGrad",Ro="MaxPool3D",Cr="MaxPool3DGrad",Cs="MaxPoolWithArgmax",fr="Mean",Sr="Min",so="Minimum",ro="MirrorPad",wo="Mod",oo="Multinomial",js="Multiply",er="Neg",Br="NotEqual",tr="NonMaxSuppressionV3",Do="NonMaxSuppressionV4",_o="NonMaxSuppressionV5",ao="OnesLike",ms="OneHot",Ao="Pack",jr="PadV2",Ws="Pool",Kr="Pow",zo="Prelu",vo="Prod",Po="RaggedGather",cs="RaggedRange",as="RaggedTensorToTensor",Oo="Range",Lr="Real",Co="Reciprocal",Ss="Relu",fs="Reshape",uo="ResizeNearestNeighbor",An="ResizeNearestNeighborGrad",Ur="ResizeBilinear",ar="ResizeBilinearGrad",nr="Relu6",ir="Reverse",So="Round",Mr="Rsqrt",Ye="ScatterNd",Ir="TensorScatterUpdate",Jn="SearchSorted",Er="Select",Wr="Selu",Fs="Slice",ur="Sin",Se="Sinh",fe="Sign",de="Sigmoid",Ee="Softplus",Ae="Sqrt",Pe="Sum",We="SpaceToBatchND",je="SplitV",Oe="Softmax",st="SparseFillEmptyRows",ut="SparseReshape",tt="SparseSegmentMean",yt="SparseSegmentSum",At="SparseToDense",xt="SquaredDifference",Qt="Square",gt="StaticRegexReplace",Ct="StridedSlice",Pt="StringNGrams",fn="StringSplit",pn="StringToHashBucketFast",Pn="Sub",Jt="Tan",Cn="Tanh",Hn="Tile",kt="TopK",Tr="Transform",Vr="Transpose",lo="Unique",Xr="Unpack",Io="UnsortedSegmentSum",co="UpperBound",zr="ZerosLike",Wn="Step",ea="FromPixels",Fo="RotateWithOffset",lr="_FusedMatMul",Go="FusedConv2D",Ho="FusedDepthwiseConv2D"},5042:function(Wt,dt,L){"use strict";L.d(dt,{pI:()=>P,tr:()=>pe,uk:()=>W,wC:()=>ee});var p=L(2360),ze=L(3386);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z=(0,p.R)("kernelRegistry",()=>new Map),ie=(0,p.R)("gradRegistry",()=>new Map);function P(Fe,Ke){const rt=De(Fe,Ke);return Z.get(rt)}function W(Fe){return ie.get(Fe)}function pe(Fe){const Ke=Z.entries(),rt=[];for(;;){const{done:ht,value:Vt}=Ke.next();if(ht)break;const[on,$t]=Vt,[ve]=on.split("_");ve===Fe&&rt.push($t)}return rt}function ee(Fe){const{kernelName:Ke,backendName:rt}=Fe,ht=De(Ke,rt);Z.has(ht)&&ze.Z(`The kernel '${Ke}' for backend '${rt}' is already registered`),Z.set(ht,Fe)}function we(Fe){const{kernelName:Ke}=Fe;ie.has(Ke)&&env().getBool("DEBUG")&&log.warn(`Overriding the gradient for '${Ke}'`),ie.set(Ke,Fe)}function xe(Fe,Ke){const rt=De(Fe,Ke);if(!Z.has(rt))throw new Error(`The kernel '${Fe}' for backend '${Ke}' is not registered`);Z.delete(rt)}function K(Fe){if(!ie.has(Fe))throw new Error(`The gradient '${Fe}' for backend is not registered`);ie.delete(Fe)}function _(Fe,Ke){pe(Fe).forEach(ht=>{const Vt=Object.assign({},ht,{backendName:Ke});ee(Vt)})}function De(Fe,Ke){return`${Ke}_${Fe}`}},3386:function(Wt,dt,L){"use strict";L.d(dt,{Z:()=>ze,c:()=>Z});var p=L(6650);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ze(...ie){(0,p.OB)().getBool("IS_TEST")||(0,p.OB)().getBool("PROD")||console.warn(...ie)}function Z(...ie){(0,p.OB)().getBool("IS_TEST")||(0,p.OB)().getBool("PROD")||console.log(...ie)}},5136:function(Wt,dt,L){"use strict";L.d(dt,{W:()=>W});var p=L(6201),ze=L(4403),Z=L(6857),ie=L(7264);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P(pe){const ee=(0,Z._1)(pe,"x","abs");if(ee.dtype==="complex64"){const we={x:ee};return p.BV.runKernel(ze.yj2,we)}else{const we={x:ee};return p.BV.runKernel(ze.SYM,we)}}const W=(0,ie.op)({abs_:P})},2364:function(Wt,dt,L){"use strict";L.d(dt,{I:()=>pe});var p=L(6201),ze=L(4403),Z=L(6802),ie=L(6857),P=L(7264);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W(ee,we){let xe=(0,ie._1)(ee,"a","add"),K=(0,ie._1)(we,"b","add");[xe,K]=(0,Z.T_)(xe,K);const _={a:xe,b:K};return p.BV.runKernel(ze.mm_,_)}const pe=(0,P.op)({add_:W})},7199:function(Wt,dt,L){"use strict";L.d(dt,{LJ:()=>ee,Q3:()=>pe,Vh:()=>Z,YB:()=>ze,kz:()=>ie,lB:()=>W,rv:()=>P,sY:()=>we});var p=L(9024);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ze(xe,K){for(let _=0;_<xe.length;++_)if(xe[xe.length-_-1]!==K-1-_)return!1;return!0}function Z(xe,K,_){const De=xe.length+K.length,Fe=[];let Ke=0,rt=0;for(let ht=0;ht<De;ht++)_.indexOf(ht)===-1?Fe.push(xe[Ke++]):Fe.push(K[rt++]);return Fe}function ie(xe,K){const _=[],De=xe.length;for(let Ke=0;Ke<De;Ke++)K.indexOf(Ke)===-1&&_.push(xe[Ke]);const Fe=K.map(Ke=>xe[Ke]);return[_,Fe]}function P(xe,K){const _=K.map(De=>1);return Z(xe,_,K)}function W(xe,K,_){p.hu(ze(K,_),()=>`${xe} supports only inner-most axes for now. Got axes ${K} and rank-${_} input.`)}function pe(xe,K){if(ze(xe,K))return null;const _=[];for(let De=0;De<K;++De)xe.indexOf(De)===-1&&_.push(De);return xe.forEach(De=>_.push(De)),_}function ee(xe){return xe.map((K,_)=>[_,K]).sort((K,_)=>K[1]-_[1]).map(K=>K[0])}function we(xe,K){const _=[];for(let De=K-xe;De<K;++De)_.push(De);return _}},6255:function(Wt,dt,L){"use strict";L.r(dt),L.d(dt,{assertAndGetBroadcastShape:()=>Z,getBroadcastDims:()=>p,getReductionAxes:()=>ze});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p(ie,P){const W=ie.length,pe=[];for(let ee=0;ee<W;ee++){const we=W-1-ee,xe=ie[we]||1;(P[P.length-1-ee]||1)>1&&xe===1&&pe.unshift(we)}return pe}function ze(ie,P){const W=[];for(let pe=0;pe<P.length;pe++){const ee=ie[ie.length-pe-1],we=P.length-pe-1,xe=P[we];(ee==null||ee===1&&xe>1)&&W.unshift(we)}return W}function Z(ie,P){const W=Math.max(ie.length,P.length),pe=new Array(W);for(let ee=0;ee<W;ee++){let we=ie[ie.length-ee-1];we==null&&(we=1);let xe=P[P.length-ee-1];if(xe==null&&(xe=1),we===1)pe[W-ee-1]=xe;else if(xe===1)pe[W-ee-1]=we;else if(we!==xe){const K=`Operands could not be broadcast together with shapes ${ie} and ${P}.`;throw Error(K)}else pe[W-ee-1]=we}return pe}},4865:function(Wt,dt,L){"use strict";L.d(dt,{f:()=>Z});var p=L(8990),ze=L(9024);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z(ie,P="float32",W){return P=P||"float32",ze.Mu(ie),new p.YD(ie,P,W)}},8341:function(Wt,dt,L){"use strict";L.d(dt,{p:()=>pe});var p=L(6201),ze=L(4403),Z=L(6857),ie=L(9024),P=L(7264);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W(ee,we){const xe=(0,Z._1)(ee,"x","cast");if(!ie.LP(we))throw new Error(`Failed to cast to unknown dtype ${we}`);if(we==="string"&&xe.dtype!=="string"||we!=="string"&&xe.dtype==="string")throw new Error("Only strings can be casted to strings");const K={x:xe},_={dtype:we};return p.BV.runKernel(ze.RFZ,K,_)}const pe=(0,P.op)({cast_:W})},8155:function(Wt,dt,L){"use strict";L.d(dt,{d:()=>W});var p=L(6201),ze=L(4403),Z=L(6857),ie=L(7264);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P(pe){const we={x:(0,Z._1)(pe,"x","clone","string_or_numeric")};return p.BV.runKernel(ze.iJz,we)}const W=(0,ie.op)({clone_:P})},1788:function(Wt,dt,L){"use strict";L.d(dt,{P:()=>pe});var p=L(6201),ze=L(4403),Z=L(6857),ie=L(9024),P=L(7264);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W(ee,we){const xe=(0,Z._1)(ee,"real","complex"),K=(0,Z._1)(we,"imag","complex");ie.k5(xe.shape,K.shape,`real and imag shapes, ${xe.shape} and ${K.shape}, must match in call to tf.complex().`);const _={real:xe,imag:K};return p.BV.runKernel(ze.Zz9,_)}const pe=(0,P.op)({complex_:W})},2132:function(Wt,dt,L){"use strict";L.d(dt,{I0:()=>rt,Ix:()=>P,Rf:()=>ze,U3:()=>Vt,Xw:()=>Z,aO:()=>we,jT:()=>ht,jw:()=>W,m:()=>$t,pl:()=>ie,sl:()=>on});var p=L(9024);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ze(ve,y,Qe,V,re="NHWC",G){const Re=ve[3],Be=[...y,Re],at=on(re);return P(ve,Be,Qe,G,V,null,null,at)}function Z(ve,y,Qe,V,re,G,Re="channelsLast"){const[Be,at]=xe(y);let S;if(Re==="channelsLast")S=[Be,at,ve[3],ve[3]];else if(Re==="channelsFirst")S=[Be,at,ve[1],ve[1]];else throw new Error(`Unknown dataFormat ${Re}`);return P(ve,S,Qe,V,re,G,!1,Re)}function ie(ve,y,Qe,V,re,G,Re="NDHWC"){const[Be,at,S]=K(y);let nt,ne;if(Re==="NDHWC")ne="channelsLast",nt=[Be,at,S,ve[4],ve[4]];else if(Re==="NCDHW")ne="channelsFirst",nt=[Be,at,S,ve[1],ve[1]];else throw new Error(`Unknown dataFormat ${Re}`);return W(ve,nt,Qe,V,re,!1,ne,G)}function P(ve,y,Qe,V,re,G,Re=!1,Be="channelsLast"){let[at,S,nt,ne]=[-1,-1,-1,-1];if(Be==="channelsLast")[at,S,nt,ne]=ve;else if(Be==="channelsFirst")[at,ne,S,nt]=ve;else throw new Error(`Unknown dataFormat ${Be}`);const[Ne,Ve,,ce]=y,[me,pt]=xe(Qe),[ct,Lt]=xe(V),Nt=_(Ne,ct),ln=_(Ve,Lt),{padInfo:Sn,outHeight:tn,outWidth:kn}=De(re,S,nt,me,pt,Nt,ln,G,Be),bn=Re?ce*ne:ce;let nn;return Be==="channelsFirst"?nn=[at,bn,tn,kn]:Be==="channelsLast"&&(nn=[at,tn,kn,bn]),{batchSize:at,dataFormat:Be,inHeight:S,inWidth:nt,inChannels:ne,outHeight:tn,outWidth:kn,outChannels:bn,padInfo:Sn,strideHeight:me,strideWidth:pt,filterHeight:Ne,filterWidth:Ve,effectiveFilterHeight:Nt,effectiveFilterWidth:ln,dilationHeight:ct,dilationWidth:Lt,inShape:ve,outShape:nn,filterShape:y}}function W(ve,y,Qe,V,re,G=!1,Re="channelsLast",Be){let[at,S,nt,ne,Ne]=[-1,-1,-1,-1,-1];if(Re==="channelsLast")[at,S,nt,ne,Ne]=ve;else if(Re==="channelsFirst")[at,Ne,S,nt,ne]=ve;else throw new Error(`Unknown dataFormat ${Re}`);const[Ve,ce,me,,pt]=y,[ct,Lt,Nt]=K(Qe),[ln,Sn,tn]=K(V),kn=_(Ve,ln),bn=_(ce,Sn),nn=_(me,tn),{padInfo:ps,outDepth:Xn,outHeight:Te,outWidth:Je}=Fe(re,S,nt,ne,ct,Lt,Nt,kn,bn,nn,Be),ft=G?pt*Ne:pt;let Ot;return Re==="channelsFirst"?Ot=[at,ft,Xn,Te,Je]:Re==="channelsLast"&&(Ot=[at,Xn,Te,Je,ft]),{batchSize:at,dataFormat:Re,inDepth:S,inHeight:nt,inWidth:ne,inChannels:Ne,outDepth:Xn,outHeight:Te,outWidth:Je,outChannels:ft,padInfo:ps,strideDepth:ct,strideHeight:Lt,strideWidth:Nt,filterDepth:Ve,filterHeight:ce,filterWidth:me,effectiveFilterDepth:kn,effectiveFilterHeight:bn,effectiveFilterWidth:nn,dilationDepth:ln,dilationHeight:Sn,dilationWidth:tn,inShape:ve,outShape:Ot,filterShape:y}}function pe(ve,y,Qe,V,re){V==null&&(V=we(ve,y,Qe));const G=ve[0],Re=ve[1],Be=Ke((G-y+2*V)/Qe+1,re),at=Ke((Re-y+2*V)/Qe+1,re);return[Be,at]}function ee(ve,y,Qe,V,re,G){re==null&&(re=we(ve,y[0],V[0]));const Re=[0,0,0,Qe];for(let Be=0;Be<3;Be++)ve[Be]+2*re>=y[Be]&&(Re[Be]=Ke((ve[Be]-y[Be]+2*re)/V[Be]+1,G));return Re}function we(ve,y,Qe,V=1){const re=_(y,V);return Math.floor((ve[0]*(Qe-1)-Qe+re)/2)}function xe(ve){return typeof ve=="number"?[ve,ve,ve]:ve.length===2?[ve[0],ve[1],1]:ve}function K(ve){return typeof ve=="number"?[ve,ve,ve]:ve}function _(ve,y){return y<=1?ve:ve+(ve-1)*(y-1)}function De(ve,y,Qe,V,re,G,Re,Be,at){let S,nt,ne;if(typeof ve=="number"){S={top:ve,bottom:ve,left:ve,right:ve,type:ve===0?"VALID":"NUMBER"};const Ve=pe([y,Qe],G,V,ve,Be);nt=Ve[0],ne=Ve[1]}else if(ve==="same"){nt=Math.ceil(y/V),ne=Math.ceil(Qe/re);const Ne=Math.max(0,(nt-1)*V+G-y),Ve=Math.max(0,(ne-1)*re+Re-Qe),ce=Math.floor(Ne/2),me=Ne-ce,pt=Math.floor(Ve/2),ct=Ve-pt;S={top:ce,bottom:me,left:pt,right:ct,type:"SAME"}}else if(ve==="valid")S={top:0,bottom:0,left:0,right:0,type:"VALID"},nt=Math.ceil((y-G+1)/V),ne=Math.ceil((Qe-Re+1)/re);else if(typeof ve=="object"){const Ne=at==="channelsLast"?ve[1][0]:ve[2][0],Ve=at==="channelsLast"?ve[1][1]:ve[2][1],ce=at==="channelsLast"?ve[2][0]:ve[3][0],me=at==="channelsLast"?ve[2][1]:ve[3][1];S={top:Ne,bottom:Ve,left:ce,right:me,type:Ne===0&&Ve===0&&ce===0&&me===0?"VALID":"EXPLICIT"},nt=Ke((y-G+Ne+Ve)/V+1,Be),ne=Ke((Qe-Re+ce+me)/re+1,Be)}else throw Error(`Unknown padding parameter: ${ve}`);return{padInfo:S,outHeight:nt,outWidth:ne}}function Fe(ve,y,Qe,V,re,G,Re,Be,at,S,nt){let ne,Ne,Ve,ce;if(ve==="valid"&&(ve=0),typeof ve=="number"){ne={top:ve,bottom:ve,left:ve,right:ve,front:ve,back:ve,type:ve===0?"VALID":"NUMBER"};const pt=ee([y,Qe,V,1],[Be,at,S],1,[re,G,Re],ve,nt);Ne=pt[0],Ve=pt[1],ce=pt[2]}else if(ve==="same"){Ne=Math.ceil(y/re),Ve=Math.ceil(Qe/G),ce=Math.ceil(V/Re);const me=(Ne-1)*re+Be-y,pt=(Ve-1)*G+at-Qe,ct=(ce-1)*Re+S-V,Lt=Math.floor(me/2),Nt=me-Lt,ln=Math.floor(pt/2),Sn=pt-ln,tn=Math.floor(ct/2),kn=ct-tn;ne={top:ln,bottom:Sn,left:tn,right:kn,front:Lt,back:Nt,type:"SAME"}}else throw Error(`Unknown padding parameter: ${ve}`);return{padInfo:ne,outDepth:Ne,outHeight:Ve,outWidth:ce}}function Ke(ve,y){if(!y)return Math.trunc(ve);switch(y){case"round":return Math.round(ve);case"ceil":return Math.ceil(ve);case"floor":return Math.floor(ve);default:throw new Error(`Unknown roundingMode ${y}`)}}function rt(ve){const[y,Qe,V]=xe(ve);return y===1&&Qe===1&&V===1}function ht(ve,y){return rt(ve)||rt(y)}function Vt(ve){return xe(ve).every(y=>y>0)}function on(ve){if(ve==="NHWC")return"channelsLast";if(ve==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${ve}`)}function $t(ve,y,Qe){if(Qe!=null){if(typeof y=="string")throw Error(`Error in ${ve}: pad must be an integer when using dimRoundingMode ${Qe} but got pad ${y}.`);if(typeof y=="number")p.hu(p.GN(y),()=>`Error in ${ve}: pad must be an integer when using dimRoundingMode ${Qe} but got pad ${y}.`);else if(typeof y=="object")y.forEach(V=>{V.forEach(re=>{p.hu(p.GN(re),()=>`Error in ${ve}: pad must be an integer when using dimRoundingMode ${Qe} but got pad ${re}.`)})});else throw Error(`Error in ${ve}: Unknown padding parameter: ${y}`)}}},8670:function(Wt,dt,L){"use strict";L.d(dt,{h:()=>ee});var p=L(6201),ze=L(4403),Z=L(6802),ie=L(6857),P=L(2951),W=L(7264);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pe(we,xe){let K=(0,ie._1)(we,"a","div"),_=(0,ie._1)(xe,"b","div");if([K,_]=(0,Z.T_)(K,_),K.dtype==="int32"&&_.dtype==="int32")return(0,P.q)(K,_);const De={a:K,b:_},Fe={};return p.BV.runKernel(ze.oHH,De,Fe)}const ee=(0,W.op)({div_:pe})},3777:function(Wt,dt,L){"use strict";L.d(dt,{p:()=>W});var p=L(6201),ze=L(4403),Z=L(6857),ie=L(7264);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P(pe){const we={x:(0,Z._1)(pe,"x","elu","float32")};return p.BV.runKernel(ze.SX0,we)}const W=(0,ie.op)({elu_:P})},7809:function(Wt,dt,L){"use strict";L.d(dt,{h:()=>ie});var p=L(6201),ze=L(4403),Z=L(9024);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ie(P,W,pe){(0,Z.Mu)(P),pe=pe||(0,Z.D2)(W);const ee={shape:P,value:W,dtype:pe};return p.BV.runKernel(ze.deh,{},ee)}},2951:function(Wt,dt,L){"use strict";L.d(dt,{q:()=>pe});var p=L(6201),ze=L(4403),Z=L(6802),ie=L(6857),P=L(7264);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W(ee,we){let xe=(0,ie._1)(ee,"a","floorDiv"),K=(0,ie._1)(we,"b","floorDiv");[xe,K]=(0,Z.T_)(xe,K);const _={a:xe,b:K};return p.BV.runKernel(ze.jeX,_)}const pe=(0,P.op)({floorDiv_:W})},3608:function(Wt,dt,L){"use strict";L.d(dt,{Fr:()=>_,QH:()=>Fe,pf:()=>De,uy:()=>Ke});var p=L(6255),ze=L(3777),Z=L(7625),ie=L(2107),P=L(7966),W=L(2124),pe=L(656),ee=L(1067),we=L(5466),xe=L(1965),K=L(5580);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _(rt,ht,Vt){if(Vt==null||Vt==="linear")return rt;if(Vt==="relu")return(0,ie.d)(rt,(0,xe.N)(ht));throw new Error(`Cannot compute gradient for fused activation ${Vt}.`)}function De(rt,ht){let Vt=ht;const on=p.getReductionAxes(rt.shape,ht.shape);return on.length>0&&(Vt=(0,K.S)(Vt,on)),(0,ee.X)(Vt,rt.shape)}function Fe(rt,ht,Vt,on){if(ht==="linear")return rt;if(ht==="relu")return(0,W.U)(rt);if(ht==="elu")return(0,ze.p)(rt);if(ht==="relu6")return(0,pe.b)(rt);if(ht==="prelu")return(0,P.A)(rt,Vt);if(ht==="leakyrelu")return(0,Z.h)(rt,on);if(ht==="sigmoid")return(0,we.X)(rt);throw new Error(`Unknown fused activation ${ht}.`)}const Ke=(rt,ht)=>!(rt>0)||ht==="linear"},7625:function(Wt,dt,L){"use strict";L.d(dt,{h:()=>W});var p=L(6201),ze=L(4403),Z=L(6857),ie=L(7264);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P(pe,ee=.2){const xe={x:(0,Z._1)(pe,"x","leakyRelu")},K={alpha:ee};return p.BV.runKernel(ze.J$2,xe,K)}const W=(0,ie.op)({leakyRelu_:P})},3624:function(Wt,dt,L){"use strict";L.d(dt,{g:()=>we});var p=L(6201),ze=L(4403),Z=L(6802),ie=L(6857),P=L(6255),W=L(8341),pe=L(7264);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ee(xe,K){let _=(0,ie._1)(xe,"a","maximum"),De=(0,ie._1)(K,"b","maximum");[_,De]=(0,Z.T_)(_,De),_.dtype==="bool"&&(_=(0,W.p)(_,"int32"),De=(0,W.p)(De,"int32")),(0,P.assertAndGetBroadcastShape)(_.shape,De.shape);const Fe={a:_,b:De};return p.BV.runKernel(ze.BMI,Fe)}const we=(0,pe.op)({maximum_:ee})},2107:function(Wt,dt,L){"use strict";L.d(dt,{d:()=>pe});var p=L(6201),ze=L(4403),Z=L(6802),ie=L(6857),P=L(7264);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W(ee,we){let xe=(0,ie._1)(ee,"a","mul"),K=(0,ie._1)(we,"b","mul");[xe,K]=(0,Z.T_)(xe,K);const _={a:xe,b:K};return p.BV.runKernel(ze.wYn,_)}const pe=(0,P.op)({mul_:W})},7264:function(Wt,dt,L){"use strict";L.d(dt,{op:()=>ie,z:()=>Z});var p=L(6201),ze=L(9024);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z="__op";function ie(P){const W=Object.keys(P);if(W.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${W.length} keys.`);let pe=W[0];const ee=P[pe];pe.endsWith("_")&&(pe=pe.substring(0,pe.length-1)),pe=pe+Z;const we=(...xe)=>{p.BV.startScope(pe);try{const K=ee(...xe);return(0,ze.tI)(K)&&console.error("Cannot return a Promise inside of tidy."),p.BV.endScope(K),K}catch(K){throw p.BV.endScope(null),K}};return Object.defineProperty(we,"name",{value:pe,configurable:!0}),we}},4337:function(Wt,dt,L){"use strict";L.d(dt,{btT:()=>dr.b,KOy:()=>Oe,VdP:()=>Yr,PAt:()=>Fr,XLQ:()=>me.X,Xxe:()=>Yu,Z_8:()=>Yc,yXz:()=>bl,XD2:()=>ps.X,S0v:()=>Ts.S,sx7:()=>Vn,iD$:()=>de.i,snQ:()=>Ol,WnP:()=>ze.W,w6H:()=>zs,zbp:()=>Do,bp0:()=>zu,pyx:()=>So.p,h62:()=>Ae.h,gME:()=>Pr,dC7:()=>nn.d,odF:()=>Oa,wOQ:()=>xl.w,V3u:()=>Vl,wQq:()=>ui,$gW:()=>Ra,_sB:()=>Is,LGj:()=>gi,pe5:()=>Fu,XeE:()=>vi.X,Pg0:()=>Cl,Vl2:()=>Aa,TN_:()=>Yo,i2d:()=>Go,UWc:()=>Fo,B10:()=>Ws,HHK:()=>Si,bc:()=>no,egP:()=>xn,p_:()=>Pl,t$B:()=>gt,VD$:()=>Rl,tdS:()=>jc,QBD:()=>Fe,qPi:()=>Cn.q,d_R:()=>xa,GaM:()=>kl,iyy:()=>pn,l_t:()=>Ie,$QV:()=>so,rq4:()=>ci,koy:()=>bt,Ip$:()=>Ta,UYe:()=>yi.U,z4N:()=>Be,NMM:()=>Xi,gWQ:()=>$a.g,ZaL:()=>Jo,Khb:()=>ee,__u:()=>xe,DgJ:()=>Lr,Qqt:()=>yt,SX3:()=>ho,Fp7:()=>Fs,hJK:()=>zt,WVs:()=>qa,d9m:()=>Eo,VT$:()=>sa,C80:()=>Ne,mG2:()=>Mu,IHx:()=>K.I,YjB:()=>Vt,op:()=>W.op,tPi:()=>Te,NXj:()=>ml,xZs:()=>wl,Gg6:()=>Pt,ycw:()=>Gr,Izb:()=>vr,PYB:()=>ws.P,luU:()=>A.l,AL3:()=>un.A,ruB:()=>Hi,QEs:()=>bi,d9v:()=>ln.d,SDf:()=>Uu,mew:()=>Ni,WmZ:()=>Po,d2q:()=>ut,XAC:()=>al,$Gn:()=>Br,t1L:()=>sn,uR5:()=>Nt,e_t:()=>N,E4h:()=>Un,Smz:()=>Pe.S,kp_:()=>xi,asL:()=>co,CmS:()=>ge,GYS:()=>go,wx0:()=>Ji,Gi7:()=>Vi,lfX:()=>pi,ppE:()=>ao,CnO:()=>nl,eab:()=>gs,Ka3:()=>zo,zcT:()=>Yn,zvA:()=>W.z,VV$:()=>Se,pNR:()=>Me,JY5:()=>Jr,U8D:()=>Gu,Tek:()=>Ms,vku:()=>se,dt4:()=>xt,zoF:()=>tn,yE8:()=>to,LTh:()=>Ft,ZRM:()=>V,lls:()=>$o,iUl:()=>qs,R_K:()=>Ju,Bfx:()=>ca,Two:()=>va,arb:()=>Ss,HvI:()=>lt,ers:()=>ou,vHJ:()=>y,$6P:()=>rt,qNN:()=>Jn,sQ3:()=>fe.s,ODp:()=>Za,f9Y:()=>js,lGY:()=>Tt,Sxn:()=>Ja,p0P:()=>rl,rVs:()=>Xc,$i:()=>eu,VfV:()=>G,W76:()=>mr,Quu:()=>Xa,G9k:()=>Ut,O$l:()=>Qu,zN1:()=>Bo,dbB:()=>Ll,uN7:()=>Hc,nGf:()=>Ht,L9e:()=>wi,p4s:()=>Ti,hg7:()=>Ci,Wvh:()=>na,AEp:()=>ft,Dxk:()=>Ar,MNy:()=>Os,pdZ:()=>Cr,zEQ:()=>cn,NTj:()=>An,p3b:()=>eo,rvX:()=>Wl,kwC:()=>Zt,cM7:()=>To,diP:()=>Ki,imm:()=>p,Nbs:()=>pl.N,M25:()=>ia,hiC:()=>cs.h,hlL:()=>Dn.h,WYO:()=>ir,nTT:()=>Ao,Iqj:()=>kt,brS:()=>Xr,jZU:()=>qi,_b3:()=>Ee._,mDi:()=>le,XsQ:()=>br,ORZ:()=>yl,Xu6:()=>Il,wS1:()=>ct,NqF:()=>$t,pju:()=>Ve.p,$r2:()=>Tu,N2O:()=>z,tgs:()=>As,U_I:()=>ju,RRF:()=>Ds,pUJ:()=>$l,YQQ:()=>Es,itS:()=>su,J69:()=>jo,N89:()=>Da,GWj:()=>Jt,fBT:()=>$n,xVT:()=>Wn,iUs:()=>kr,GRh:()=>au,SJ_:()=>No,UFq:()=>Ps,SmN:()=>Zi,BHj:()=>Eu,f3b:()=>pr.f,EDe:()=>Ye,pjt:()=>Vr,wzB:()=>_u,P84:()=>fs.P,anm:()=>Fa,JpU:()=>U,ry_:()=>ii,MB5:()=>Kc,knu:()=>la,mCk:()=>wo,OI3:()=>bn,fvJ:()=>nt,AKD:()=>ar,Krr:()=>Gt,K5V:()=>an,hi7:()=>Ho.h});var p={};L.r(p),L.d(p,{conv2d:()=>ti,depthwiseConv2d:()=>uu,matMul:()=>lu});var ze=L(5136),Z=L(6201),ie=L(4403),P=L(6857),W=L(7264);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pe(I){const x={x:(0,P._1)(I,"x","acos")};return Z.BV.runKernel(ie.VGw,x)}const ee=(0,W.op)({acos_:pe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function we(I){const x={x:(0,P._1)(I,"x","acosh")};return Z.BV.runKernel(ie.SpW,x)}const xe=(0,W.op)({acosh_:we});var K=L(2364),_=L(9024);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function De(I){_.hu(Array.isArray(I),()=>"The argument passed to tf.addN() must be a list of tensors"),_.hu(I.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${I.length}`);const w=I.map((O,M)=>(0,P._1)(O,`tensors${M}`,"addN")),x=w[0];w.forEach(O=>{if(O.dtype!==x.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),w.forEach(O=>{if(!_.cO(O.shape,x.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const $=w;return Z.BV.runKernel(ie.Xze,$)}const Fe=(0,W.op)({addN_:De});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ke(I,w=null,x=!1){const O={x:(0,P._1)(I,"x","all","bool")},M={axis:w,keepDims:x};return Z.BV.runKernel(ie.oT6,O,M)}const rt=(0,W.op)({all_:Ke});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ht(I,w=null,x=!1){const O={x:(0,P._1)(I,"x","any","bool")},M={axis:w,keepDims:x};return Z.BV.runKernel(ie.IKK,O,M)}const Vt=(0,W.op)({any_:ht});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function on(I,w=0){const $={x:(0,P._1)(I,"x","argMax")},O={axis:w};return Z.BV.runKernel(ie.sJF,$,O)}const $t=(0,W.op)({argMax_:on});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ve(I,w=0){const $={x:(0,P._1)(I,"x","argMin")},O={axis:w};return Z.BV.runKernel(ie.aJk,$,O)}const y=(0,W.op)({argMin_:ve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qe(I){const x={x:(0,P._1)(I,"x","asin")};return Z.BV.runKernel(ie.M2y,x)}const V=(0,W.op)({asin_:Qe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function re(I){const x={x:(0,P._1)(I,"x","asinh")};return Z.BV.runKernel(ie.qw7,x)}const G=(0,W.op)({asinh_:re});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Re(I){const x={x:(0,P._1)(I,"x","atan")};return Z.BV.runKernel(ie.jMg,x)}const Be=(0,W.op)({atan_:Re});var at=L(6802);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S(I,w){let x=(0,P._1)(I,"a","atan2"),$=(0,P._1)(w,"b","atan2");[x,$]=(0,at.T_)(x,$);const O={a:x,b:$};return Z.BV.runKernel(ie.QCc,O)}const nt=(0,W.op)({atan2_:S});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ne(I){const x={x:(0,P._1)(I,"x","atanh")};return Z.BV.runKernel(ie.Oyi,x)}const Ne=(0,W.op)({atanh_:ne});var Ve=L(8341),ce=L(2132),me=L(1067);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pt(I,w,x,$,O){const M=(0,P._1)(I,"x","avgPool","float32"),j=1;_.hu(ce.jT(x,j),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${x} and dilations '${j}'`);let J=M,ye=!1;M.rank===3&&(ye=!0,J=(0,me.X)(M,[1,M.shape[0],M.shape[1],M.shape[2]])),_.hu(J.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${J.rank}.`),ce.m("avgPool",$,O);const $e={x:J},qe={filterSize:w,strides:x,pad:$,dimRoundingMode:O};let Ze=Z.BV.runKernel(ie.JhU,$e,qe);return Ze=(0,Ve.p)(Ze,M.dtype),ye?(0,me.X)(Ze,[Ze.shape[1],Ze.shape[2],Ze.shape[3]]):Ze}const ct=(0,W.op)({avgPool_:pt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lt(I,w,x,$,O,M="NDHWC"){const j=(0,P._1)(I,"x","avgPool3d","float32");let J=j,ye=!1;j.rank===4&&(ye=!0,J=(0,me.X)(j,[1,j.shape[0],j.shape[1],j.shape[2],j.shape[3]])),_.hu(J.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${J.rank}.`),_.hu(M==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${M}`),_.hu(typeof x=="number"&&x>0||Array.isArray(x)&&x[0]>0&&x[1]>0&&x[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${x}'`),(0,ce.m)("avgPool3d",$,O);const $e={x:J},qe={filterSize:w,strides:x,pad:$,dimRoundingMode:O,dataFormat:M};let Ze=Z.BV.runKernel(ie._k9,$e,qe);return Ze=(0,Ve.p)(Ze,J.dtype),ye?(0,me.X)(Ze,[Ze.shape[1],Ze.shape[2],Ze.shape[3],Ze.shape[4]]):Ze}const Nt=(0,W.op)({avgPool3d_:Lt});var ln=L(8155);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sn(I,w=0){(0,_.hu)(I.length>=1,()=>"Pass at least one tensor to concat");const x=(0,P.sI)(I,"tensors","concat","string_or_numeric");if(x[0].dtype==="complex64"&&x.forEach(M=>{if(M.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${M.dtype}. `)}),x.length===1)return(0,ln.d)(x[0]);const $=x,O={axis:w};return Z.BV.runKernel(ie.Eh3,$,O)}const tn=(0,W.op)({concat_:Sn});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kn(I,w,x=!1,$=!1){let O=(0,P._1)(I,"a","matMul"),M=(0,P._1)(w,"b","matMul");[O,M]=(0,at.T_)(O,M);const j={a:O,b:M},J={transposeA:x,transposeB:$};return Z.BV.runKernel(ie.XLW,j,J)}const bn=(0,W.op)({matMul_:kn});var nn=L(2107),ps=L(5466);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xn(I,w,x){const $=(0,P._1)(I,"x","slice","string_or_numeric");if($.rank===0)throw new Error("Slicing scalar is not possible");const O={x:$},M={begin:w,size:x};return Z.BV.runKernel(ie.p2w,O,M)}const Te=(0,W.op)({slice_:Xn});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Je(I){const x={x:(0,P._1)(I,"x","tanh","float32")};return Z.BV.runKernel(ie.MIZ,x)}const ft=(0,W.op)({tanh_:Je});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ot(I,w,x,$,O,M){const j=(0,P._1)(I,"forgetBias","basicLSTMCell"),J=(0,P._1)(w,"lstmKernel","basicLSTMCell"),ye=(0,P._1)(x,"lstmBias","basicLSTMCell"),$e=(0,P._1)($,"data","basicLSTMCell"),qe=(0,P._1)(O,"c","basicLSTMCell"),Ze=(0,P._1)(M,"h","basicLSTMCell"),Dt=tn([$e,Ze],1),Yt=bn(Dt,J),qt=(0,K.I)(Yt,ye),In=qt.shape[0],dn=qt.shape[1]/4,Mn=[In,dn],Ks=Te(qt,[0,0],Mn),Hs=Te(qt,[0,dn],Mn),$s=Te(qt,[0,dn*2],Mn),Bs=Te(qt,[0,dn*3],Mn),Ln=(0,K.I)((0,nn.d)((0,ps.X)(Ks),ft(Hs)),(0,nn.d)(qe,(0,ps.X)((0,K.I)(j,$s)))),ys=(0,nn.d)(ft(Ln),(0,ps.X)(Bs));return[Ln,ys]}const cn=(0,W.op)({basicLSTMCell_:Ot});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rn(I,w,x){const $=(0,P._1)(I,"x","batchToSpaceND"),O=w.reduce((J,ye)=>J*ye);_.hu($.rank>=1+w.length,()=>`input rank is ${$.rank} but should be > than blockShape.length ${w.length}`),_.hu(x.length===w.length,()=>`crops.length is ${x.length} but should be equal to blockShape.length  ${w.length}`),_.hu($.shape[0]%O===0,()=>`input tensor batch is ${$.shape[0]} but is not divisible by the product of the elements of blockShape ${w.join(" * ")} === ${O}`);const M={x:$},j={blockShape:w,crops:x};return Z.BV.runKernel(ie.zws,M,j)}const Un=(0,W.op)({batchToSpaceND_:Rn});function Kn(I){let w;return I.rank===0||I.rank===1?w=(0,me.X)(I,[1,1,1,I.size]):I.rank===2?w=(0,me.X)(I,[1,1,I.shape[0],I.shape[1]]):I.rank===3?w=(0,me.X)(I,[1,I.shape[0],I.shape[1],I.shape[2]]):w=I,w}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Us(I,w,x,$,O,M){M==null&&(M=.001);const j=(0,P._1)(I,"x","batchNorm"),J=(0,P._1)(w,"mean","batchNorm"),ye=(0,P._1)(x,"variance","batchNorm");let $e;O!=null&&($e=(0,P._1)(O,"scale","batchNorm"));let qe;$!=null&&(qe=(0,P._1)($,"offset","batchNorm")),_.hu(J.rank===ye.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),_.hu(qe==null||J.rank===qe.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),_.hu($e==null||J.rank===$e.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const Dt={x:Kn(j),scale:$e,offset:qe,mean:J,variance:ye},Yt={varianceEpsilon:M},qt=Z.BV.runKernel(ie.sHE,Dt,Yt);return(0,me.X)(qt,j.shape)}const As=(0,W.op)({batchNorm_:Us});function _r(I,w,x,$,O,M){const j=(0,P._1)(I,"x","batchNorm"),J=(0,P._1)(w,"mean","batchNorm"),ye=(0,P._1)(x,"variance","batchNorm");let $e;O!=null&&($e=(0,P._1)(O,"scale","batchNorm"));let qe;return $!=null&&(qe=(0,P._1)($,"offset","batchNorm")),_.hu(j.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${j.rank}.`),_.hu(J.rank===2||J.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${J.rank}.`),_.hu(ye.rank===2||ye.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${ye.rank}.`),$e!=null&&_.hu($e.rank===2||$e.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${$e.rank}.`),qe!=null&&_.hu(qe.rank===2||qe.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${qe.rank}.`),As(j,J,ye,qe,$e,M)}const Ar=(0,W.op)({batchNorm2d_:_r});function Ns(I,w,x,$,O,M){const j=(0,P._1)(I,"x","batchNorm"),J=(0,P._1)(w,"mean","batchNorm"),ye=(0,P._1)(x,"variance","batchNorm");let $e;O!=null&&($e=(0,P._1)(O,"scale","batchNorm"));let qe;return $!=null&&(qe=(0,P._1)($,"offset","batchNorm")),_.hu(j.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${j.rank}.`),_.hu(J.rank===3||J.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${J.rank}.`),_.hu(ye.rank===3||ye.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${ye.rank}.`),$e!=null&&_.hu($e.rank===3||$e.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${$e.rank}.`),qe!=null&&_.hu(qe.rank===3||qe.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${qe.rank}.`),As(j,J,ye,qe,$e,M)}const Jr=(0,W.op)({batchNorm3d_:Ns});function Ys(I,w,x,$,O,M){const j=(0,P._1)(I,"x","batchNorm"),J=(0,P._1)(w,"mean","batchNorm"),ye=(0,P._1)(x,"variance","batchNorm");let $e;O!=null&&($e=(0,P._1)(O,"scale","batchNorm"));let qe;return $!=null&&(qe=(0,P._1)($,"offset","batchNorm")),_.hu(j.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${j.rank}.`),_.hu(J.rank===4||J.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${J.rank}.`),_.hu(ye.rank===4||ye.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${ye.rank}.`),$e!=null&&_.hu($e.rank===4||$e.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${$e.rank}.`),qe!=null&&_.hu(qe.rank===4||qe.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${qe.rank}.`),As(j,J,ye,qe,$e,M)}const eo=(0,W.op)({batchNorm4d_:Ys});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bo(I,w,x){const $=(0,P._1)(I,"x","bincount"),O=(0,P._1)(w,"weights","bincount");_.hu($.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${$.dtype}`),_.hu(x>=0,()=>`size must be non-negative, but got ${x}.`),_.hu(O.size===$.size||O.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${$.shape}, weights shape: ${O.shape}.`);const M={x:$,weights:O},j={size:x};return Z.BV.runKernel(ie.zvY,M,j)}const to=(0,W.op)({bincount_:bo});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ks(I,w){const x=(0,P._1)(I,"x","bitwiseAnd"),$=(0,P._1)(w,"y","bitwiseAnd");if(!(0,_.cO)(x.shape,$.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${x.shape}, y: ${$.shape}`);if(x.dtype!=="int32"||$.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${x.dtype} and type of y: ${$.dtype}`);const O={a:x,b:$};return Z.BV.runKernel(ie.hCO,O)}const Gr=(0,W.op)({bitwiseAnd_:ks});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hr(I,w){const x=(0,P._1)(I,"s0","broadcastArgs","int32"),$=(0,P._1)(w,"s1","broadcastArgs","int32");if(x.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${x.rank}`);if($.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${$.rank}`);const O={s0:x,s1:$};return Z.BV.runKernel(ie.eEB,O)}const br=(0,W.op)({broadcastArgs_:hr});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wr(I,w){let x=(0,P._1)(I,"broadcastTo","x");const $=x.shape;if((0,_.Mu)(w),w.length<x.rank)throw new Error(`broadcastTo(): shape.length=${w.length} < input.rank=${x.rank}.`);if(w.length>x.rank){const $e=x.shape.slice();for(;$e.length<w.length;)$e.unshift(1);x=(0,me.X)(x,$e)}const O=x.shape,M=Array.from(w);for(let $e=w.length-1;$e>=0;$e--)if(O[$e]===w[$e])M[$e]=1;else if(x.shape[$e]!==1)throw new Error(`broadcastTo(): [${$}] cannot be broadcast to [${w}].`);if(M.map(($e,qe)=>$e>1?qe:-1).filter($e=>$e>=0).length===0)return(0,ln.d)(x);const J={x},ye={reps:M};return Z.BV.runKernel(ie.n9L,J,ye)}const Ps=(0,W.op)({broadcastTo_:wr});var pr=L(4865);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mn(I){const x={x:(0,P._1)(I,"x","ceil","float32")};return Z.BV.runKernel(ie.gJX,x)}const le=(0,W.op)({ceil_:mn});var Dn=L(7809);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wn(I,w,x){const $=(0,P._1)(I,"x","clipByValue");if(_.hu(w<=x,()=>`Error in clip: min (${w}) must be less than or equal to max (${x}).`),w===x)return(0,Dn.h)($.shape,w,$.dtype);const O={x:$},M={clipValueMin:w,clipValueMax:x};return Z.BV.runKernel(ie.xnO,O,M)}const qs=(0,W.op)({clipByValue_:wn});var ws=L(1788);function ns(I){return tn(I,0)}const Pr=(0,W.op)({concat1d_:ns});function ls(I,w){return tn(I,w)}const vr=(0,W.op)({concat2d_:ls});function Or(I,w){return tn(I,w)}const Os=(0,W.op)({concat3d_:Or});function Qs(I,w){return tn(I,w)}const Jo=(0,W.op)({concat4d_:Qs});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zs(I,w,x,$,O="NHWC",M=[1,1],j){const J=(0,P._1)(I,"x","conv2d","float32"),ye=(0,P._1)(w,"filter","conv2d","float32");let $e=J,qe=!1;J.rank===3&&(qe=!0,$e=(0,me.X)(J,[1,J.shape[0],J.shape[1],J.shape[2]])),_.hu($e.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${$e.rank}.`),_.hu(ye.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${ye.rank}.`),ce.m("conv2d",$,j);const Ze=O==="NHWC"?$e.shape[3]:$e.shape[1];_.hu(Ze===ye.shape[2],()=>`Error in conv2d: depth of input (${Ze}) must match input depth for filter ${ye.shape[2]}.`),_.hu(ce.jT(x,M),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${x} and dilations '${M}'`),_.hu(ce.U3(M),()=>"Error in conv2D: Dilated rates should be larger than 0."),_.hu(ce.U3(x),()=>"Error in conv2D: Strides should be larger than 0.");const Dt={x:$e,filter:ye},Yt={strides:x,pad:$,dataFormat:O,dilations:M,dimRoundingMode:j},qt=Z.BV.runKernel(ie.mhS,Dt,Yt);return qe?(0,me.X)(qt,[qt.shape[1],qt.shape[2],qt.shape[3]]):qt}const Ms=(0,W.op)({conv2d_:Zs});function Js(I,w,x,$,O="NWC",M=1,j){const J=(0,P._1)(I,"x","conv1d"),ye=(0,P._1)(w,"filter","conv1d");let $e=J,qe=!1;J.rank===2&&(qe=!0,$e=(0,me.X)(J,[1,J.shape[0],J.shape[1]])),_.hu($e.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${$e.rank}.`),_.hu(ye.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${ye.rank}.`),ce.m("conv1d",$,j),_.hu($e.shape[2]===ye.shape[1],()=>`Error in conv1d: depth of input (${$e.shape[2]}) must match input depth for filter ${ye.shape[1]}.`),_.hu(ce.jT(x,M),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${x} and dilation '${M}'`),_.hu(ce.U3(M),()=>"Error in conv1D: Dilated rates should be larger than 0."),_.hu(ce.U3(x),()=>"Error in conv1D: Stride should be larger than 0."),_.hu(O==="NWC",()=>`Error in conv1d: got dataFormat of ${O} but only NWC is currently supported.`);const Ze=(0,me.X)(ye,[1,ye.shape[0],ye.shape[1],ye.shape[2]]),Dt=(0,me.X)($e,[$e.shape[0],1,$e.shape[1],$e.shape[2]]),dn=Ms(Dt,Ze,[1,x],$,"NHWC",[1,M],j);return qe?(0,me.X)(dn,[dn.shape[2],dn.shape[3]]):(0,me.X)(dn,[dn.shape[0],dn.shape[2],dn.shape[3]])}const Fr=(0,W.op)({conv1d_:Js});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hr(I,w,x,$,O,M="NHWC",j){_.hu(I.length===w.rank,()=>`Length of inShape (${I.length}) and rank of dy (${w.rank}) must match`);let J=I,ye=w,$e=!1;w.rank===3&&($e=!0,ye=(0,me.X)(w,[1,w.shape[0],w.shape[1],w.shape[2]]),J=[1,I[0],I[1],I[2]]),_.hu(J.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${J.length}.`),_.hu(ye.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${ye.rank}`),_.hu(x.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${x.rank}`);const qe=M==="NHWC"?J[3]:J[1],Ze=M==="NHWC"?ye.shape[3]:ye.shape[1];_.hu(qe===x.shape[2],()=>`Error in conv2dDerInput: depth of input (${qe}) must match input depth for filter ${x.shape[2]}.`),_.hu(Ze===x.shape[3],()=>`Error in conv2dDerInput: depth of output (${Ze}) must match output depth for filter ${x.shape[3]}.`),ce.m("conv2dDerInput",O,j);const Dt={dy:ye,filter:x},Yt={strides:$,pad:O,dataFormat:M,dimRoundingMode:j,inputShape:J},qt=Z.BV.runKernel(ie.wm,Dt,Yt);return $e?(0,me.X)(qt,[qt.shape[1],qt.shape[2],qt.shape[3]]):qt}const Zn=(0,W.op)({conv2DBackpropInput_:Hr});function vs(I,w,x,$,O,M){const j=(0,P._1)(I,"x","conv2dTranspose"),J=(0,P._1)(w,"filter","conv2dTranspose");return Zn(x,j,J,$,O,"NHWC",M)}const no=(0,W.op)({conv2dTranspose_:vs});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ro(I,w,x,$,O="NDHWC",M=[1,1,1]){const j=(0,P._1)(I,"x","conv3d"),J=(0,P._1)(w,"filter","conv3d");let ye=j,$e=!1;j.rank===4&&($e=!0,ye=(0,me.X)(j,[1,j.shape[0],j.shape[1],j.shape[2],j.shape[3]])),_.hu(ye.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${ye.rank}.`),_.hu(J.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${J.rank}.`),_.hu(ye.shape[4]===J.shape[3],()=>`Error in conv3d: depth of input (${ye.shape[4]}) must match input depth for filter ${J.shape[3]}.`),_.hu((0,ce.jT)(x,M),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${x} and dilations '${M}'`),_.hu(O==="NDHWC",()=>`Error in conv3d: got dataFormat of ${O} but only NDHWC is currently supported.`),_.hu((0,ce.U3)(M),()=>"Error in conv3D: Dilated rates should be larger than 0."),_.hu((0,ce.U3)(x),()=>"Error in conv3D: Strides should be larger than 0.");const qe={x:ye,filter:J},Ze={strides:x,pad:$,dataFormat:O,dilations:M},Dt=Z.BV.runKernel(ie.x12,qe,Ze);return $e?(0,me.X)(Dt,[Dt.shape[1],Dt.shape[2],Dt.shape[3],Dt.shape[4]]):Dt}const Cr=(0,W.op)({conv3d_:Ro});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cs(I,w,x,$,O){_.hu(I.length===w.rank,()=>`Length of inShape (${I.length}) and rank of dy (${w.rank}) must match`);let M=I,j=w,J=!1;w.rank===4&&(J=!0,j=(0,me.X)(w,[1,w.shape[0],w.shape[1],w.shape[2],w.shape[3]]),M=[1,I[0],I[1],I[2],I[3]]);const ye=M[4],$e=j.shape[4];_.hu(M.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${M.length}.`),_.hu(j.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${j.rank}`),_.hu(x.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${x.rank}`),_.hu(ye===x.shape[3],()=>`Error in conv3dDerInput: depth of input (${ye}) must match input depth for filter ${x.shape[3]}.`),_.hu($e===x.shape[4],()=>`Error in conv3dDerInput: depth of output (${$e}) must match output depth for filter ${x.shape[4]}.`);const qe={dy:j,filter:x},Ze={pad:O,strides:$,inputShape:M},Dt=Z.BV.runKernel(ie.ik2,qe,Ze);return J?(0,me.X)(Dt,[Dt.shape[1],Dt.shape[2],Dt.shape[3],Dt.shape[4]]):Dt}const fr=(0,W.op)({conv3DBackpropInput_:Cs});function Sr(I,w,x,$,O){const M=(0,P._1)(I,"x","conv3dTranspose"),j=(0,P._1)(w,"filter","conv3dTranspose");return fr(x,M,j,$,O)}const so=(0,W.op)({conv3dTranspose_:Sr});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ro(I){const x={x:(0,P._1)(I,"x","cos","float32")};return Z.BV.runKernel(ie.mc4,x)}const wo=(0,W.op)({cos_:ro});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oo(I){const x={x:(0,P._1)(I,"x","cosh","float32")};return Z.BV.runKernel(ie.TR1,x)}const js=(0,W.op)({cosh_:oo});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function er(I,w=0,x=!1,$=!1){const M={x:(0,P._1)(I,"x","cumprod")},j={axis:w,exclusive:x,reverse:$};return Z.BV.runKernel(ie.Byc,M,j)}const Br=(0,W.op)({cumprod_:er});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tr(I,w=0,x=!1,$=!1){const M={x:(0,P._1)(I,"x","cumsum")},j={axis:w,exclusive:x,reverse:$};return Z.BV.runKernel(ie.iHb,M,j)}const Do=(0,W.op)({cumsum_:tr});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _o(I,w,x,$=!1){const O=(0,P._1)(I,"x","denseBincount"),M=(0,P._1)(w,"weights","denseBincount");_.hu(O.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${O.dtype}`),_.hu(O.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${O.rank}.`),_.hu(x>=0,()=>`size must be non-negative, but got ${x}.`),_.hu(M.size===O.size||M.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${O.shape}, weights shape: ${M.shape}.`);const j={x:O,weights:M},J={size:x,binaryOutput:$};return Z.BV.runKernel(ie.QRR,j,J)}const ao=(0,W.op)({denseBincount_:_o});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ms(I,w,x="NHWC"){const $=(0,P._1)(I,"x","depthToSpace","float32"),O=x==="NHWC"?$.shape[1]:$.shape[2],M=x==="NHWC"?$.shape[2]:$.shape[3],j=x==="NHWC"?$.shape[3]:$.shape[1];_.hu(w>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${w}`),_.hu(O*w>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${O} and ${w}  for depthToSpace with input shape
    ${$.shape}`),_.hu(M*w>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${M} and ${w} for depthToSpace with input shape
        ${$.shape}`),_.hu(j%(w*w)===0,()=>`Dimension size must be evenly divisible by ${w*w} but is ${j} for depthToSpace with input shape ${$.shape}`);const J={x:$},ye={blockSize:w,dataFormat:x};return Z.BV.runKernel(ie.T0n,J,ye)}const Ao=(0,W.op)({depthToSpace_:ms});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jr(I,w,x,$,O="NHWC",M=[1,1],j){const J=(0,P._1)(I,"x","depthwiseConv2d","float32"),ye=(0,P._1)(w,"filter","depthwiseConv2d","float32");let $e=J,qe=!1;J.rank===3&&(qe=!0,$e=(0,me.X)(J,[1,J.shape[0],J.shape[1],J.shape[2]])),_.hu($e.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${$e.rank}.`),_.hu(ye.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${ye.rank}.`);const Ze=O==="NHWC"?$e.shape[3]:$e.shape[1];_.hu(Ze===ye.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${Ze}) must match the inChannels dimension in filter ${ye.shape[2]}.`),ce.m("depthwiseConv2d",$,j);const Dt={x:$e,filter:ye},Yt={strides:x,pad:$,dataFormat:O,dilations:M,dimRoundingMode:j},qt=Z.BV.runKernel(ie.cie,Dt,Yt);return qe?(0,me.X)(qt,[qt.shape[1],qt.shape[2],qt.shape[3]]):qt}const Ws=(0,W.op)({depthwiseConv2d_:jr});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kr(I){const x={x:(0,P._1)(I,"x","diag")};return Z.BV.runKernel(ie.$w,x)}const zo=(0,W.op)({diag_:Kr});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vo(I,w,x,$,O=[1,1],M="NHWC"){const j=(0,P._1)(I,"x","dilation2d"),J=(0,P._1)(w,"filter","dilation2d");_.hu(j.rank===3||j.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${j.rank}.`),_.hu(J.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${J.rank}.`),_.hu(M==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${M}`);let ye=j,$e=!1;j.rank===3&&(ye=(0,me.X)(j,[1,j.shape[0],j.shape[1],j.shape[2]]),$e=!0),_.hu(ye.shape[3]===J.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${ye.shape[3]} vs ${J.shape[2]}`);const qe={x:ye,filter:J},Ze={strides:x,pad:$,dilations:O},Dt=Z.BV.runKernel(ie.p4S,qe,Ze);return $e?(0,me.X)(Dt,[Dt.shape[1],Dt.shape[2],Dt.shape[3]]):Dt}const Po=(0,W.op)({dilation2d_:vo});var cs=L(8670),as=L(6255);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oo(I,w){let x=(0,P._1)(I,"a","equal","string_or_numeric"),$=(0,P._1)(w,"b","equal","string_or_numeric");[x,$]=(0,at.T_)(x,$),(0,as.assertAndGetBroadcastShape)(x.shape,$.shape);const O={a:x,b:$};return Z.BV.runKernel(ie.hdR,O)}const Lr=(0,W.op)({equal_:Oo});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Co(I,w,x){const $=(0,P._1)(w,"a","where"),O=(0,P._1)(x,"b","where"),M=(0,P._1)(I,"condition","where","bool"),j=(0,as.assertAndGetBroadcastShape)((0,as.assertAndGetBroadcastShape)(M.shape,$.shape),O.shape),J=Ps(M,j),ye=Ps($,j),$e=Ps(O,j),qe={condition:J,t:ye,e:$e};return Z.BV.runKernel(ie.PhF,qe)}const Ss=(0,W.op)({where_:Co});var fs=L(9146);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uo(I,w){let x=(0,P._1)(I,"a","div"),$=(0,P._1)(w,"b","div");[x,$]=(0,at.T_)(x,$);const O=(0,cs.h)(x,$),M=(0,fs.P)(O),j=Lr($,M);return Ss(j,M,O)}const An=(0,W.op)({divNoNan_:uo});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ur(I,w){const x=(0,P._1)(I,"t1","dot"),$=(0,P._1)(w,"t2","dot");_.hu((x.rank===1||x.rank===2)&&($.rank===1||$.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${x.rank} and ${$.rank}.`);const O=x.rank===1?x.size:x.shape[1],M=$.rank===1?$.size:$.shape[0];if(_.hu(O===M,()=>`Error in dot: inner dimensions of inputs must match, but got ${O} and ${M}.`),x.rank===1&&$.rank===1){const j=(0,me.X)(x,[1,-1]),J=(0,me.X)($,[-1,1]),ye=bn(j,J);return(0,me.X)(ye,[])}else if(x.rank===1&&$.rank===2){const j=(0,me.X)(x,[1,-1]),J=(0,me.X)($,[$.shape[0],$.shape[1]]),ye=bn(j,J);return(0,me.X)(ye,[ye.size])}else if(x.rank===2&&$.rank===1){const j=(0,me.X)($,[-1,1]),J=bn(x,j);return(0,me.X)(J,[J.size])}else{const j=(0,me.X)($,[$.shape[0],$.shape[1]]);return bn(x,j)}}const ar=(0,W.op)({dot_:Ur});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nr(I,...w){const x=w.map((O,M)=>(0,P._1)(O,`tensors${M}`,"einsum")),$={equation:I};return Z.BV.runKernel(ie.$g6,x,$)}const ir=(0,W.op)({einsum_:nr});var So=L(3777);/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mr(I,w){const x=(0,P._1)(I,"x","ensureShape","string_or_numeric");if(!(0,_.DK)(x.shape,w))throw new Error(`EnsureShape: Shape of tensor ${x.shape} is not compatible with expected shape ${w}`);return I}const Ye=(0,W.op)({ensureShape_:Mr});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ir(I){let w=(0,P._1)(I,"x","erf");_.hu(w.dtype==="int32"||w.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),w.dtype==="int32"&&(w=(0,Ve.p)(w,"float32"));const x={x:w};return Z.BV.runKernel(ie.Omj,x)}const Jn=(0,W.op)({erf_:Ir});var Er=L(7199);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wr(I,w=null,x=!1){const O={x:(0,P._1)(I,"x","max")},M={reductionIndices:w,keepDims:x};return Z.BV.runKernel(ie.YoZ,O,M)}const Fs=(0,W.op)({max_:Wr});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ur(I,w=null,x=!1){const O={x:(0,P._1)(I,"x","min")},M={axis:w,keepDims:x};return Z.BV.runKernel(ie.c17,O,M)}const Se=(0,W.op)({min_:ur});var fe=L(5650),de=L(528),Ee=L(9896),Ae=L(414),Pe=L(5580);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function We(I,w="euclidean",x=null,$=!1){I=(0,P._1)(I,"x","norm");const O=je(I,w,x);let M=O.shape;if($){const j=(0,_.EC)(x,I.shape);M=Er.rv(O.shape,j)}return(0,me.X)(O,M)}function je(I,w,x=null){if(I.rank===0)return(0,ze.W)(I);if(I.rank!==1&&x===null)return je((0,me.X)(I,[-1]),w,x);if(I.rank===1||typeof x=="number"||Array.isArray(x)&&x.length===1){if(w===1)return(0,Pe.S)((0,ze.W)(I),x);if(w===1/0)return Fs((0,ze.W)(I),x);if(w===-1/0)return Se((0,ze.W)(I),x);if(w==="euclidean"||w===2)return(0,Ee._)((0,Pe.S)((0,fe.s)((0,ze.W)(I),(0,de.i)(2,"int32")),x));throw new Error(`Error in norm: invalid ord value: ${w}`)}if(Array.isArray(x)&&x.length===2){if(w===1)return Fs((0,Pe.S)((0,ze.W)(I),x[0]),x[1]-1);if(w===1/0)return Fs((0,Pe.S)((0,ze.W)(I),x[1]),x[0]);if(w===-1/0)return Se((0,Pe.S)((0,ze.W)(I),x[1]),x[0]);if(w==="fro"||w==="euclidean")return(0,Ee._)((0,Pe.S)((0,Ae.h)(I),x));throw new Error(`Error in norm: invalid ord value: ${w}`)}throw new Error(`Error in norm: invalid axis: ${x}`)}const Oe=(0,W.op)({norm_:We});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function st(I,w=null,x=!1){return Oe(I,"euclidean",w,x)}const ut=(0,W.op)({euclideanNorm_:st});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tt(I){const x={x:(0,P._1)(I,"x","exp")};return Z.BV.runKernel(ie.NEP,x)}const yt=(0,W.op)({exp_:tt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function At(I,w=0){const x=(0,P._1)(I,"x","expandDims","string_or_numeric");_.hu(w<=x.rank,()=>"Axis must be <= rank of the tensor");const $={input:x},O={dim:w};return Z.BV.runKernel(ie.YFo,$,O)}const xt=(0,W.op)({expandDims_:At});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qt(I){const x={x:(0,P._1)(I,"x","expm1")};return Z.BV.runKernel(ie.Y0y,x)}const gt=(0,W.op)({expm1_:Qt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ct(I,w){const x=(0,P._1)(I,"x","tile","string_or_numeric");_.hu(x.rank===w.length,()=>`Error in transpose: rank of input ${x.rank} must match length of reps ${w}.`);const $={x},O={reps:w};return Z.BV.runKernel(ie.n9L,$,O)}const Pt=(0,W.op)({tile_:Ct});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fn(I,w,x,$="float32"){w==null&&(w=I);const O=(0,pr.f)([I,w],$),M=I<=w?I:w;for(let J=0;J<M;++J)O.set(1,J,J);const j=(0,me.X)(O.toTensor(),[I,w]);if(x==null)return j;if(x.length===1)return Pt(xt(j,0),[x[0],1,1]);if(x.length===2)return Pt(xt(xt(j,0),0),[x[0],x[1],1,1]);if(x.length===3)return Pt(xt(xt(xt(j,0),0),0),[x[0],x[1],x[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${x.length}D.`)}const pn=(0,W.op)({eye_:fn});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pn(I){const x={x:(0,P._1)(I,"x","floor","float32")};return Z.BV.runKernel(ie.OR,x)}const Jt=(0,W.op)({floor_:Pn});var Cn=L(2951);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hn(I,w,x=0,$=0){const O=(0,P._1)(I,"x","gather"),M=(0,P._1)(w,"indices","gather","int32"),j={x:O,indices:M},J={axis:x,batchDims:$};return Z.BV.runKernel(ie.qi_,j,J)}const kt=(0,W.op)({gather_:Hn});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tr(I,w){let x=(0,P._1)(I,"a","greater","string_or_numeric"),$=(0,P._1)(w,"b","greater","string_or_numeric");[x,$]=(0,at.T_)(x,$),(0,as.assertAndGetBroadcastShape)(x.shape,$.shape);const O={a:x,b:$};return Z.BV.runKernel(ie.iZT,O)}const Vr=(0,W.op)({greater_:Tr});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lo(I,w){let x=(0,P._1)(I,"a","greaterEqual","string_or_numeric"),$=(0,P._1)(w,"b","greaterEqual","string_or_numeric");[x,$]=(0,at.T_)(x,$),(0,as.assertAndGetBroadcastShape)(x.shape,$.shape);const O={a:x,b:$};return Z.BV.runKernel(ie.Acj,O)}const Xr=(0,W.op)({greaterEqual_:lo});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Io(I){const x={input:(0,P._1)(I,"input","imag")};return Z.BV.runKernel(ie.J_u,x)}const co=(0,W.op)({imag_:Io});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zr(I){const x={x:(0,P._1)(I,"x","isFinite")};return Z.BV.runKernel(ie.avt,x)}const Wn=(0,W.op)({isFinite_:zr});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ea(I){const x={x:(0,P._1)(I,"x","isInf")};return Z.BV.runKernel(ie.iWB,x)}const Fo=(0,W.op)({isInf_:ea});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lr(I){const x={x:(0,P._1)(I,"x","isNaN")};return Z.BV.runKernel(ie.r7n,x)}const Go=(0,W.op)({isNaN_:lr});var Ho=L(7625);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rs(I,w){let x=(0,P._1)(I,"a","less","string_or_numeric"),$=(0,P._1)(w,"b","less","string_or_numeric");[x,$]=(0,at.T_)(x,$),(0,as.assertAndGetBroadcastShape)(x.shape,$.shape);const O={a:x,b:$};return Z.BV.runKernel(ie.vtC,O)}const Eo=(0,W.op)({less_:Rs});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $r(I,w){let x=(0,P._1)(I,"a","lessEqual","string_or_numeric"),$=(0,P._1)(w,"b","lessEqual","string_or_numeric");[x,$]=(0,at.T_)(x,$),(0,as.assertAndGetBroadcastShape)(x.shape,$.shape);const O={a:x,b:$};return Z.BV.runKernel(ie.CAk,O)}const Bo=(0,W.op)({lessEqual_:$r});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ho(I,w,x){if(x<=0)throw new Error("The number of values should be positive.");const $={start:I,stop:w,num:x};return Z.BV.runKernel(ie.e7N,{},$)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ha(I,w=5,x=1,$=1,O=.5){const M=(0,P._1)(I,"x","localResponseNormalization");_.hu(M.rank===4||M.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${M.rank}.`),_.hu(_.GN(w),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${w}.`);let j=M,J=!1;M.rank===3&&(J=!0,j=(0,me.X)(M,[1,M.shape[0],M.shape[1],M.shape[2]]));const ye={x:j},$e={depthRadius:w,bias:x,alpha:$,beta:O},qe=Z.BV.runKernel(ie.eZ0,ye,$e);return J?(0,me.X)(qe,[qe.shape[1],qe.shape[2],qe.shape[3]]):qe}const Ut=(0,W.op)({localResponseNormalization_:Ha});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ta(I){const x={x:(0,P._1)(I,"x","log","float32")};return Z.BV.runKernel(ie.ZbH,x)}const To=(0,W.op)({log_:ta});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ma(I){const x={x:(0,P._1)(I,"x","log1p")};return Z.BV.runKernel(ie.kU,x)}const Gt=(0,W.op)({log1p_:ma});var Nr=L(4233);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ga(I){const x={x:(0,P._1)(I,"x","neg")};return Z.BV.runKernel(ie.kuV,x)}const mr=(0,W.op)({neg_:ga});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gr(I){const x={x:(0,P._1)(I,"x","softplus")};return Z.BV.runKernel(ie.MRv,x)}const na=(0,W.op)({softplus_:gr});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h(I){const w=(0,P._1)(I,"x","logSigmoid");return(0,Nr.cb)($=>({value:mr(na(mr($))),gradFunc:j=>(0,nn.d)(j,(0,ps.X)(mr($)))}))(w)}const N=(0,W.op)({logSigmoid_:h});var A=L(8712);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q(I,w=-1){const x=(0,P._1)(I,"logits","logSoftmax");if(w===-1&&(w=x.rank-1),w!==x.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${x.rank} and axis was ${w}`);return(0,Nr.cb)((O,M)=>{const J=Fs(O,w,!0),ye=(0,A.l)(O,J),$e=(0,A.l)((0,Ve.p)(ye,"float32"),To((0,Pe.S)(yt(ye),w,!0)));return M([$e]),{value:$e,gradFunc:(Ze,Dt)=>{const[Yt]=Dt,qt=!0,In=yt(Yt);return(0,A.l)(Ze,(0,nn.d)((0,Pe.S)(Ze,w,qt),In))}}})(x)}const ge=(0,W.op)({logSoftmax_:Q});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ke(I,w=null,x=!1){const $=(0,P._1)(I,"x","logSumExp"),O=(0,_.EC)(w,$.shape),M=Fs($,O,!0),j=(0,A.l)($,M),J=yt(j),ye=(0,Pe.S)(J,O),$e=To(ye),qe=(0,K.I)((0,me.X)(M,$e.shape),$e);if(x){const Ze=(0,Er.rv)(qe.shape,O);return(0,me.X)(qe,Ze)}return qe}const Ie=(0,W.op)({logSumExp_:ke});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function He(I,w){const x=(0,P._1)(I,"a","logicalAnd","bool"),$=(0,P._1)(w,"b","logicalAnd","bool");(0,as.assertAndGetBroadcastShape)(x.shape,$.shape);const O={a:x,b:$};return Z.BV.runKernel(ie.PYm,O)}const lt=(0,W.op)({logicalAnd_:He});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rt(I){const x={x:(0,P._1)(I,"x","logicalNot","bool")};return Z.BV.runKernel(ie.VfG,x)}const zt=(0,W.op)({logicalNot_:Rt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yn(I,w){const x=(0,P._1)(I,"a","logicalOr","bool"),$=(0,P._1)(w,"b","logicalOr","bool");(0,as.assertAndGetBroadcastShape)(x.shape,$.shape);const O={a:x,b:$};return Z.BV.runKernel(ie.MZg,O)}const an=(0,W.op)({logicalOr_:yn});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xt(I,w){const x=(0,P._1)(I,"a","logicalXor","bool"),$=(0,P._1)(w,"b","logicalXor","bool");return(0,as.assertAndGetBroadcastShape)(x.shape,$.shape),lt(an(I,w),zt(lt(I,w)))}const xn=(0,W.op)({logicalXor_:Xt});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tn=2147483648;function ss(I,w,x="left"){const $=(0,P._1)(I,"sortedSequence","searchSorted"),O=(0,P._1)(w,"values","searchSorted"),M=$.shape[$.shape.length-1],j=O.shape[O.shape.length-1],J=(0,me.X)($,[-1,M]),ye=(0,me.X)(O,[-1,j]);if(J.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(J.shape[0]!==ye.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if((0,_.NA)(ye.shape)>=Tn)throw new Error(`values tensor size must less than ${Tn}`);if(J.shape[1]>=Tn)throw new Error(`trailing dim_size must less than ${Tn} for int32 output type, was ${J.shape[1]}`);const $e={sortedSequence:J,values:ye},qe={side:x};return Z.BV.runKernel(ie.nr8,$e,qe)}const Yn=(0,W.op)({searchSorted_:ss});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gs(I,w){return Yn(I,w,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cr(I,w,x,$,O){const M=(0,P._1)(I,"x","maxPool"),j=1;let J=M,ye=!1;M.rank===3&&(ye=!0,J=(0,me.X)(M,[1,M.shape[0],M.shape[1],M.shape[2]])),_.hu(J.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${J.rank}.`),_.hu(ce.jT(x,j),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${x} and dilations '${j}'`),ce.m("maxPool",$,O);const $e={x:J},qe={filterSize:w,strides:x,pad:$,dimRoundingMode:O},Ze=Z.BV.runKernel(ie.mTV,$e,qe);return ye?(0,me.X)(Ze,[Ze.shape[1],Ze.shape[2],Ze.shape[3]]):Ze}const Is=(0,W.op)({maxPool_:cr});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fn(I,w=[1,1,1],x,$,O,M="NDHWC"){const j=(0,P._1)(I,"x","maxPool3d");let J=j,ye=!1;j.rank===4&&(ye=!0,J=(0,me.X)(j,[1,j.shape[0],j.shape[1],j.shape[2],j.shape[3]])),_.hu(J.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${J.rank}.`),_.hu(M==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${M}`),(0,ce.m)("maxPool3d",$,O);const $e={x:J},qe={filterSize:w,strides:x,pad:$,dimRoundingMode:O,dataFormat:M},Ze=Z.BV.runKernel(ie.OAf,$e,qe);return ye?(0,me.X)(Ze,[Ze.shape[1],Ze.shape[2],Ze.shape[3],Ze.shape[4]]):Ze}const Es=(0,W.op)({maxPool3d_:Fn});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function os(I,w,x,$,O=!1){const j={x:(0,P._1)(I,"x","maxPoolWithArgmax")},J={filterSize:w,strides:x,pad:$,includeBatchInIndex:O},ye=Z.BV.runKernel(ie.vFR,j,J);return{result:ye[0],indexes:ye[1]}}const Ta=(0,W.op)({maxPoolWithArgmax_:os});var $a=L(3624);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ya(I,w=null,x=!1){const O={x:(0,P._1)(I,"x","mean")},M={axis:w,keepDims:x};return Z.BV.runKernel(ie.q2K,O,M)}const jo=(0,W.op)({mean_:ya});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $o(I,w="float32"){if((0,_.Mu)(I),w==="complex64"){const $=$o(I,"float32"),O=$o(I,"float32");return(0,ws.P)($,O)}const x=(0,_.wT)((0,_.NA)(I),w);return Z.BV.makeTensor(x,I,w)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kr(I,w="float32"){if((0,_.Mu)(I),w==="complex64"){const $=kr(I,"float32"),O=$o(I,"float32");return(0,ws.P)($,O)}const x=(0,_.p8)((0,_.NA)(I),w);return Z.BV.makeTensor(x,I,w)}var Ko=L(8990);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ii(I,w,{indexing:x="xy"}={}){if(x!=="xy"&&x!=="ij")throw new TypeError(`${x} is not a valid third argument to meshgrid`);if(I===void 0)return[];let $=(0,P._1)(I,"x","meshgrid",I instanceof Ko.es?I.dtype:"float32");if(w===void 0)return[$];let O=(0,P._1)(w,"y","meshgrid",w instanceof Ko.es?w.dtype:"float32");const M=(0,_.NA)($.shape),j=(0,_.NA)(O.shape);return x==="xy"?($=(0,me.X)($,[1,-1]),O=(0,me.X)(O,[-1,1]),[bn(kr([j,1],$.dtype),$),bn(O,kr([1,M],O.dtype))]):($=(0,me.X)($,[-1,1]),O=(0,me.X)(O,[1,-1]),[bn($,kr([1,j],$.dtype)),bn(kr([M,1],O.dtype),O)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Na(I,w){let x=(0,P._1)(I,"a","minimum"),$=(0,P._1)(w,"b","minimum");[x,$]=(0,at.T_)(x,$),x.dtype==="bool"&&(x=(0,Ve.p)(x,"int32"),$=(0,Ve.p)($,"int32")),(0,as.assertAndGetBroadcastShape)(x.shape,$.shape);const O={a:x,b:$};return Z.BV.runKernel(ie.q8u,O)}const Ft=(0,W.op)({minimum_:Na});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ja(I,w,x){_.hu(x==="reflect"||x==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${x}.`);const $=(0,P._1)(I,"x","mirrorPad");if($.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");_.hu(w.length===$.rank,()=>`Padding doesn't match input. Must be ${$.rank}. Got ${w.length}.`);const O=x==="reflect"?1:0;for(let J=0;J<$.rank;J++)_.hu(w[J].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),_.hu(w[J][0]>=0&&w[J][0]<=$.shape[J]-O&&w[J][1]>=0&&w[J][1]<=$.shape[J]-O,()=>`Padding in dimension ${J} cannot be greater than or equal to ${$.shape[J]-O} or less than 0 for input of shape ${$.shape}`);const M={paddings:w,mode:x},j={x:$};return Z.BV.runKernel(ie.jQs,j,M)}const Yr=(0,W.op)({mirrorPad_:ja});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yr(I,w){let x=(0,P._1)(I,"a","mod"),$=(0,P._1)(w,"b","mod");[x,$]=(0,at.T_)(x,$);const O={a:x,b:$};return Z.BV.runKernel(ie.Vbg,O)}const ui=(0,W.op)({mod_:yr});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ka(I,w=null,x=!1){I=(0,P._1)(I,"x","moments");const $=(0,_.EC)(w,I.shape),O=jo(I,$,x);let M=O.shape;x||(M=(0,Er.rv)(O.shape,$));const j=(0,Ae.h)((0,A.l)((0,Ve.p)(I,"float32"),(0,me.X)(O,M))),J=jo(j,$,x);return{mean:O,variance:J}}const Vi=(0,W.op)({moments_:Ka});function li(I,w,x,$){const O=(0,P._1)(w,"data","multiRNNCell"),M=(0,P.sI)(x,"c","multiRNNCell"),j=(0,P.sI)($,"h","multiRNNCell");let J=O;const ye=[];for(let Ze=0;Ze<I.length;Ze++){const Dt=I[Ze](J,M[Ze],j[Ze]);ye.push(Dt[0]),ye.push(Dt[1]),J=Dt[1]}const $e=[],qe=[];for(let Ze=0;Ze<ye.length;Ze+=2)$e.push(ye[Ze]),qe.push(ye[Ze+1]);return[$e,qe]}const ci=(0,W.op)({multiRNNCell_:li});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function di(I,w,x,$=!1){const O=(0,P._1)(I,"logits","multinomial"),M=O.size,j=O.rank;if(M<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${M}.`);if(j>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${j}`);x=x||Math.random();const ye={logits:j===1?(0,me.X)(O,[1,-1]):O},$e={numSamples:w,seed:x,normalized:$},qe=Z.BV.runKernel(ie.NZg,ye,$e);return j===1?(0,me.X)(qe,[qe.size]):qe}const No=(0,W.op)({multinomial_:di});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hi(I,w){let x=(0,P._1)(I,"a","notEqual","string_or_numeric"),$=(0,P._1)(w,"b","notEqual","string_or_numeric");[x,$]=(0,at.T_)(x,$),(0,as.assertAndGetBroadcastShape)(x.shape,$.shape);const O={a:x,b:$};return Z.BV.runKernel(ie.yQU,O)}const Xa=(0,W.op)({notEqual_:hi});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ka(I,w,x=1,$=0,O="int32"){if(w<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${w}`);const j={indices:(0,P._1)(I,"indices","oneHot","int32")},J={dtype:O,depth:w,onValue:x,offValue:$};return Z.BV.runKernel(ie.we_,j,J)}const pi=(0,W.op)({oneHot_:ka});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ya(I){const x={x:(0,P._1)(I,"x","onesLike")};return Z.BV.runKernel(ie.qWM,x)}const U=(0,W.op)({onesLike_:Ya});function E(I,w){const x=(0,P._1)(I,"v1","outerProduct"),$=(0,P._1)(w,"v2","outerProduct");_.hu(x.rank===1&&$.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${x.rank} and ${$.rank}.`);const O=(0,me.X)(x,[-1,1]),M=(0,me.X)($,[1,-1]);return bn(O,M)}const z=(0,W.op)({outerProduct_:E});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q(I,w,x=0){const $=(0,P._1)(I,"x","pad");if($.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const O={paddings:w,constantValue:x},M={x:$};return Z.BV.runKernel(ie.lyA,M,O)}const se=(0,W.op)({pad_:q});function _e(I,w,x=0){return(0,_.hu)(w.length===2,()=>"Invalid number of paddings. Must be length of 2."),se(I,[w],x)}const Me=(0,W.op)({pad1d_:_e});function et(I,w,x=0){return(0,_.hu)(w.length===2&&w[0].length===2&&w[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),se(I,w,x)}const bt=(0,W.op)({pad2d_:et});function It(I,w,x=0){return(0,_.hu)(w.length===3&&w[0].length===2&&w[1].length===2&&w[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),se(I,w,x)}const sn=(0,W.op)({pad3d_:It});function _t(I,w,x=0){return(0,_.hu)(w.length===4&&w[0].length===2&&w[1].length===2&&w[2].length===2&&w[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),se(I,w,x)}const Tt=(0,W.op)({pad4d_:_t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kt(I,w,x){const $=(0,P._1)(I,"x","spaceToBatchND");_.hu($.rank>=1+w.length,()=>`input rank ${$.rank} should be > than [blockShape] ${w.length}`),_.hu(x.length===w.length,()=>`paddings.shape[0] ${x.length} must be equal to [blockShape] ${w.length}`),_.hu($.shape.reduce((j,J,ye)=>ye>0&&ye<=w.length?j&&(J+x[ye-1][0]+x[ye-1][1])%w[ye-1]===0:j,!0),()=>`input spatial dimensions ${$.shape.slice(1)} with paddings ${x.toString()} must be divisible by blockShapes ${w.toString()}`);const O={x:$},M={blockShape:w,paddings:x};return Z.BV.runKernel(ie.TQc,O,M)}const $n=(0,W.op)({spaceToBatchND_:Kt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qn(I,w,x,$,O,M,j){O==null&&(O=[1,1]),M==null&&(M=1),$===0&&($="valid");const J=(0,P._1)(I,"x","maxPool");let ye=J,$e=!1;J.rank===3&&($e=!0,ye=(0,me.X)(J,[1,J.shape[0],J.shape[1],J.shape[2]])),_.hu(ce.jT(M,O),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${M} and dilations '${O}'`);const qe=ce.Xw(ye.shape,w,M,O,$),Ze=[qe.dilationHeight,qe.dilationWidth];let Dt;$==="same"?Dt=Vs([qe.filterHeight,qe.filterWidth],Ze):Dt=[[0,0],[0,0]];const Yt=Ze[0]===1&&Ze[1]===1,[qt,In]=es([qe.inHeight,qe.inWidth],Ze,Dt),dn=Yt?$:"valid",Mn=Yt?ye:$n(ye,Ze,qt),Hs=(x==="avg"?()=>ct(Mn,w,M,dn,j):()=>Is(Mn,w,M,dn,j))(),$s=Yt?Hs:Un(Hs,Ze,In);return $e?(0,me.X)($s,[$s.shape[1],$s.shape[2],$s.shape[3]]):$s}function es(I,w,x){const $=x.map(qe=>qe[0]),O=x.map(qe=>qe[1]),M=I.concat($,O),j=w.map((qe,Ze)=>(qe-M[Ze]%qe)%qe),J=O.map((qe,Ze)=>qe+j[Ze]),ye=w.map((qe,Ze)=>[$[Ze],J[Ze]]),$e=w.map((qe,Ze)=>[0,j[Ze]]);return[ye,$e]}function Vs(I,w){const $=I.map((j,J)=>j+(j-1)*(w[J]-1)).map(j=>j-1),O=$.map(j=>Math.floor(j/2)),M=$.map((j,J)=>j-O[J]);return $.map((j,J)=>[O[J],M[J]])}const xa=(0,W.op)({pool_:qn});var un=L(7966),Ts=L(2351);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rs(I,w=null,x=!1){let $=(0,P._1)(I,"x","prod");$.dtype==="bool"&&($=(0,Ve.p)($,"int32"));const O={x:$},M={axis:w,keepDims:x};return Z.BV.runKernel(ie.DlI,O,M)}const qa=(0,W.op)({prod_:rs});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function po(I,w,x,$){const O=I.map((qe,Ze)=>(0,P._1)(qe,`tensors${Ze}`,"raggedGather","int32")),M=(0,P._1)(w,"paramsDenseValues","raggedGather"),j=(0,P._1)(x,"indices","raggedGather","int32"),J={paramsNestedSplits:O,paramsDenseValues:M,indices:j},ye={outputRaggedRank:$},$e=Z.BV.runKernel(ie.dDz,J,ye);return{outputNestedSplits:$e.slice(0,$e.length-1),outputDenseValues:$e[$e.length-1]}}const Ra=(0,W.op)({raggedGather_:po});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fo(I,w,x){const $=(0,P._1)(I,"starts","raggedRange"),O=(0,P._1)(w,"limits","raggedRange",$.dtype),M=(0,P._1)(x,"deltas","raggedRange",$.dtype),j={starts:$,limits:O,deltas:M},J=Z.BV.runKernel(ie.CQl,j);return{rtNestedSplits:J[0],rtDenseValues:J[1]}}const sa=(0,W.op)({raggedRange_:fo});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xo(I,w,x,$,O){const M=(0,P._1)(I,"shape","raggedTensorToTensor","int32"),j=(0,P._1)(w,"values","raggedTensorToTensor"),J=(0,P._1)(x,"defaultValue","raggedTensorToTensor",j.dtype),ye=$.map((Ze,Dt)=>(0,P._1)(Ze,`tensors${Dt}`,"raggedTensorToTensor","int32")),$e={shape:M,values:j,defaultValue:J,rowPartitionTensors:ye},qe={rowPartitionTypes:O};return Z.BV.runKernel(ie.BiW,$e,qe)}const Da=(0,W.op)({raggedTensorToTensor_:Xo});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zi(I,w,x){(0,_.Mu)(I);const $=(0,_.NA)(I);let O=null;if(x==null||x==="float32")O=new Float32Array($);else if(x==="int32")O=new Int32Array($);else if(x==="bool")O=new Uint8Array($);else throw new Error(`Unknown data type ${x}`);for(let M=0;M<$;M++)O[M]=w();return Z.BV.makeTensor(O,I,x)}const Yo=(0,W.op)({rand_:zi});var mo=L(6963);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lo{constructor(w,x,$,O,M){this.mean=w,this.stdDev=x,this.dtype=$,this.nextVal=NaN,this.truncated=O,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const j=M||Math.random();this.random=mo.alea(j.toString())}nextValue(){if(!isNaN(this.nextVal)){const O=this.nextVal;return this.nextVal=NaN,O}let w,x,$=!1;for(;!$;){let O,M,j;do O=2*this.random()-1,M=2*this.random()-1,j=O*O+M*M;while(j>=1||j===0);const J=Math.sqrt(-2*Math.log(j)/j);w=this.mean+this.stdDev*O*J,x=this.mean+this.stdDev*M*J,(!this.truncated||this.isValidTruncated(w))&&($=!0)}return(!this.truncated||this.isValidTruncated(x))&&(this.nextVal=this.convertValue(x)),this.convertValue(w)}convertValue(w){return this.dtype==null||this.dtype==="float32"?w:Math.round(w)}isValidTruncated(w){return w<=this.upper&&w>=this.lower}}class ra{constructor(w,x,$,O){this.alpha=w,this.beta=1/x,this.dtype=$;const M=O||Math.random();this.randu=mo.alea(M.toString()),this.randn=new Lo(0,1,$,!1,this.randu()),w<1?this.d=w+2/3:this.d=w-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let w,x,$,O,M,j;for(;;){do O=this.randn.nextValue(),j=1+this.c*O;while(j<=0);if(j*=j*j,w=O*O,x=1-.331*w*w,$=.5*w+this.d*(1-j+Math.log(j)),M=this.randu(),M<x||Math.log(M)<$)break}return j=1/this.beta*this.d*j,this.alpha<1&&(j*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(j)}convertValue(w){return this.dtype==="float32"?w:Math.round(w)}}class Bn{constructor(w=0,x=1,$,O){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=w,this.range=x-w,this.dtype=$,O==null&&(O=Math.random()),typeof O=="number"&&(O=O.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${w} - ${x} <= 1 and dtype is not float`);this.random=mo.alea(O)}convertValue(w){return this.canReturnFloat()?w:Math.round(w)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function sr(I){const w=I.length,x=_a(I),$=Gi(I),O=w/6*(Math.pow(x,2)+.25*Math.pow($-3,2));if(O>5.991)throw new Error(`Invalid p-value for JB: ${O}`)}function Qa(I,w,x,$){$==null&&($=testEpsilon());const O=oa(I);expectNumbersClose(O,w,$),expectNumbersClose(fi(I,O),x,$)}function oa(I){let w=0;for(let x=0;x<I.length;x++)w+=I[x];return w/I.length}function fi(I,w){let x=0;for(let $=0;$<I.length;$++){const O=I[$]-w;x+=O*O}return Math.sqrt(x/I.length)}function Gi(I){const w=oa(I),x=I.length;let $=0,O=0;for(let M=0;M<x;M++){const j=I[M]-w;$+=Math.pow(j,2),O+=Math.pow(j,4)}return 1/x*O/Math.pow(1/x*$,2)}function _a(I){const w=oa(I),x=I.length;let $=0,O=0;for(let M=0;M<x;M++){const j=I[M]-w;$+=Math.pow(j,2),O+=Math.pow(j,3)}return 1/x*O/Math.pow(1/(x-1)*$,3/2)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mi(I,w,x=1,$="float32",O){if((0,_.Mu)(I),x==null&&(x=1),$==null&&($="float32"),$!=="float32"&&$!=="int32")throw new Error(`Unsupported data type ${$}`);const M=new ra(w,x,$,O),j=(0,pr.f)(I,$);for(let J=0;J<j.values.length;J++)j.values[J]=M.nextValue();return j.toTensor()}const _u=(0,W.op)({randomGamma_:mi});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Au(I,w=0,x=1,$,O){if((0,_.Mu)(I),$!=null&&$==="bool")throw new Error(`Unsupported data type ${$}`);const M=new Lo(w,x,$,!1,O),j=(0,pr.f)(I,$);for(let J=0;J<j.values.length;J++)j.values[J]=M.nextValue();return j.toTensor()}const Ht=(0,W.op)({randomNormal_:Au});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pu(I,w,x){if(w!=null&&w==="bool")throw new Error(`Unsupported data type ${w}`);return Ht(I,0,1,w,x)}const Hi=(0,W.op)({randomStandardNormal_:Pu});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ou(I,w=0,x=1,$="float32",O){(0,_.Mu)(I);const M=(0,pr.f)(I,$),j=new Bn(w,x,null,O);for(let J=0;J<M.values.length;J++)M.values[J]=j.nextValue();return M.toTensor()}const gi=(0,W.op)({randomUniform_:Ou});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aa(I,w,x,$){return gi(I,w,x,"int32",$)}const Fu=(0,W.op)({randomUniformInt_:aa});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zs(I,w,x=1,$="float32"){if(x===0)throw new Error("Cannot have a step of zero");const O={start:I,stop:w,step:x,dtype:$};return Z.BV.runKernel(ie.e6w,{},O)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bu(I){const x={input:(0,P._1)(I,"input","real")};return Z.BV.runKernel(ie.xJR,x)}const Zt=(0,W.op)({real_:Bu});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lu(I){const x={x:(0,P._1)(I,"x","reciprocal")};return Z.BV.runKernel(ie.$HU,x)}const ia=(0,W.op)({reciprocal_:Lu});var yi=L(2124),dr=L(656);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ji(I,w){const $={x:(0,P._1)(I,"x","reverse")},O={dims:w};return Z.BV.runKernel(ie.mKl,$,O)}const go=(0,W.op)({reverse_:ji});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rr(I){const w=(0,P._1)(I,"x","reverse");return _.hu(w.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${w.rank}.`),go(w,0)}const Uu=(0,W.op)({reverse1d_:rr});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ua(I,w){const x=(0,P._1)(I,"x","reverse");return _.hu(x.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${x.rank}.`),go(x,w)}const Ki=(0,W.op)({reverse2d_:ua});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ba(I,w){const x=(0,P._1)(I,"x","reverse");return _.hu(x.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${x.rank}.`),go(x,w)}const Vn=(0,W.op)({reverse3d_:ba});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gs(I,w){const x=(0,P._1)(I,"x","reverse");return _.hu(x.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${x.rank}.`),go(x,w)}const Mu=(0,W.op)({reverse4d_:Gs});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wu(I){const x={x:(0,P._1)(I,"x","round")};return Z.BV.runKernel(ie.e07,x)}const Xi=(0,W.op)({round_:Wu});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vu(I){const x={x:(0,P._1)(I,"x","rsqrt","float32")};return Z.BV.runKernel(ie.bV0,x)}const zu=(0,W.op)({rsqrt_:Vu});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yi(I){const x={x:(0,P._1)(I,"x","selu")};return Z.BV.runKernel(ie.oFR,x)}const Gu=(0,W.op)({selu_:Yi});function Hu(I,w,x,$,O,M=[1,1],j="NHWC"){const J=(0,P._1)(I,"x","separableConv2d"),ye=(0,P._1)(w,"depthwiseFilter","separableConv2d"),$e=(0,P._1)(x,"pointwiseFilter","separableConv2d");let qe=J,Ze=!1;if(J.rank===3&&(Ze=!0,qe=(0,me.X)(J,[1,J.shape[0],J.shape[1],J.shape[2]])),j==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");_.hu(qe.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${qe.rank}.`),_.hu(ye.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${ye.rank}.`),_.hu($e.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${ye.rank}.`),_.hu($e.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${$e.shape[0]}.`),_.hu($e.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${$e.shape[1]}.`);const Dt=ye.shape[2],Yt=ye.shape[3];_.hu($e.shape[2]===Dt*Yt,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${Dt*Yt}, but got ${$e.shape[2]}.`);const qt=Ws(qe,ye,$,O,j,M),dn=Ms(qt,$e,1,"valid",j);return Ze?(0,me.X)(dn,[dn.shape[1],dn.shape[2],dn.shape[3]]):dn}const ju=(0,W.op)({separableConv2d_:Hu});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Ku(I,w){const x=(0,P._1)(I,"x","setdiff1d"),$=(0,P._1)(w,"y","setdiff1d");_.hu(x.dtype===$.dtype,()=>`x and y should have the same dtype, but got x (${x.dtype}) and y (${$.dtype}).`),_.hu(x.rank===1,()=>`x should be 1D tensor, but got x (${x.shape}).`),_.hu($.rank===1,()=>`y should be 1D tensor, but got y (${$.shape}).`);const O=await x.data(),M=await $.data(),j=new Set(M);let J=0;for(let qe=0;qe<O.length;qe++)j.has(O[qe])||J++;const ye=new Ko.YD([J],x.dtype),$e=new Ko.YD([J],"int32");for(let qe=0,Ze=0;qe<O.length;qe++)j.has(O[qe])||(ye.values[Ze]=O[qe],$e.values[Ze]=qe,Ze++);return[ye.toTensor(),$e.toTensor()]}const Za=Ku;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xu(I){const x={x:(0,P._1)(I,"x","sign")};return Z.BV.runKernel(ie.i5y,x)}const Yu=(0,W.op)({sign_:Xu});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qu(I){const x={x:(0,P._1)(I,"x","sin","float32")};return Z.BV.runKernel(ie.RQH,x)}const Qu=(0,W.op)({sin_:qu});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zu(I){const x={x:(0,P._1)(I,"x","sinh")};return Z.BV.runKernel(ie.wYB,x)}const Ju=(0,W.op)({sinh_:Zu});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function el(I,w,x){const $=(0,P._1)(I,"x","slice1d");return _.hu($.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${$.rank} tensor`),Te($,[w],[x])}const qi=(0,W.op)({slice1d_:el});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qi(I,w,x){const $=(0,P._1)(I,"x","slice2d");return _.hu($.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${$.rank} tensor`),Te($,w,x)}const Zi=(0,W.op)({slice2d_:Qi});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tl(I,w,x){const $=(0,P._1)(I,"x","slice3d");return _.hu($.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${$.rank} tensor`),Te($,w,x)}const nl=(0,W.op)({slice3d_:tl});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sl(I,w,x){const $=(0,P._1)(I,"x","slice4d");return _.hu($.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${$.rank} tensor`),Te($,w,x)}const rl=(0,W.op)({slice4d_:sl});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ol(I,w=-1){const x=(0,P._1)(I,"logits","softmax","float32");if(w===-1&&(w=x.rank-1),w!==x.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${x.rank} and dim was ${w}`);const $={logits:x},O={dim:w};return Z.BV.runKernel(ie.Gcp,$,O)}const al=(0,W.op)({softmax_:ol});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function il(I){(0,_.hu)(I.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${I.dtype}.`);const w={input:I};return Z.BV.runKernel(ie.vwp,w)}const xi=(0,W.op)({fft_:il});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ul(I){(0,_.hu)(I.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${I.dtype}.`);const w={input:I};return Z.BV.runKernel(ie.Qg5,w)}const Ja=(0,W.op)({ifft_:ul});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ll(I){const w=I.shape[I.shape.length-1],x=I.size/w;let $;if(w<=2){const O=(0,me.X)(I,[x,w]);$=Ja(O)}else{const O=[x,2*(w-1)],M=(0,me.X)(Zt(I),[x,w]),j=(0,me.X)(co(I),[x,w]),J=go(Te(M,[0,1],[x,w-2]),1),ye=(0,nn.d)(go(Te(j,[0,1],[x,w-2]),1),(0,de.i)(-1)),$e=tn([M,J],1),qe=tn([j,ye],1),Ze=(0,me.X)((0,ws.P)($e,qe),[O[0],O[1]]);$=Ja(Ze)}if($=Zt($),I.rank===3&&I.shape[0]!==0){const O=$,M=I.shape[0];$=(0,me.X)($,[M,$.shape[0]/M,$.shape[1]]),O.dispose()}return $}const Ji=(0,W.op)({irfft_:ll});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cl(I,w,x=0){const O={x:(0,P._1)(I,"x","split")},M={numOrSizeSplits:w,axis:x};return Z.BV.runKernel(ie.L8s,O,M)}const Aa=(0,W.op)({split_:cl});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function od(I,w){(0,_.hu)(I.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${I.dtype}`);let x=I.shape[I.shape.length-1];const $=I.size/x;let O;if(w!=null&&w<x){const qt=I.shape.map(dn=>0),In=I.shape.map(dn=>dn);In[I.shape.length-1]=w,O=Te(I,qt,In),x=w}else if(w!=null&&w>x){const qt=I.shape.map(In=>In);qt[I.shape.length-1]=w-x,O=tn([I,$o(qt)],I.shape.length-1),x=w}else O=I;const M=(0,fs.P)(O),j=(0,me.X)((0,ws.P)(O,M),[$,x]),J=xi(j),ye=Math.floor(x/2)+1,$e=Zt(J),qe=co(J),Ze=Aa($e,[ye,x-ye],$e.shape.length-1),Dt=Aa(qe,[ye,x-ye],qe.shape.length-1),Yt=O.shape.slice();return Yt[O.shape.length-1]=ye,(0,me.X)((0,ws.P)(Ze[0],Dt[0]),Yt)}const bi=(0,W.op)({rfft_:od});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dl(I,w){let x=(0,P._1)(I,"a","squaredDifference"),$=(0,P._1)(w,"b","squaredDifference");[x,$]=(0,at.T_)(x,$),(0,as.assertAndGetBroadcastShape)(x.shape,$.shape);const O={a:x,b:$},M={};return Z.BV.runKernel(ie._tC,O,M)}const eu=(0,W.op)({squaredDifference_:dl});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hl(I,w){const x=(0,P._1)(I,"x","squeeze","string_or_numeric");return(0,me.X)(x,(0,_.bp)(x.shape,w).newShape)}const wi=(0,W.op)({squeeze_:hl});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pa(I,w=0){const x=(0,P.sI)(I,"tensors","stack","string_or_numeric");_.hu(x.length>=1,()=>"Pass at least one tensor to tf.stack"),x.length>0&&_.hu(w<=x[0].rank,()=>"Axis must be <= rank of the tensor");const $=x,O={axis:w};return Z.BV.runKernel(ie.QiL,$,O)}const la=(0,W.op)({stack_:Pa});var pl=L(1965);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fl(I,w,x,$,O=0,M=0,j=0,J=0,ye=0){const qe={x:(0,P._1)(I,"x","stridedSlice","string_or_numeric")},Ze={begin:w,end:x,strides:$,beginMask:O,endMask:M,ellipsisMask:j,newAxisMask:J,shrinkAxisMask:ye};return Z.BV.runKernel(ie.jQk,qe,Ze)}const ml=(0,W.op)({stridedSlice_:fl});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gl(I){const x={x:(0,P._1)(I,"x","tan","float32")};return Z.BV.runKernel(ie.sEM,x)}const yl=(0,W.op)({tan_:gl});var vi=L(4594),wa=L(9790);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ds(I,w){(0,_.Cq)(I);const x=(0,P.C)(I,w);if(x.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return(0,wa.H)(I,null,x,w)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oa(I,w,x){if((0,_.Cq)(I),w!=null&&w.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const $=(0,P.C)(I,x);if($.length!==2&&$.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if($.length===1&&w==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,wa.H)(I,w,$,x)}var xl=L(7158);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bl(I,w,x){if((0,_.Cq)(I),w!=null&&w.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const $=(0,P.C)(I,x);if($.length!==4&&$.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if($.length===1&&w==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return(0,wa.H)(I,w,$,x)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ca(I,w,x){if((0,_.Cq)(I),w!=null&&w.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const $=(0,P.C)(I,x);if($.length!==5&&$.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if($.length===1&&w==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return(0,wa.H)(I,w,$,x)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wl(I,w,x){if((0,_.Cq)(I),w!=null&&w.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const $=(0,P.C)(I,x);if($.length!==6&&$.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if($.length===1&&w==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return w=w||$,(0,wa.H)(I,w,$,x)}var tu=L(1820);/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vl(I,w,x){const $=(0,P._1)(I,"tensor","tensorScatterupdate"),O=(0,P._1)(w,"indices","tensorScatterupdate","int32"),M=(0,P._1)(x,"updates","tensorScatterupdate");if(tu.b0(M,O,$.shape),$.dtype!==M.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${$.dtype} and ${M.dtype}.`);const j={tensor:$,indices:O,updates:M},J={};return Z.BV.runKernel(ie.SIB,j,J)}const Cl=(0,W.op)({tensorScatterUpdate_:vl});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nu(I,w=1,x=!0){const $=(0,P._1)(I,"x","topk");if($.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const O=$.shape[$.shape.length-1];if(w<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${w}`);if(w>O)throw new Error(`'k' passed to topk() must be <= the last dimension (${O}) but got ${w}`);const M={x:$},j={k:w,sorted:x},[J,ye]=Z.BV.runKernel(ie.cWu,M,j);return{values:J,indices:ye}}const Ci=(0,W.op)({topk_:nu});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sl(I,w=0,x=1,$,O){if((0,_.Mu)(I),$!=null&&$==="bool")throw new Error("Unsupported data type $ { dtype }");const M=new Lo(w,x,$,!0,O),j=(0,pr.f)(I,$);for(let J=0;J<j.values.length;J++)j.values[J]=M.nextValue();return j.toTensor()}const Il=(0,W.op)({truncatedNormal_:Sl});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function El(I,w=0){const x=(0,P._1)(I,"x","unique","string_or_numeric");(0,_.hu)(x.rank>0,()=>"The input tensor must be at least 1D");const $={x},O={axis:w},[M,j]=Z.BV.runKernel(ie.kpP,$,O);return{values:M,indices:j}}const va=(0,W.op)({unique_:El});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tl(I,w,x){const $=(0,P._1)(I,"x","unsortedSegmentSum"),O=(0,P._1)(w,"segmentIds","unsortedSegmentSum","int32");(0,_.hu)((0,_.GN)(x),()=>"numSegments must be of dtype int");const M={x:$,segmentIds:O},j={numSegments:x};return Z.BV.runKernel(ie.Qvg,M,j)}const $l=(0,W.op)({unsortedSegmentSum_:Tl});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nl(I,w=0){const x=(0,P._1)(I,"x","unstack","string_or_numeric");_.hu(w>=-x.shape.length&&w<x.shape.length,()=>`Axis = ${w} is not in [-${x.shape.length}, ${x.shape.length})`);const $={value:x},O={axis:w};return Z.BV.runKernel(ie.ToN,$,O)}const Si=(0,W.op)({unstack_:Nl});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kl(I,w){return Yn(I,w,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rl(I,w=!0,x,$){return Z.BV.makeVariable(I,w,x,$)}var Dl=L(9560);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function _l(I){const w=(0,P._1)(I,"condition","whereAsync","bool"),x=await w.data(),$=(0,Dl.Z)(w.shape,x);return I!==w&&w.dispose(),$}const su=_l;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Al(I,w,x){const $=(0,P._1)(I,"tensor","boolMask"),O=(0,P._1)(w,"mask","boolMask","bool"),M=x??0,j=O.rank,J=$.shape;_.hu(j>0,()=>"mask cannot be scalar"),_.k5(J.slice(M,M+j),O.shape,"mask's shape must match the first K dimensions of tensor's shape,");let ye=1;for(let In=M;In<M+j;In++)ye*=J[In];const $e=J.slice(0,M).concat([ye],J.slice(M+j)),qe=(0,me.X)($,$e),Ze=(0,me.X)(O,[-1]),Dt=await su(Ze),Yt=wi(Dt,[1]),qt=kt(qe,Yt,M);return I!==$&&$.dispose(),w!==O&&O.dispose(),Yt.dispose(),qe.dispose(),Ze.dispose(),Dt.dispose(),qt}const Fa=Al;var Ii=L(4531);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ei(I,w,x){const $=(0,P._1)(I,"x","transpose");if(w==null&&(w=$.shape.map((j,J)=>J).reverse()),_.hu($.rank===w.length,()=>`Error in transpose: rank of input ${$.rank} must match length of perm ${w}.`),w.forEach(j=>{_.hu(j>=0&&j<$.rank,()=>`All entries in 'perm' must be between 0 and ${$.rank-1} but got ${w}`)}),$.rank<=1)return $.clone();const O={x:$},M={perm:w};return $.dtype==="complex64"?(0,Ii.lu)(()=>{let j=Zt($),J=co($);return j=Z.BV.runKernel(ie.G3Y,{x:j},M),J=Z.BV.runKernel(ie.G3Y,{x:J},M),x&&(J=mr(J)),(0,ws.P)(j,J)}):Z.BV.runKernel(ie.G3Y,O,M)}const Ti=(0,W.op)({transpose_:Ei});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ca(I,w,x,$,O=!0){const M=(0,P._1)(I,"v","movingAverage"),j=(0,P._1)(w,"x","movingAverage"),J=(0,P._1)(x,"decay","movingAverage");(0,at.xg)(M,j),_.hu(_.cO(M.shape,j.shape),()=>"Shape mismatch in v and x");const ye=(0,de.i)(1),$e=(0,A.l)(ye,J);let qe=(0,nn.d)((0,A.l)(j,M),$e);if(O){_.hu($!=null,()=>"When using zeroDebias: true, step is required.");const Ze=(0,P._1)($,"step","movingAverage");qe=(0,cs.h)(qe,(0,A.l)(ye,(0,fe.s)(J,Ze)))}return(0,K.I)(M,qe)}const Pl=(0,W.op)({movingAverage_:Ca});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ru(I,w,x){(0,_.Mu)(x);const $=(0,P._1)(I,"indices","scatterND","int32"),O=(0,P._1)(w,"updates","scatterND");tu.b0(O,$,x);const M={indices:$,updates:O},j={shape:x};return Z.BV.runKernel(ie.xQA,M,j)}const Ol=(0,W.op)({scatterND_:ru});function $i(I,w,x,$){if(I.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${I.dtype}.`);if(I.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${I.shape}.`);const O=I.rank>0?I.shape[0]:1,M=I.rank>1?I.shape[1]:1;if(x.length!==M)throw new Error(`outputShape has incorrect number of elements:, ${x.length}, should be: ${M}.`);const j=w.size;if(!(w.rank===0||w.rank===1&&j===O))throw new Error(`sparseValues has incorrect shape ${w.shape}, should be [] or [${O}]`);if(w.dtype!==$.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fl(I,w,x,$=0){(0,_.Mu)(x);const O=(0,P._1)(I,"sparseIndices","sparseToDense","int32"),M=(0,P._1)(w,"sparseValues","sparseToDense","string_or_numeric"),j=(0,P._1)($,"defaultValue","sparseToDense",M.dtype);$i(O,M,x,j);const J={sparseIndices:O,sparseValues:M,defaultValue:j},ye={outputShape:x};return Z.BV.runKernel(ie.D2d,J,ye)}const ou=(0,W.op)({sparseToDense_:Fl});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bl(I,w){const x=(0,P._1)(w,"indices","gatherND","int32"),O={params:(0,P._1)(I,"x","gatherND","string_or_numeric"),indices:x};return Z.BV.runKernel(ie.q1x,O)}const Ll=(0,W.op)({gatherND_:Bl});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ul(I,w){if(w==null)return I.shape.slice();if(_.cO(I.shape,w))return w;if(I.shape.length===w.length){const x=[];for(let $=0;$<I.shape.length;$++)w[$]==null&&I.shape[$]!=null?x.push(I.shape[$]):x.push(w[$]);return x}return w}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ml(I,w,x,$){const O=(0,P._1)(I,"x","dropout");if(_.hu(O.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${O.dtype} tensor instead.`),_.hu(w>=0&&w<1,()=>`rate must be a float in the range [0, 1), but got ${w}.`),w===0)return I instanceof Ko.es?O.clone():O;const M=Ul(O,x),j=1-w,J=(0,cs.h)(Jt((0,K.I)(gi(M,0,1,"float32",$),j)),j);return(0,nn.d)(O,J)}const Wl=(0,W.op)({dropout_:Ml});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function au(I){return Math.floor(Math.pow(2,Math.ceil(Math.log(I)/Math.log(2))))}function Ni(I,w,x){const $=1-I%2,O=new Float32Array(I);for(let M=0;M<I;++M){const j=2*Math.PI*M/(I+$-1);O[M]=w-x*Math.cos(j)}return Ds(O,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function iu(I,w,x=1){const $=(0,P._1)(I,"predictions","inTopK"),O=(0,P._1)(w,"targets","inTopK");(0,_.hu)($.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${$.rank}`),(0,_.hu)($.rank-1===O.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${$.rank} and targets rank ${O.rank}`),(0,_.k5)($.shape.slice(0,$.shape.length-1),O.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const M=$.shape[$.shape.length-1];(0,_.hu)(x>0&&x<=M,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${M}), but got ${x}`);const j=await $.data(),J=await O.data(),[ye,$e]=[j.length/M,M],qe=(0,_.WP)("bool",ye);for(let Ze=0;Ze<ye;Ze++){const Dt=Ze*$e,Yt=j.subarray(Dt,Dt+$e),qt=[];for(let In=0;In<Yt.length;In++)qt.push({value:Yt[In],index:In});qt.sort((In,dn)=>dn.value-In.value),qe[Ze]=0;for(let In=0;In<x;In++)if(qt[In].index===J[Ze]){qe[Ze]=1;break}}return I!==$&&$.dispose(),w!==O&&O.dispose(),(0,vi.X)(qe,O.shape,"bool")}const Vl=iu;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ki(I,w,x,$,O,M="NHWC",j){let J=I;I.rank===3&&(J=(0,me.X)(I,[1,I.shape[0],I.shape[1],I.shape[2]]));let ye=w;ye.rank===3&&(ye=(0,me.X)(w,[1,w.shape[0],w.shape[1],w.shape[2]])),_.hu(J.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${J.shape}.`),_.hu(ye.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${ye.shape}.`),_.hu(x.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${x}.`);const $e=M==="NHWC"?J.shape[3]:J.shape[1],qe=M==="NHWC"?ye.shape[3]:ye.shape[1];_.hu($e===x[2],()=>`Error in conv2dDerFilter: depth of input ${$e}) must match input depth in filter (${x[2]}.`),_.hu(qe===x[3],()=>`Error in conv2dDerFilter: depth of dy (${qe}) must match output depth for filter (${x[3]}).`),ce.m("conv2dDerFilter",O,j);const Ze={x:J,dy:ye},Dt={strides:$,pad:O,dataFormat:M,dimRoundingMode:j,filterShape:x};return Z.BV.runKernel(ie.wUP,Ze,Dt)}const zl=(0,W.op)({conv2DBackpropFilter_:ki});var or=L(3608);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ei({x:I,filter:w,strides:x,pad:$,dataFormat:O="NHWC",dilations:M=[1,1],dimRoundingMode:j,bias:J,activation:ye="linear",preluActivationWeights:$e,leakyreluAlpha:qe}){if(ye=ye||"linear",(0,or.uy)(Z.BV.state.gradientDepth,ye)===!1){_.hu(O==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${O} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let Ln=Ms(I,w,x,$,O,M,j);return J!=null&&(Ln=(0,K.I)(Ln,J)),(0,or.QH)(Ln,ye,$e,qe)}const Ze=(0,P._1)(I,"x","conv2d","float32"),Dt=(0,P._1)(w,"filter","conv2d","float32");let Yt=Ze,qt=!1;Ze.rank===3&&(qt=!0,Yt=(0,me.X)(Ze,[1,Ze.shape[0],Ze.shape[1],Ze.shape[2]])),_.hu(Yt.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${Yt.rank}.`),_.hu(Dt.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${Dt.rank}.`),ce.m("fused conv2d",$,j);const In=O==="NHWC"?Yt.shape[3]:Yt.shape[1];_.hu(Dt.shape[2]===In,()=>`Error in conv2d: depth of input (${In}) must match input depth for filter ${Dt.shape[2]}.`),_.hu(ce.jT(x,M),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${x} and dilations '${M}'`);const dn=ce.Ix(Yt.shape,Dt.shape,x,M,$,j);let Mn;J!=null&&(Mn=(0,P._1)(J,"bias","fused conv2d"),[Mn]=(0,at.T_)(Mn,Ze),O==="NHWC"?as.assertAndGetBroadcastShape(dn.outShape,Mn.shape):(_.hu(Mn.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${Mn.shape.length}.`),_.hu(Mn.shape.length===0||Mn.shape[0]===dn.outChannels||Mn.shape[0]===1,()=>`Error in fused conv2d: bias shape (${Mn.shape}) is not compatible with the number of output channels (${dn.outChannels})`)));let Ks;if($e!=null){const Ln=$e.shape;if(_.hu(Ln.length<=1||Ln.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${Ln.length}.`),Ln.length===1)_.hu(Ln[0]===1||Ln[0]===dn.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${Ln}) is not compatible with the number of output channels (${dn.outChannels}).`);else if(Ln.length===3)try{as.assertAndGetBroadcastShape(Ln,dn.outShape)}catch{const xs=`Error in fused conv2d: PReLU activation weights (${Ln}) is not compatible with the output shape of the conv2d (${dn.outShape}).`;throw Error(xs)}Ks=(0,P._1)($e,"prelu weights","fused conv2d")}const Hs=(Ln,ys)=>{_.hu(O==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${O} but only NHWC is currently supported.`);const[xs,ds,hs,bs]=ys,qr=(0,or.Fr)(Ln,hs,ye);_.hu(ce.I0(M),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${M}'`);const Qr=Zn(ds.shape,qr,xs,x,$),Zr=zl(ds,qr,xs.shape,x,$),ko=[Qr,Zr];if(bs!=null){const Wa=(0,or.pf)(bs,qr);ko.push(Wa)}return ko},$s={x:Yt,filter:Dt,bias:Mn,preluActivationWeights:Ks},Bs={strides:x,pad:$,dataFormat:O,dilations:M,dimRoundingMode:j,activation:ye,leakyreluAlpha:qe};return J==null?(0,Nr.cb)((ys,xs,ds)=>{let hs=Z.BV.runKernel(ie._V0,$s,Bs);return ds([xs,ys,hs]),qt&&(hs=(0,me.X)(hs,[hs.shape[1],hs.shape[2],hs.shape[3]])),{value:hs,gradFunc:Hs}})(Yt,Dt):(0,Nr.cb)((ys,xs,ds,hs)=>{let bs=Z.BV.runKernel(ie._V0,$s,Bs);return hs([xs,ys,bs,ds]),qt&&(bs=(0,me.X)(bs,[bs.shape[1],bs.shape[2],bs.shape[3]])),{value:bs,gradFunc:Hs}})(Yt,Dt,Mn)}const ti=(0,W.op)({fusedConv2d_:ei});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gl(I,w,x,$,O,M=[1,1],j){let J=I;I.rank===3&&(J=(0,me.X)(I,[1,I.shape[0],I.shape[1],I.shape[2]]));let ye=w;ye.rank===3&&(ye=(0,me.X)(w,[1,w.shape[0],w.shape[1],w.shape[2]]));const $e={x:J,dy:ye},qe={strides:$,pad:O,dimRoundingMode:j,dilations:M,filterShape:x};return Z.BV.runKernel(ie.sL$,$e,qe)}const Ba=(0,W.op)({depthwiseConv2dNativeBackpropFilter_:Gl});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hl(I,w,x,$,O,M=[1,1],j){let J=w,ye=!1;w.rank===3&&(ye=!0,J=(0,me.X)(w,[1,w.shape[0],w.shape[1],w.shape[2]]));const $e={dy:J,filter:x},qe={strides:$,pad:O,dimRoundingMode:j,dilations:M,inputShape:I},Ze=Z.BV.runKernel(ie.y7R,$e,qe);return ye?(0,me.X)(Ze,[Ze.shape[1],Ze.shape[2],Ze.shape[3]]):Ze}const Ri=(0,W.op)({depthwiseConv2dNativeBackpropInput_:Hl});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jl({x:I,filter:w,strides:x,pad:$,dataFormat:O="NHWC",dilations:M=[1,1],dimRoundingMode:j,bias:J,activation:ye="linear",preluActivationWeights:$e,leakyreluAlpha:qe}){if((0,or.uy)(Z.BV.state.gradientDepth,ye)===!1){let Bs=Ws(I,w,x,$,O,M,j);return J!=null&&(Bs=(0,K.I)(Bs,J)),(0,or.QH)(Bs,ye,$e,qe)}const Ze=(0,P._1)(I,"x","depthwiseConv2d","float32"),Dt=(0,P._1)(w,"filter","depthwiseConv2d","float32");let Yt=Ze,qt=!1;Ze.rank===3&&(qt=!0,Yt=(0,me.X)(Ze,[1,Ze.shape[0],Ze.shape[1],Ze.shape[2]])),_.hu(Yt.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${Yt.rank}.`),_.hu(Dt.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${Dt.rank}.`),_.hu(Yt.shape[3]===Dt.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${Yt.shape[3]}) must match the inChannels dimension in filter ${Dt.shape[2]}.`),M==null&&(M=[1,1]),_.hu(ce.jT(x,M),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${x} and dilations '${M}'`),ce.m("fused depthwiseConv2d",$,j);const In=ce.Ix(Yt.shape,Dt.shape,x,M,$,j,!0);let dn;J!=null&&(dn=(0,P._1)(J,"bias","fused conv2d"),[dn]=(0,at.T_)(dn,Ze),as.assertAndGetBroadcastShape(In.outShape,dn.shape));let Mn;$e!=null&&(Mn=(0,P._1)($e,"prelu weights","fused depthwiseConv2d"));const Ks=(Bs,Ln)=>{_.hu(ce.I0(M),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${M}'`);const[ys,xs,ds,hs]=Ln,bs=(0,or.Fr)(Bs,ds,ye),qr=Ri(xs.shape,bs,ys,x,$,M,j),Qr=Ba(xs,bs,ys.shape,x,$,M,j);if(hs!=null){const Zr=(0,or.pf)(dn,bs);return[qr,Qr,Zr]}return[qr,Qr]},Hs={x:Yt,filter:Dt,bias:dn,preluActivationWeights:Mn},$s={strides:x,pad:$,dataFormat:O,dilations:M,dimRoundingMode:j,activation:ye,leakyreluAlpha:qe};return J==null?(0,Nr.cb)((Ln,ys,xs)=>{let ds=Z.BV.runKernel(ie.luS,Hs,$s);return xs([ys,Ln,ds]),qt&&(ds=(0,me.X)(ds,[ds.shape[1],ds.shape[2],ds.shape[3]])),{value:ds,gradFunc:Ks}})(Yt,Dt):(0,Nr.cb)((Ln,ys,xs,ds)=>{let hs=Z.BV.runKernel(ie.luS,Hs,$s);return ds([ys,Ln,hs,xs]),qt&&(hs=(0,me.X)(hs,[hs.shape[1],hs.shape[2],hs.shape[3]])),{value:hs,gradFunc:Ks}})(Yt,Dt,dn)}const uu=(0,W.op)({fusedDepthwiseConv2d_:jl});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kl({a:I,b:w,transposeA:x=!1,transposeB:$=!1,bias:O,activation:M="linear",preluActivationWeights:j,leakyreluAlpha:J=.2}){if((0,or.uy)(Z.BV.state.gradientDepth,M)===!1){let bs=bn(I,w,x,$);return O!=null&&(bs=(0,K.I)(bs,O)),(0,or.QH)(bs,M,j,J)}let ye=(0,P._1)(I,"a","fused matMul"),$e=(0,P._1)(w,"b","fused matMul");[ye,$e]=(0,at.T_)(ye,$e);const qe=x?ye.shape[ye.rank-2]:ye.shape[ye.rank-1],Ze=$?$e.shape[$e.rank-1]:$e.shape[$e.rank-2],Dt=x?ye.shape[ye.rank-1]:ye.shape[ye.rank-2],Yt=$?$e.shape[$e.rank-2]:$e.shape[$e.rank-1],qt=ye.shape.slice(0,-2),In=$e.shape.slice(0,-2),dn=_.NA(qt),Mn=_.NA(In);_.hu(qe===Ze,()=>`Error in fused matMul: inner shapes (${qe}) and (${Ze}) of Tensors with shapes ${ye.shape} and ${$e.shape} and transposeA=${x} and transposeB=${$} must match.`);const Hs=as.assertAndGetBroadcastShape(ye.shape.slice(0,-2),$e.shape.slice(0,-2)).concat([Dt,Yt]),$s=x?(0,me.X)(ye,[dn,qe,Dt]):(0,me.X)(ye,[dn,Dt,qe]),Bs=$?(0,me.X)($e,[Mn,Yt,Ze]):(0,me.X)($e,[Mn,Ze,Yt]);let Ln;O!=null&&(Ln=(0,P._1)(O,"bias","fused matMul"),[Ln]=(0,at.T_)(Ln,ye),as.assertAndGetBroadcastShape(Hs,Ln.shape));let ys;j!=null&&(ys=(0,P._1)(j,"prelu weights","fused matMul"));const xs=(bs,qr)=>{const[Qr,Zr,ko,Wa]=qr,qo=(0,or.Fr)((0,me.X)(bs,ko.shape),ko,M);let Ia,Ea;if(!x&&!$?(Ia=bn(qo,Zr,!1,!0),Ea=bn(Qr,qo,!0,!1)):!x&&$?(Ia=bn(qo,Zr,!1,!1),Ea=bn(qo,Qr,!0,!1)):x&&!$?(Ia=bn(Zr,qo,!1,!0),Ea=bn(Qr,qo,!1,!1)):(Ia=bn(Zr,qo,!0,!0),Ea=bn(qo,Qr,!0,!0)),O!=null){const qc=(0,or.pf)(Wa,qo);return[Ia,Ea,qc]}else return[Ia,Ea]},ds={a:$s,b:Bs,bias:Ln,preluActivationWeights:ys},hs={transposeA:x,transposeB:$,activation:M,leakyreluAlpha:J};return O==null?(0,Nr.cb)((qr,Qr,Zr)=>{const ko=Z.BV.runKernel(ie.usg,ds,hs);return Zr([qr,Qr,ko]),{value:(0,me.X)(ko,Hs),gradFunc:xs}})($s,Bs):(0,Nr.cb)((qr,Qr,Zr,ko)=>{const Wa=Z.BV.runKernel(ie.usg,ds,hs);return ko([qr,Qr,Wa,Zr]),{value:(0,me.X)(Wa,Hs),gradFunc:xs}})($s,Bs,Ln)}const lu=(0,W.op)({fusedMatMul_:Kl});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xl(I){return Ni(I,.54,.46)}const La=(0,W.op)({hammingWindow_:Xl});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cu(I){return Ni(I,.5,.5)}const da=(0,W.op)({hannWindow_:cu});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yl(I,w,x,$=!1,O=0){let M=0;const j=[];for(;M+w<=I.size;)j.push(Te(I,M,w)),M+=x;if($)for(;M<I.size;){const J=M+w-I.size,ye=tn([Te(I,M,w-J),(0,Dn.h)([J],O)]);j.push(ye),M+=x}return j.length===0?Oa([],[0,w]):(0,me.X)(tn(j),[j.length,w])}const du=(0,W.op)({frame_:Yl});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Di(I,w,x,$,O=da){$==null&&($=au(w));const M=du(I,w,x),j=(0,nn.d)(M,O(w));return bi(j,$)}const ql=(0,W.op)({stft_:Di});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ql(I,w,x,$,O="bilinear",M=0){const j=(0,P._1)(I,"image","cropAndResize"),J=(0,P._1)(w,"boxes","cropAndResize","float32"),ye=(0,P._1)(x,"boxInd","cropAndResize","int32"),$e=J.shape[0];_.hu(j.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${j.rank}.`),_.hu(J.rank===2&&J.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${$e},4] but had shape ${J.shape}.`),_.hu(ye.rank===1&&ye.shape[0]===$e,()=>`Error in cropAndResize: boxInd must be have size [${$e}] but had shape ${J.shape}.`),_.hu($.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${$.length}.`),_.hu($[0]>=1&&$[1]>=1,()=>`cropSize must be atleast [1,1], but was ${$}`),_.hu(O==="bilinear"||O==="nearest",()=>`method must be bilinear or nearest, but was ${O}`);const qe={image:j,boxes:J,boxInd:ye},Ze={method:O,extrapolationValue:M,cropSize:$};return Z.BV.runKernel(ie.VcC,qe,Ze)}const Zl=(0,W.op)({cropAndResize_:Ql});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jl(I){const w=(0,P._1)(I,"image","flipLeftRight","float32");_.hu(w.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${w.rank}.`);const x={image:w};return Z.BV.runKernel(ie.Uyb,x,{})}const ec=(0,W.op)({flipLeftRight_:Jl});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tc(I){const w=(0,P._1)(I,"image","grayscaleToRGB"),x=w.rank-1,$=w.shape[x];_.hu(w.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${w.rank}.`),_.hu($===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${$}.`);const O=new Array(w.rank);return O.fill(1,0,x),O[x]=3,Pt(w,O)}const nc=(0,W.op)({grayscaleToRGB_:tc});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sc(I){const w=(0,P._1)(I,"image","RGBToGrayscale"),x=w.rank-1,$=w.shape[x];_.hu(w.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${w.rank}.`),_.hu($===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${$}.`);const O=w.dtype,M=(0,Ve.p)(w,"float32"),j=Ds([.2989,.587,.114]);let J;switch(w.rank){case 2:J=ir("ij,j->i",M,j);break;case 3:J=ir("ijk,k->ij",M,j);break;case 4:J=ir("ijkl,l->ijk",M,j);break;case 5:J=ir("ijklm,m->ijkl",M,j);break;case 6:J=ir("ijklmn,n->ijklm",M,j);break;default:throw new Error("Not a valid tensor rank.")}return J=xt(J,-1),(0,Ve.p)(J,O)}const hu=(0,W.op)({rgbToGrayscale_:sc});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rc(I,w,x=0,$=.5){const O=(0,P._1)(I,"image","rotateWithOffset","float32");_.hu(O.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${O.rank}.`);const M={image:O},j={radians:w,fillValue:x,center:$};return Z.BV.runKernel(ie.b9H,M,j)}const oc=(0,W.op)({rotateWithOffset_:rc});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sa(I,w,x,$,O,M){$==null&&($=.5),O==null&&(O=Number.NEGATIVE_INFINITY),M==null&&(M=0);const j=I.shape[0];return x=Math.min(x,j),_.hu(0<=$&&$<=1,()=>`iouThreshold must be in [0, 1], but was '${$}'`),_.hu(I.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${I.rank}'`),_.hu(I.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${I.shape[1]}`),_.hu(w.rank===1,()=>"scores must be a 1D tensor"),_.hu(w.shape[0]===j,()=>`scores has incompatible shape with boxes. Expected ${j}, but was ${w.shape[0]}`),_.hu(0<=M&&M<=1,()=>`softNmsSigma must be in [0, 1], but was '${M}'`),{maxOutputSize:x,iouThreshold:$,scoreThreshold:O,softNmsSigma:M}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ni(I,w,x,$=.5,O=Number.NEGATIVE_INFINITY){const M=(0,P._1)(I,"boxes","nonMaxSuppression","float32"),j=(0,P._1)(w,"scores","nonMaxSuppression","float32"),J=Sa(M,j,x,$,O);x=J.maxOutputSize,$=J.iouThreshold,O=J.scoreThreshold;const ye={maxOutputSize:x,iouThreshold:$,scoreThreshold:O};return Z.BV.runKernel(ie.uv1,{boxes:M,scores:j},ye)}const ac=(0,W.op)({nonMaxSuppression_:ni});var ha=L(8135);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function ic(I,w,x,$=.5,O=Number.NEGATIVE_INFINITY){const M=(0,P._1)(I,"boxes","nonMaxSuppressionAsync"),j=(0,P._1)(w,"scores","nonMaxSuppressionAsync"),J=Sa(M,j,x,$,O);x=J.maxOutputSize,$=J.iouThreshold,O=J.scoreThreshold;const ye=await Promise.all([M.data(),j.data()]),$e=ye[0],qe=ye[1],{selectedIndices:Ze}=(0,ha.GP)($e,qe,x,$,O);return M!==I&&M.dispose(),j!==w&&j.dispose(),Ds(Ze,"int32")}const pu=ic;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uc(I,w,x,$=.5,O=Number.NEGATIVE_INFINITY,M=0){const j=(0,P._1)(I,"boxes","nonMaxSuppression"),J=(0,P._1)(w,"scores","nonMaxSuppression"),ye=Sa(j,J,x,$,O,M);x=ye.maxOutputSize,$=ye.iouThreshold,O=ye.scoreThreshold,M=ye.softNmsSigma;const $e={boxes:j,scores:J},qe={maxOutputSize:x,iouThreshold:$,scoreThreshold:O,softNmsSigma:M},Ze=Z.BV.runKernel(ie.W0H,$e,qe);return{selectedIndices:Ze[0],selectedScores:Ze[1]}}const ad=(0,W.op)({nonMaxSuppressionWithScore_:uc});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function lc(I,w,x,$=.5,O=Number.NEGATIVE_INFINITY,M=0){const j=(0,P._1)(I,"boxes","nonMaxSuppressionAsync"),J=(0,P._1)(w,"scores","nonMaxSuppressionAsync"),ye=Sa(j,J,x,$,O,M);x=ye.maxOutputSize,$=ye.iouThreshold,O=ye.scoreThreshold,M=ye.softNmsSigma;const $e=await Promise.all([j.data(),J.data()]),qe=$e[0],Ze=$e[1],{selectedIndices:Dt,selectedScores:Yt}=(0,ha.pA)(qe,Ze,x,$,O,M);return j!==I&&j.dispose(),J!==w&&J.dispose(),{selectedIndices:Ds(Dt,"int32"),selectedScores:Ds(Yt)}}const cc=lc;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dc(I,w,x,$=.5,O=Number.NEGATIVE_INFINITY,M=!1){const j=(0,P._1)(I,"boxes","nonMaxSuppression"),J=(0,P._1)(w,"scores","nonMaxSuppression"),ye=Sa(j,J,x,$,O,null),$e=ye.maxOutputSize,qe=ye.iouThreshold,Ze=ye.scoreThreshold,Dt={boxes:j,scores:J},Yt={maxOutputSize:$e,iouThreshold:qe,scoreThreshold:Ze,padToMaxOutputSize:M},qt=Z.BV.runKernel(ie.cye,Dt,Yt);return{selectedIndices:qt[0],validOutputs:qt[1]}}const si=(0,W.op)({nonMaxSuppressionPadded_:dc});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function hc(I,w,x,$=.5,O=Number.NEGATIVE_INFINITY,M=!1){const j=(0,P._1)(I,"boxes","nonMaxSuppressionAsync"),J=(0,P._1)(w,"scores","nonMaxSuppressionAsync"),ye=Sa(j,J,x,$,O,null),$e=ye.maxOutputSize,qe=ye.iouThreshold,Ze=ye.scoreThreshold,[Dt,Yt]=await Promise.all([j.data(),J.data()]),{selectedIndices:qt,validOutputs:In}=(0,ha.qP)(Dt,Yt,$e,qe,Ze,M);return j!==I&&j.dispose(),J!==w&&J.dispose(),{selectedIndices:Ds(qt,"int32"),validOutputs:(0,de.i)(In,"int32")}}const Ua=hc;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _i(I,w,x=!1,$=!1){const O=(0,P._1)(I,"images","resizeBilinear");_.hu(O.rank===3||O.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${O.rank}.`),_.hu(w.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${w}.`),_.hu($===!1||x===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let M=O,j=!1;O.rank===3&&(j=!0,M=(0,me.X)(O,[1,O.shape[0],O.shape[1],O.shape[2]]));const[]=w,J={images:M},ye={alignCorners:x,halfPixelCenters:$,size:w},$e=Z.BV.runKernel(ie._Yw,J,ye);return j?(0,me.X)($e,[$e.shape[1],$e.shape[2],$e.shape[3]]):$e}const fu=(0,W.op)({resizeBilinear_:_i});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mu(I,w,x=!1,$=!1){const O=(0,P._1)(I,"images","resizeNearestNeighbor");_.hu(O.rank===3||O.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${O.rank}.`),_.hu(w.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${w}.`),_.hu(O.dtype==="float32"||O.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),_.hu($===!1||x===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let M=O,j=!1;O.rank===3&&(j=!0,M=(0,me.X)(O,[1,O.shape[0],O.shape[1],O.shape[2]]));const[]=w,J={images:M},ye={alignCorners:x,halfPixelCenters:$,size:w},$e=Z.BV.runKernel(ie.dpD,J,ye);return j?(0,me.X)($e,[$e.shape[1],$e.shape[2],$e.shape[3]]):$e}const gu=(0,W.op)({resizeNearestNeighbor_:mu});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pc(I,w="binary",x=!1,$=.5){const O=(0,P._1)(I,"image","threshold"),M=.2989,j=.587,J=.114,ye=O.shape[0]*O.shape[1];let $e=(0,nn.d)(Ds([$]),255),qe,Ze,Dt,Yt;if(_.hu(O.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${O.rank}.`),_.hu(O.shape[2]===3||O.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${O.shape[2]}.`),_.hu(O.dtype==="int32"||O.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${O.dtype}.`),_.hu(w==="otsu"||w==="binary",()=>`Method must be binary or otsu, but was ${w}`),O.shape[2]===3){[qe,Ze,Dt]=Aa(O,[1,1,1],-1);const dn=(0,nn.d)(qe,M),Mn=(0,nn.d)(Ze,j),Ks=(0,nn.d)(Dt,J);Yt=(0,K.I)((0,K.I)(dn,Mn),Ks)}else Yt=I;if(w==="otsu"){const dn=to((0,Ve.p)(Xi(Yt),"int32"),(0,vi.X)([]),256);$e=fc(dn,ye)}const qt=x?Bo(Yt,$e):Vr(Yt,$e);return(0,Ve.p)((0,nn.d)(qt,255),"int32")}function fc(I,w){let x=Ds([-1]),$=Ds([0]),O=Ds([0]),M,j,J,ye,$e,qe;for(let Ze=0;Ze<I.size-1;Ze++){M=Te(I,0,Ze+1),j=Te(I,Ze+1),$e=(0,cs.h)((0,Pe.S)(M),w),qe=(0,cs.h)((0,Pe.S)(j),w);const Dt=(0,Pe.S)((0,nn.d)(M,zs(0,M.size)));J=(0,cs.h)(Dt,(0,Pe.S)(M));const Yt=(0,Dn.h)(j.shape,M.size),qt=(0,K.I)(zs(0,j.size),Yt),In=(0,nn.d)(j,qt);ye=(0,cs.h)((0,Pe.S)(In),(0,Pe.S)(j));const dn=(0,A.l)(J,ye),Mn=(0,A.l)(J,ye),Ks=(0,nn.d)($e,qe);O=(0,nn.d)((0,nn.d)(Ks,dn),Mn);const Hs=Vr(O,$);$=Ss(Hs,O,$),x=Ss(Hs,Ds([Ze]),x)}return x}const mc=(0,W.op)({threshold_:pc});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gc(I,w,x="nearest",$="constant",O=0,M){const j=(0,P._1)(I,"image","transform","float32"),J=(0,P._1)(w,"transforms","transform","float32");_.hu(j.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${j.rank}.`),_.hu(J.rank===2&&(J.shape[0]===j.shape[0]||J.shape[0]===1)&&J.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),_.hu(M==null||M.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${M}.`);const ye={image:j,transforms:J},$e={interpolation:x,fillMode:$,fillValue:O,outputShape:M};return Z.BV.runKernel(ie.wx7,ye,$e)}const yc=(0,W.op)({transform_:gc});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xc(I,w,x){const $=(0,P._1)(I,"a","bandPart");(0,_.hu)($.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${$.rank}.`);const O=$.shape,[M,j]=$.shape.slice(-2);let J,ye;typeof w=="number"?((0,_.hu)(w%1===0,()=>`bandPart(): numLower must be an integer, got ${w}.`),(0,_.hu)(w<=M,()=>`bandPart(): numLower (${w}) must not be greater than the number of rows (${M}).`),J=(0,P._1)(w<0?M:w,"numLower","bandPart")):((0,_.hu)(w.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),J=Ss(Eo(w,0),M,Ft(w,M))),typeof x=="number"?((0,_.hu)(x%1===0,()=>`bandPart(): numUpper must be an integer, got ${x}.`),(0,_.hu)(x<=j,()=>`bandPart(): numUpper (${x}) must not be greater than the number of columns (${j}).`),ye=(0,P._1)(x<0?j:x,"numUpper","bandPart")):((0,_.hu)(x.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),ye=Ss(Eo(x,0),j,Ft(x,j)));const $e=(0,me.X)(zs(0,M,1,"int32"),[-1,1]),qe=zs(0,j,1,"int32"),Ze=(0,A.l)($e,qe),Dt=lt(Bo(Ze,J),Xr(Ze,mr(ye))),Yt=$o([M,j],$.dtype);return(0,me.X)(la(Si((0,me.X)($,[-1,M,j])).map(qt=>Ss(Dt,qt,Yt))),O)}const bc=(0,W.op)({bandPart_:xc});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wc(I){let w;if(Array.isArray(I)){w=!1,(0,_.hu)(I!=null&&I.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const O=I[0].shape[0];for(let M=1;M<I.length;++M)(0,_.hu)(I[M].shape[0]===O,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${I[M].shape[0]} vs. ${O})`)}else w=!0,I=Aa(I,I.shape[0],0).map(O=>wi(O,[0]));(0,_.hu)(I.length<=I[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${I.length}) exceeds number of dimensions (${I[0].shape[0]}).`);const x=[],$=I;for(let O=0;O<I.length;++O)x.push(Z.BV.tidy(()=>{let M=$[O];if(O>0)for(let j=0;j<O;++j){const J=(0,nn.d)((0,Pe.S)((0,nn.d)(x[j],M)),x[j]);M=(0,A.l)(M,J)}return(0,cs.h)(M,Oe(M,"euclidean"))}));return w?la(x,0):x}const vc=(0,W.op)({gramSchmidt_:wc});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yu(I,w=!1){if((0,_.hu)(I.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${I.rank}`),I.rank===2)return Ai(I,w);{const x=I.shape.slice(0,I.shape.length-2).reduce((ye,$e)=>ye*$e),$=Si((0,me.X)(I,[x,I.shape[I.shape.length-2],I.shape[I.shape.length-1]]),0),O=[],M=[];$.forEach(ye=>{const[$e,qe]=Ai(ye,w);O.push($e),M.push(qe)});const j=(0,me.X)(la(O,0),I.shape),J=(0,me.X)(la(M,0),I.shape);return[j,J]}}function Ai(I,w=!1){return Z.BV.tidy(()=>{(0,_.hu)(I.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${I.shape.length}D Tensor.`);const x=I.shape[0],$=I.shape[1];let O=pn(x),M=(0,ln.d)(I);const j=Oa([[1]],[1,1]);let J=(0,ln.d)(j);const ye=x>=$?$:x;for(let $e=0;$e<ye;++$e){const qe=M,Ze=J,Dt=O;[J,M,O]=Z.BV.tidy(()=>{const Yt=Te(M,[$e,$e],[x-$e,1]),qt=Oe(Yt),In=Te(M,[$e,$e],[1,1]),dn=Ss(Vr(In,0),Oa([[-1]]),Oa([[1]])),Mn=(0,A.l)(In,(0,nn.d)(dn,qt)),Ks=(0,cs.h)(Yt,Mn);Ks.shape[0]===1?J=(0,ln.d)(j):J=tn([j,Te(Ks,[1,0],[Ks.shape[0]-1,Ks.shape[1]])],0);const Hs=mr((0,cs.h)(bn(dn,Mn),qt)),$s=Te(M,[$e,0],[x-$e,$]),Bs=(0,nn.d)(Hs,J),Ln=Ti(J);if($e===0)M=(0,A.l)($s,bn(Bs,bn(Ln,$s)));else{const ds=(0,A.l)($s,bn(Bs,bn(Ln,$s)));M=tn([Te(M,[0,0],[$e,$]),ds],0)}const ys=Ti(Bs),xs=Te(O,[0,$e],[x,O.shape[1]-$e]);if($e===0)O=(0,A.l)(xs,bn(bn(xs,J),ys));else{const ds=(0,A.l)(xs,bn(bn(xs,J),ys));O=tn([Te(O,[0,0],[x,$e]),ds],1)}return[J,M,O]}),(0,Ii.B9)([qe,Ze,Dt])}return!w&&x>$&&(O=Te(O,[0,0],[x,$]),M=Te(M,[0,0],[$,$])),[O,M]})}const Cc=(0,W.op)({qr_:yu});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var xr;(function(I){I[I.NONE=0]="NONE",I[I.MEAN=1]="MEAN",I[I.SUM=2]="SUM",I[I.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(xr||(xr={}));function Sc(I,w,x=xr.SUM_BY_NONZERO_WEIGHTS){const $=(0,P._1)(I,"losses","computeWeightedLoss");let O=null;w!=null&&(O=(0,P._1)(w,"weights","computeWeightedLoss"));const M=O==null?$:(0,nn.d)($,O);if(x===xr.NONE)return M;if(x===xr.SUM)return(0,Pe.S)(M);if(x===xr.MEAN){if(O==null)return jo(M);{const j=$.size/O.size,J=(0,cs.h)((0,Pe.S)(M),(0,Pe.S)(O));return j>1?(0,cs.h)(J,(0,de.i)(j)):J}}if(x===xr.SUM_BY_NONZERO_WEIGHTS){if(O==null)return(0,cs.h)((0,Pe.S)(M),(0,de.i)($.size));{const j=(0,nn.d)(O,kr($.shape)),J=(0,Ve.p)((0,Pe.S)(Xa(j,(0,de.i)(0))),"float32");return(0,cs.h)((0,Pe.S)(M),J)}}throw Error(`Unknown reduction: ${x}`)}const Uo=(0,W.op)({computeWeightedLoss_:Sc});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ic(I,w,x,$=xr.SUM_BY_NONZERO_WEIGHTS){const O=(0,P._1)(I,"labels","absoluteDifference"),M=(0,P._1)(w,"predictions","absoluteDifference");let j=null;x!=null&&(j=(0,P._1)(x,"weights","absoluteDifference")),(0,_.k5)(O.shape,M.shape,"Error in absoluteDifference: ");const J=(0,ze.W)((0,A.l)(O,M));return Uo(J,j,$)}const Ec=(0,W.op)({absoluteDifference_:Ic});function Tc(I,w,x,$,O=xr.SUM_BY_NONZERO_WEIGHTS){const M=(0,P._1)(I,"labels","cosineDistance"),j=(0,P._1)(w,"predictions","cosineDistance");let J=null;$!=null&&(J=(0,P._1)($,"weights","cosineDistance")),(0,_.k5)(M.shape,j.shape,"Error in cosineDistance: ");const ye=(0,de.i)(1),$e=(0,A.l)(ye,(0,Pe.S)((0,nn.d)(M,j),x,!0));return Uo($e,J,O)}const $c=(0,W.op)({cosineDistance_:Tc});function Nc(I,w,x,$=xr.SUM_BY_NONZERO_WEIGHTS){let O=(0,P._1)(I,"labels","hingeLoss");const M=(0,P._1)(w,"predictions","hingeLoss");let j=null;x!=null&&(j=(0,P._1)(x,"weights","hingeLoss")),(0,_.k5)(O.shape,M.shape,"Error in hingeLoss: ");const J=(0,de.i)(1);O=(0,A.l)((0,nn.d)((0,de.i)(2),O),J);const ye=(0,yi.U)((0,A.l)(J,(0,nn.d)(O,M)));return Uo(ye,j,$)}const kc=(0,W.op)({hingeLoss_:Nc});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rc(I,w,x,$=1,O=xr.SUM_BY_NONZERO_WEIGHTS){const M=(0,P._1)(I,"labels","huberLoss"),j=(0,P._1)(w,"predictions","huberLoss");let J=null;x!=null&&(J=(0,P._1)(x,"weights","huberLoss")),(0,_.k5)(M.shape,j.shape,"Error in huberLoss: ");const ye=(0,de.i)($),$e=(0,ze.W)((0,A.l)(j,M)),qe=Ft($e,ye),Ze=(0,A.l)($e,qe),Dt=(0,K.I)((0,nn.d)((0,de.i)(.5),(0,Ae.h)(qe)),(0,nn.d)(ye,Ze));return Uo(Dt,J,O)}const Dc=(0,W.op)({huberLoss_:Rc});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ma(I,w,x,$=1e-7,O=xr.SUM_BY_NONZERO_WEIGHTS){const M=(0,P._1)(I,"labels","logLoss"),j=(0,P._1)(w,"predictions","logLoss");let J=null;x!=null&&(J=(0,P._1)(x,"weights","logLoss")),(0,_.k5)(M.shape,j.shape,"Error in logLoss: ");const ye=(0,de.i)(1),$e=(0,de.i)($),qe=mr((0,nn.d)(M,To((0,K.I)(j,$e)))),Ze=(0,nn.d)((0,A.l)(ye,M),To((0,K.I)((0,A.l)(ye,j),$e))),Dt=(0,A.l)(qe,Ze);return Uo(Dt,J,O)}const xu=(0,W.op)({logLoss_:Ma});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bu(I,w,x,$=xr.SUM_BY_NONZERO_WEIGHTS){const O=(0,P._1)(I,"labels","meanSquaredError"),M=(0,P._1)(w,"predictions","meanSquaredError");let j=null;x!=null&&(j=(0,P._1)(x,"weights","meanSquaredError")),(0,_.k5)(O.shape,M.shape,"Error in meanSquaredError: ");const J=eu(O,M);return Uo(J,j,$)}const wu=(0,W.op)({meanSquaredError_:bu});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _c(I,w){const x=(0,P._1)(I,"labels","sigmoidCrossEntropyWithLogits"),$=(0,P._1)(w,"logits","sigmoidCrossEntropyWithLogits");(0,_.k5)(x.shape,$.shape,"Error in sigmoidCrossEntropyWithLogits: ");const O=(0,yi.U)($),M=(0,nn.d)($,x),j=Gt(yt(mr((0,ze.W)($))));return(0,K.I)((0,A.l)(O,M),j)}function id(I,w,x,$=0,O=xr.SUM_BY_NONZERO_WEIGHTS){let M=(0,P._1)(I,"multiClassLabels","sigmoidCrossEntropy");const j=(0,P._1)(w,"logits","sigmoidCrossEntropy");let J=null;if(x!=null&&(J=(0,P._1)(x,"weights","sigmoidCrossEntropy")),(0,_.k5)(M.shape,j.shape,"Error in sigmoidCrossEntropy: "),$>0){const $e=(0,de.i)($),qe=(0,de.i)(1),Ze=(0,de.i)(.5);M=(0,K.I)((0,nn.d)(M,(0,A.l)(qe,$e)),(0,nn.d)(Ze,$e))}const ye=_c(M,j);return Uo(ye,J,O)}const Ac=(0,W.op)({sigmoidCrossEntropy_:id});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pc(I,w,x=-1){if(x===-1&&(x=w.rank-1),x!==w.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${w.rank} and dim was ${x}`);return(0,Nr.cb)((O,M,j)=>{const ye=Ie(M,[x],!0),$e=(0,A.l)((0,Ve.p)(M,"float32"),ye);j([O,$e]);const qe=mr((0,nn.d)($e,O));return{value:(0,Pe.S)(qe,[x]),gradFunc:(Yt,qt)=>{const[In,dn]=qt,Mn=(0,Er.rv)(Yt.shape,[x]);return[(0,nn.d)((0,me.X)(Yt,Mn),(0,A.l)((0,Ve.p)(In,"float32"),yt(dn))),(0,nn.d)((0,me.X)(Yt,Mn),(0,A.l)(yt(dn),(0,Ve.p)(In,"float32")))]}}})(I,w)}function Oc(I,w,x,$=0,O=xr.SUM_BY_NONZERO_WEIGHTS){let M=(0,P._1)(I,"onehotLabels","softmaxCrossEntropy");const j=(0,P._1)(w,"logits","softmaxCrossEntropy");let J=null;if(x!=null&&(J=(0,P._1)(x,"weights","softmaxCrossEntropy")),(0,_.k5)(M.shape,j.shape,"Error in softmaxCrossEntropy: "),$>0){const $e=(0,de.i)($),qe=(0,de.i)(1),Ze=(0,de.i)(M.shape[1]);M=(0,K.I)((0,nn.d)(M,(0,A.l)(qe,$e)),(0,cs.h)($e,Ze))}const ye=Pc(M,j);return Uo(ye,J,O)}const Fc=(0,W.op)({softmaxCrossEntropy_:Oc});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bc(I,w,x,$){const O=(0,P._1)(I,"indices","sparseFillEmptyRows","int32"),M=(0,P._1)(w,"values","sparseFillEmptyRows"),j=(0,P._1)(x,"denseShape","sparseFillEmptyRows","int32"),J=(0,P._1)($,"defaultValue","sparseFillEmptyRows",M.dtype);if(O.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${O.shape}`);if(M.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${M.shape}`);if(j.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${j.shape}`);if(J.rank!==0)throw new Error(`Default value should be a scalar but received shape ${J.shape}`);const ye={indices:O,values:M,denseShape:j,defaultValue:J},$e=Z.BV.runKernel(ie.O3z,ye);return{outputIndices:$e[0],outputValues:$e[1],emptyRowIndicator:$e[2],reverseIndexMap:$e[3]}}const Lc=(0,W.op)({sparseFillEmptyRows_:Bc});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ud(I,w,x){const $=(0,P._1)(I,"inputIndices","sparseReshape","int32"),O=(0,P._1)(w,"inputShape","sparseReshape","int32"),M=(0,P._1)(x,"newShape","sparseReshape","int32");if($.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${$.shape}`);if(O.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${O.shape}`);if(M.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${M.shape}`);const j={inputIndices:$,inputShape:O,newShape:M},J=Z.BV.runKernel(ie.nhH,j);return{outputIndices:J[0],outputShape:J[1]}}const ld=(0,W.op)({sparseReshape_:ud});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uc(I,w,x){const $=(0,P._1)(I,"data","sparseSegmentMean"),O=(0,P._1)(w,"indices","sparseSegmentMean","int32"),M=(0,P._1)(x,"segmentIds","sparseSegmentMean","int32");if($.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(O.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${O.shape}`);if(M.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${M.shape}`);const j={data:$,indices:O,segmentIds:M};return Z.BV.runKernel(ie.w3H,j)}const vu=(0,W.op)({sparseSegmentMean_:Uc});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cu(I,w,x){const $=(0,P._1)(I,"data","sparseSegmentSum"),O=(0,P._1)(w,"indices","sparseSegmentSum","int32"),M=(0,P._1)(x,"segmentIds","sparseSegmentSum","int32");if($.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(O.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${O.shape}`);if(M.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${M.shape}`);const j={data:$,indices:O,segmentIds:M};return Z.BV.runKernel(ie.ZjV,j)}const Mc=(0,W.op)({sparseSegmentSum_:Cu});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wc(I,w,x,$,O,M,j,J){const ye=(0,P._1)(I,"data","stringNGrams","string");if(ye.dtype!=="string")throw new Error("Data must be of datatype string");if(ye.shape.length!==1)throw new Error(`Data must be a vector, saw: ${ye.shape}`);const $e=(0,P._1)(w,"dataSplits","stringNGrams");if($e.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const qe={separator:x,nGramWidths:$,leftPad:O,rightPad:M,padWidth:j,preserveShortSequences:J},Ze={data:ye,dataSplits:$e},Dt=Z.BV.runKernel(ie._JP,Ze,qe);return{nGrams:Dt[0],nGramsSplits:Dt[1]}}const Vc=(0,W.op)({stringNGrams_:Wc});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cd(I,w,x=!0){const $=(0,P._1)(I,"input","stringSplit","string"),O=(0,P._1)(w,"delimiter","stringSplit","string");if($.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${$.shape}`);if(O.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${O.shape}`);const M={skipEmpty:x},j={input:$,delimiter:O},J=Z.BV.runKernel(ie.s1s,j,M);return{indices:J[0],values:J[1],shape:J[2]}}const Su=(0,W.op)({stringSplit_:cd});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zc(I,w){const x=(0,P._1)(I,"input","stringToHashBucketFast","string"),$={numBuckets:w};if(w<=0)throw new Error("Number of buckets must be at least 1");const O={input:x};return Z.BV.runKernel(ie.XkS,O,$)}const Pi=(0,W.op)({stringToHashBucketFast_:zc});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gc(I,w,x,$=!0){const O=(0,P._1)(I,"input","staticRegexReplace","string"),M={pattern:w,rewrite:x,replaceGlobal:$};return Z.BV.runKernel(ie.e0R,{x:O},M)}const Iu=(0,W.op)({staticRegexReplace_:Gc});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hc={fft:xi,ifft:Ja,rfft:bi,irfft:Ji},jc={hammingWindow:La,hannWindow:da,frame:du,stft:ql},Eu={flipLeftRight:ec,grayscaleToRGB:nc,resizeNearestNeighbor:gu,resizeBilinear:fu,rgbToGrayscale:hu,rotateWithOffset:oc,cropAndResize:Zl,nonMaxSuppression:ac,nonMaxSuppressionAsync:pu,nonMaxSuppressionWithScore:ad,nonMaxSuppressionWithScoreAsync:cc,nonMaxSuppressionPadded:si,nonMaxSuppressionPaddedAsync:Ua,threshold:mc,transform:yc},Tu={bandPart:bc,gramSchmidt:vc,qr:Cc},Kc={absoluteDifference:Ec,computeWeightedLoss:Uo,cosineDistance:$c,hingeLoss:kc,huberLoss:Dc,logLoss:xu,meanSquaredError:wu,sigmoidCrossEntropy:Ac,softmaxCrossEntropy:Fc},Xc={sparseFillEmptyRows:Lc,sparseReshape:ld,sparseSegmentMean:vu,sparseSegmentSum:Mc},Yc={stringNGrams:Vc,stringSplit:Su,stringToHashBucketFast:Pi,staticRegexReplace:Iu}},5650:function(Wt,dt,L){"use strict";L.d(dt,{s:()=>pe});var p=L(6201),ze=L(4403),Z=L(6802),ie=L(6857),P=L(7264);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W(ee,we){let xe=(0,ie._1)(ee,"base","pow"),K=(0,ie._1)(we,"exp","pow");[xe,K]=(0,Z.T_)(xe,K);const _={a:xe,b:K};return p.BV.runKernel(ze.pe_,_)}const pe=(0,P.op)({pow_:W})},7966:function(Wt,dt,L){"use strict";L.d(dt,{A:()=>W});var p=L(6201),ze=L(4403),Z=L(6857),ie=L(7264);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P(pe,ee){const we=(0,Z._1)(pe,"x","prelu"),xe=(0,Z._1)(ee,"alpha","prelu"),K={x:we,alpha:xe};return p.BV.runKernel(ze.o0g,K)}const W=(0,ie.op)({prelu_:P})},2351:function(Wt,dt,L){"use strict";L.d(dt,{S:()=>p});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p(ze,Z=!1){console.log(ze.toString(Z))}},2124:function(Wt,dt,L){"use strict";L.d(dt,{U:()=>W});var p=L(6201),ze=L(4403),Z=L(6857),ie=L(7264);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P(pe){const we={x:(0,Z._1)(pe,"x","relu")};return p.BV.runKernel(ze.qkr,we)}const W=(0,ie.op)({relu_:P})},656:function(Wt,dt,L){"use strict";L.d(dt,{b:()=>W});var p=L(6201),ze=L(4403),Z=L(6857),ie=L(7264);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P(pe){const we={x:(0,Z._1)(pe,"x","relu6")};return p.BV.runKernel(ze.SbG,we)}const W=(0,ie.op)({relu6_:P})},1067:function(Wt,dt,L){"use strict";L.d(dt,{X:()=>W});var p=L(6201),ze=L(4403),Z=L(6857),ie=L(7264);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P(pe,ee){const xe={x:(0,Z._1)(pe,"x","reshape","string_or_numeric")},K={shape:ee};return p.BV.runKernel(ze.HZH,xe,K)}const W=(0,ie.op)({reshape_:P})},528:function(Wt,dt,L){"use strict";L.d(dt,{i:()=>Z});var p=L(2891),ze=L(9790);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z(ie,P){if(((0,p.isTypedArray)(ie)&&P!=="string"||Array.isArray(ie))&&P!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(P==="string"&&(0,p.isTypedArray)(ie)&&!(ie instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");const W=[],pe=[];return(0,ze.H)(ie,W,pe,P)}},1820:function(Wt,dt,L){"use strict";L.d(dt,{SU:()=>ie,b0:()=>Z,l5:()=>ze});var p=L(9024);function ze(P,W,pe){const ee=W.rank>1?W.shape[W.rank-1]:1,we=W.rank>1?W.rank-1:1,xe=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${pe.shape}, indices.shape: ${W.shape}, shape: ${P}, sliceDim: ${ee}, and batchDim: ${we}.`;if(pe.rank<we)throw new Error(xe+` update.rank < ${we}. `);if(P.length<ee+(pe.rank-we))throw new Error(xe+` Output shape length < ${ee+(pe.rank-we)}`);if(pe.rank!==we+P.length-ee)throw new Error(xe+` update.rank != ${we+P.length-ee}`);for(let K=0;K<we;++K)if(pe.shape[K]!==W.shape[K])throw new Error(xe+` updates.shape[${K}] (${pe.shape[K]}) != indices.shape[${K}] (${W.shape[K]}).`);for(let K=0;K<pe.rank-we;++K)if(pe.shape[K+we]!==P[K+ee])throw new Error(xe+` updates.shape[${K+we}] (${pe.shape[K+we]}) != shape[${K+we}] (${P[K+we]})`)}function Z(P,W,pe){if(W.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${W.rank}.`);if(P.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${P.rank}.`);if(W.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${W.dtype}`);if(pe.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${pe}`);if(pe.length===0){if(W.size===0)throw new Error(`Indices specified for empty output. indices shape: ${W.shape}`);if(P.size===0)throw new Error(`Updates specified for empty output. updates shape: ${P.shape}`)}ze(pe,W,P)}function ie(P,W,pe){const ee=W.shape.length,we=ee>1?W.shape[ee-1]:1,xe=pe.length;let K=1;for(let rt=we;rt<xe;++rt)K*=pe[rt];const _=we<1?1:we,De=(0,p.NA)(W.shape)/_,Fe=[...(0,p.e3)(pe.slice(0,we)),1],Ke=(0,p.NA)(pe);return{sliceRank:we,numUpdates:De,sliceSize:K,strides:Fe,outputSize:Ke}}},5466:function(Wt,dt,L){"use strict";L.d(dt,{X:()=>W});var p=L(6201),ze=L(4403),Z=L(6857),ie=L(7264);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P(pe){const we={x:(0,Z._1)(pe,"x","sigmoid","float32")};return p.BV.runKernel(ze.a5O,we)}const W=(0,ie.op)({sigmoid_:P})},9896:function(Wt,dt,L){"use strict";L.d(dt,{_:()=>W});var p=L(6201),ze=L(4403),Z=L(6857),ie=L(7264);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P(pe){const we={x:(0,Z._1)(pe,"x","sqrt","float32")};return p.BV.runKernel(ze.FKq,we)}const W=(0,ie.op)({sqrt_:P})},414:function(Wt,dt,L){"use strict";L.d(dt,{h:()=>P});var p=L(6201),ze=L(6857),Z=L(7264);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ie(W){const pe=(0,ze._1)(W,"x","square"),ee={};return p.BV.runKernel("Square",{x:pe},ee)}const P=(0,Z.op)({square_:ie})},1965:function(Wt,dt,L){"use strict";L.d(dt,{N:()=>W});var p=L(6201),ze=L(4403),Z=L(6857),ie=L(7264);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P(pe,ee=0){const xe={x:(0,Z._1)(pe,"x","step")},K={alpha:ee};return p.BV.runKernel(ze.h8e,xe,K)}const W=(0,ie.op)({step_:P})},8712:function(Wt,dt,L){"use strict";L.d(dt,{l:()=>pe});var p=L(6201),ze=L(4403),Z=L(6802),ie=L(6857),P=L(7264);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W(ee,we){let xe=(0,ie._1)(ee,"a","sub"),K=(0,ie._1)(we,"b","sub");[xe,K]=(0,Z.T_)(xe,K);const _={a:xe,b:K};return p.BV.runKernel(ze.Tr8,_)}const pe=(0,P.op)({sub_:W})},5580:function(Wt,dt,L){"use strict";L.d(dt,{S:()=>pe});var p=L(6201),ze=L(4403),Z=L(6857),ie=L(8341),P=L(7264);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W(ee,we=null,xe=!1){let K=(0,Z._1)(ee,"x","sum");K.dtype==="bool"&&(K=(0,ie.p)(K,"int32"));const _={x:K},De={axis:we,keepDims:xe};return p.BV.runKernel(ze.GBy,_,De)}const pe=(0,P.op)({sum_:W})},4594:function(Wt,dt,L){"use strict";L.d(dt,{X:()=>Z});var p=L(6857),ze=L(9790);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z(ie,P,W){const pe=(0,p.C)(ie,W);return(0,ze.H)(ie,P,pe,W)}},7158:function(Wt,dt,L){"use strict";L.d(dt,{w:()=>ie});var p=L(6857),ze=L(9024),Z=L(9790);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ie(P,W,pe){if((0,ze.Cq)(P),W!=null&&W.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const ee=(0,p.C)(P,pe);if(ee.length!==3&&ee.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(ee.length===1&&W==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,Z.H)(P,W,ee,pe)}},9790:function(Wt,dt,L){"use strict";L.d(dt,{H:()=>P});var p=L(6201),ze=L(6154),Z=L(9024),ie=L(2891);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P(W,pe,ee,we){if(we==null)we=(0,Z.D2)(W);else if(we==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if((0,ze.$F)(W)||(0,ze.Oq)(W)){if(we!=="float32"&&we!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${we}.`);return p.BV.backend.createTensorFromGPUData(W,pe||ee,we)}if(!(0,ie.isTypedArray)(W)&&!Array.isArray(W)&&typeof W!="number"&&typeof W!="boolean"&&typeof W!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(pe!=null){(0,Z.Mu)(pe);const xe=(0,Z.NA)(pe),K=(0,Z.NA)(ee);(0,Z.hu)(xe===K,()=>`Based on the provided shape, [${pe}], the tensor should have ${xe} values but has ${K}`);for(let _=0;_<ee.length;++_){const De=ee[_],Fe=_===ee.length-1?De!==(0,Z.NA)(pe.slice(_)):!0;(0,Z.hu)(ee[_]===pe[_]||!Fe,()=>`Error creating a new Tensor. Inferred shape (${ee}) does not match the provided shape (${pe}). `)}}return!(0,ie.isTypedArray)(W)&&!Array.isArray(W)&&(W=[W]),pe=pe||ee,W=we!=="string"?(0,ie.toTypedArray)(W,we):(0,ie.flatten)(W,[],!0),p.BV.makeTensor(W,pe,we)}},9146:function(Wt,dt,L){"use strict";L.d(dt,{P:()=>W});var p=L(6201),ze=L(4403),Z=L(6857),ie=L(7264);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P(pe){const we={x:(0,Z._1)(pe,"x","zerosLike")};return p.BV.runKernel(ze.RuY,we)}const W=(0,ie.op)({zerosLike_:P})},5830:function(Wt,dt,L){"use strict";L.d(dt,{j:()=>p});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p(ze){return ze instanceof Float32Array||ze instanceof Int32Array||ze instanceof Uint8Array||ze instanceof Uint8ClampedArray}},8990:function(Wt,dt,L){"use strict";L.d(dt,{Vi:()=>ht,es:()=>$t,YD:()=>De,t3:()=>ve,_w:()=>y,FZ:()=>on,Vp:()=>Vt});var p=L(2360),ze=L(9024);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z=20,ie=3,P=7;function W(Qe,V,re,G){const Re=(0,ze.e3)(V),Be=pe(Qe,V,re,Re),at=V.length,S=xe(Qe,V,re,Re,Be),nt=["Tensor"];return G&&(nt.push(`  dtype: ${re}`),nt.push(`  rank: ${at}`),nt.push(`  shape: [${V}]`),nt.push("  values:")),nt.push(S.map(ne=>"    "+ne).join(`
`)),nt.join(`
`)}function pe(Qe,V,re,G){const Re=(0,ze.NA)(V),Be=G[G.length-1],at=new Array(Be).fill(0),S=V.length,nt=re==="complex64"?K(Qe):Qe;if(S>1)for(let ne=0;ne<Re/Be;ne++){const Ne=ne*Be;for(let Ve=0;Ve<Be;Ve++)at[Ve]=Math.max(at[Ve],ee(nt[Ne+Ve],0,re).length)}return at}function ee(Qe,V,re){let G;return Array.isArray(Qe)?G=`${parseFloat(Qe[0].toFixed(P))} + ${parseFloat(Qe[1].toFixed(P))}j`:(0,ze.HD)(Qe)?G=`'${Qe}'`:re==="bool"?G=we(Qe):G=parseFloat(Qe.toFixed(P)).toString(),(0,ze.oj)(G,V)}function we(Qe){return Qe===0?"false":"true"}function xe(Qe,V,re,G,Re,Be=!0){const at=re==="complex64"?2:1,S=V[0],nt=V.length;if(nt===0){if(re==="complex64"){const ct=K(Qe);return[ee(ct[0],0,re)]}return re==="bool"?[we(Qe[0])]:[Qe[0].toString()]}if(nt===1){if(S>Z){const Lt=ie*at;let Nt=Array.from(Qe.slice(0,Lt)),ln=Array.from(Qe.slice((S-ie)*at,S*at));return re==="complex64"&&(Nt=K(Nt),ln=K(ln)),["["+Nt.map((Sn,tn)=>ee(Sn,Re[tn],re)).join(", ")+", ..., "+ln.map((Sn,tn)=>ee(Sn,Re[S-ie+tn],re)).join(", ")+"]"]}return["["+(re==="complex64"?K(Qe):Array.from(Qe)).map((Lt,Nt)=>ee(Lt,Re[Nt],re)).join(", ")+"]"]}const ne=V.slice(1),Ne=G.slice(1),Ve=G[0]*at,ce=[];if(S>Z){for(let ct=0;ct<ie;ct++){const Lt=ct*Ve,Nt=Lt+Ve;ce.push(...xe(Qe.slice(Lt,Nt),ne,re,Ne,Re,!1))}ce.push("...");for(let ct=S-ie;ct<S;ct++){const Lt=ct*Ve,Nt=Lt+Ve;ce.push(...xe(Qe.slice(Lt,Nt),ne,re,Ne,Re,ct===S-1))}}else for(let ct=0;ct<S;ct++){const Lt=ct*Ve,Nt=Lt+Ve;ce.push(...xe(Qe.slice(Lt,Nt),ne,re,Ne,Re,ct===S-1))}const me=nt===2?",":"";ce[0]="["+(S>0?ce[0]+me:"");for(let ct=1;ct<ce.length-1;ct++)ce[ct]=" "+ce[ct]+me;let pt=`,
`;for(let ct=2;ct<nt;ct++)pt+=`
`;return ce[ce.length-1]=" "+ce[ce.length-1]+"]"+(Be?"":pt),ce}function K(Qe){const V=[];for(let re=0;re<Qe.length;re+=2)V.push([Qe[re],Qe[re+1]]);return V}var _=L(2891);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class De{constructor(V,re,G){if(this.dtype=re,this.shape=V.slice(),this.size=ze.NA(V),G!=null){const Re=G.length;ze.hu(Re===this.size,()=>`Length of values '${Re}' does not match the size inferred by the shape '${this.size}'.`)}if(re==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=G||ze.rQ(re,this.size),this.strides=(0,ze.e3)(V)}set(V,...re){re.length===0&&(re=[0]),ze.hu(re.length===this.rank,()=>`The number of provided coordinates (${re.length}) must match the rank (${this.rank})`);const G=this.locToIndex(re);this.values[G]=V}get(...V){V.length===0&&(V=[0]);let re=0;for(const Re of V){if(Re<0||Re>=this.shape[re]){const Be=`Requested out of range element at ${V}.   Buffer shape=${this.shape}`;throw new Error(Be)}re++}let G=V[V.length-1];for(let Re=0;Re<V.length-1;++Re)G+=this.strides[Re]*V[Re];return this.values[G]}locToIndex(V){if(this.rank===0)return 0;if(this.rank===1)return V[0];let re=V[V.length-1];for(let G=0;G<V.length-1;++G)re+=this.strides[G]*V[G];return re}indexToLoc(V){if(this.rank===0)return[];if(this.rank===1)return[V];const re=new Array(this.shape.length);for(let G=0;G<re.length-1;++G)re[G]=Math.floor(V/this.strides[G]),V-=re[G]*this.strides[G];return re[re.length-1]=V,re}get rank(){return this.shape.length}toTensor(){return Fe().makeTensor(this.values,this.shape,this.dtype)}}let Fe=null,Ke=null,rt=null;function ht(Qe){Fe=Qe}function Vt(Qe){Ke=Qe}function on(Qe){rt=Qe}class $t{constructor(V,re,G,Re){this.kept=!1,this.isDisposedInternal=!1,this.shape=V.slice(),this.dtype=re||"float32",this.size=ze.NA(V),this.strides=(0,ze.e3)(V),this.dataId=G,this.id=Re,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const V=await this.data();return Ke.buffer(this.shape,this.dtype,V)}bufferSync(){return Ke.buffer(this.shape,this.dtype,this.dataSync())}async array(){const V=await this.data();return(0,ze.GX)(this.shape,V,this.dtype==="complex64")}arraySync(){return(0,ze.GX)(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const V=Fe().read(this.dataId);if(this.dtype==="string"){const re=await V;try{return re.map(G=>_.decodeString(G))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return V}dataToGPU(V){return this.throwIfDisposed(),Fe().readToGPU(this.dataId,V)}dataSync(){this.throwIfDisposed();const V=Fe().readSync(this.dataId);if(this.dtype==="string")try{return V.map(re=>_.decodeString(re))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return V}async bytes(){this.throwIfDisposed();const V=await Fe().read(this.dataId);return this.dtype==="string"?V:new Uint8Array(V.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Fe().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(V=!1){return Ke.print(this,V)}clone(){return this.throwIfDisposed(),Ke.clone(this)}toString(V=!1){const re=this.dataSync();return W(re,this.shape,this.dtype,V)}cast(V){return this.throwIfDisposed(),Ke.cast(this,V)}variable(V=!0,re,G){return this.throwIfDisposed(),Fe().makeVariable(this,V,re,G)}}Object.defineProperty($t,Symbol.hasInstance,{value:Qe=>!!Qe&&Qe.data!=null&&Qe.dataSync!=null&&Qe.throwIfDisposed!=null});function ve(){return(0,p.R)("Tensor",()=>$t)}ve();class y extends $t{constructor(V,re,G,Re){super(V.shape,V.dtype,V.dataId,Re),this.trainable=re,this.name=G}assign(V){if(V.dtype!==this.dtype)throw new Error(`dtype of the new value (${V.dtype}) and previous value (${this.dtype}) must match`);if(!ze.cO(V.shape,this.shape))throw new Error(`shape of the new value (${V.shape}) and previous value (${this.shape}) must match`);Fe().disposeTensor(this),this.dataId=V.dataId,Fe().incRef(this,null)}dispose(){Fe().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(y,Symbol.hasInstance,{value:Qe=>Qe instanceof $t&&Qe.assign!=null&&Qe.assign instanceof Function})},6802:function(Wt,dt,L){"use strict";L.d(dt,{T_:()=>ie,Vu:()=>pe,xg:()=>P});var p=L(8990),ze=L(6154),Z=L(9024);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ie(xe,K){if(xe.dtype===K.dtype)return[xe,K];const _=(0,ze.x8)(xe.dtype,K.dtype);return[xe.cast(_),K.cast(_)]}function P(xe,K){(0,Z.hu)(xe.dtype===K.dtype,()=>`The dtypes of the first(${xe.dtype}) and second(${K.dtype}) input must match`)}function W(xe,K){return K.some(_=>_.id===xe.id)}function pe(xe){const K=[];return ee(xe,K,new Set),K}function ee(xe,K,_){if(xe==null)return;if(xe instanceof p.es){K.push(xe);return}if(!we(xe))return;const De=xe;for(const Fe in De){const Ke=De[Fe];_.has(Ke)||(_.add(Ke),ee(Ke,K,_))}}function we(xe){return Array.isArray(xe)||typeof xe=="object"}},6857:function(Wt,dt,L){"use strict";L.d(dt,{C:()=>pe,_1:()=>xe,sI:()=>K});var p=L(6201),ze=L(6650),Z=L(8990),ie=L(6154),P=L(2891),W=L(9024);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pe(_,De){let Fe=_;if((0,P.isTypedArray)(_))return De==="string"?[]:[_.length];if((0,ie.Oq)(_)){const rt=_.channels||"RGBA";return[_.height,_.width*rt.length]}else if((0,ie.$F)(_))return[_.buffer.size/(De==null?4:(0,W.bT)(De))];if(!Array.isArray(_))return[];const Ke=[];for(;Array.isArray(Fe)||(0,P.isTypedArray)(Fe)&&De!=="string";)Ke.push(Fe.length),Fe=Fe[0];return Array.isArray(_)&&(0,ze.OB)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&ee(_,Ke,[]),Ke}function ee(_,De,Fe){if(Fe=Fe||[],!Array.isArray(_)&&!(0,P.isTypedArray)(_)){(0,W.hu)(De.length===0,()=>`Element arr[${Fe.join("][")}] is a primitive, but should be an array/TypedArray of ${De[0]} elements`);return}(0,W.hu)(De.length>0,()=>`Element arr[${Fe.join("][")}] should be a primitive, but is an array of ${_.length} elements`),(0,W.hu)(_.length===De[0],()=>`Element arr[${Fe.join("][")}] should have ${De[0]} elements, but has ${_.length} elements`);const Ke=De.slice(1);for(let rt=0;rt<_.length;++rt)ee(_[rt],Ke,Fe.concat(rt))}function we(_,De,Fe,Ke){if(_!=="string_or_numeric"){if(_==null)throw new Error("Expected dtype cannot be null.");if(_!=="numeric"&&_!==De||_==="numeric"&&De==="string")throw new Error(`Argument '${Fe}' passed to '${Ke}' must be ${_} tensor, but got ${De} tensor`)}}function xe(_,De,Fe,Ke="numeric"){if(_ instanceof(0,Z.t3)())return we(Ke,_.dtype,De,Fe),_;let rt=(0,W.D2)(_);if(rt!=="string"&&["bool","int32","float32"].indexOf(Ke)>=0&&(rt=Ke),we(Ke,rt,De,Fe),_==null||!(0,P.isTypedArray)(_)&&!Array.isArray(_)&&typeof _!="number"&&typeof _!="boolean"&&typeof _!="string"){const $t=_==null?"null":_.constructor.name;throw new Error(`Argument '${De}' passed to '${Fe}' must be a Tensor or TensorLike, but got '${$t}'`)}const ht=pe(_,rt);!(0,P.isTypedArray)(_)&&!Array.isArray(_)&&(_=[_]);const on=rt!=="string"?(0,P.toTypedArray)(_,rt):(0,P.flatten)(_,[],!0);return p.BV.makeTensor(on,ht,rt)}function K(_,De,Fe,Ke="numeric"){if(!Array.isArray(_))throw new Error(`Argument ${De} passed to ${Fe} must be a \`Tensor[]\` or \`TensorLike[]\``);return _.map((ht,Vt)=>xe(ht,`${De}[${Vt}]`,Fe,Ke))}},6154:function(Wt,dt,L){"use strict";L.d(dt,{$F:()=>xe,Oq:()=>we,x8:()=>pe,z4:()=>ee});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var p;(function(K){K.R0="R0",K.R1="R1",K.R2="R2",K.R3="R3",K.R4="R4",K.R5="R5",K.R6="R6"})(p||(p={}));var ze;(function(K){K.float32="float32",K.int32="int32",K.bool="int32",K.complex64="complex64"})(ze||(ze={}));var Z;(function(K){K.float32="float32",K.int32="int32",K.bool="bool",K.complex64="complex64"})(Z||(Z={}));var ie;(function(K){K.float32="float32",K.int32="float32",K.bool="float32",K.complex64="complex64"})(ie||(ie={}));var P;(function(K){K.float32="complex64",K.int32="complex64",K.bool="complex64",K.complex64="complex64"})(P||(P={}));const W={float32:ie,int32:ze,bool:Z,complex64:P};function pe(K,_){if(K==="string"||_==="string"){if(K==="string"&&_==="string")return"string";throw new Error(`Can not upcast ${K} with ${_}`)}return W[K][_]}function ee(K){return pe(K,"int32")}function we(K){return K!=null&&typeof K=="object"&&"texture"in K&&K.texture instanceof WebGLTexture}function xe(K){return typeof GPUBuffer<"u"&&K!=null&&typeof K=="object"&&"buffer"in K&&K.buffer instanceof GPUBuffer}},2891:function(Wt,dt,L){"use strict";L.r(dt),L.d(dt,{hexToLong:()=>pe,decodeString:()=>at,arraysEqualWithNull:()=>Z.DK,createShuffledIndices:()=>Z.U$,squeezeShape:()=>Z.bp,locToIndex:()=>Z.qy,distSquared:()=>Z.E7,nearestLargerEven:()=>Z.nY,getTypedArrayFromDType:()=>Z.WP,shuffleCombo:()=>Z.d7,createScalarValue:()=>Qe,bytesFromStringArray:()=>Z.Ub,shuffle:()=>Z.TV,assert:()=>Z.hu,inferFromImplicitShape:()=>Z.JZ,toTypedArray:()=>re,isTypedArray:()=>S,randUniform:()=>Z.bj,convertBackendValuesAndArrayBuffer:()=>Z.KS,indexToLoc:()=>Z.NE,assertShapesMatch:()=>Z.k5,sum:()=>Z.Sm,parseAxisParam:()=>Z.EC,isBoolean:()=>Z.jn,sizeToSquarishShape:()=>Z.YP,clamp:()=>Z.uZ,isValidDtype:()=>Z.LP,toNestedArray:()=>Z.GX,getArrayFromDType:()=>Z.rQ,fingerPrint64:()=>y,makeOnesTypedArray:()=>Z.p8,repeatedTry:()=>Z.WD,swap:()=>Z.LF,isFunction:()=>Z.mf,isPromise:()=>Z.tI,isNumber:()=>Z.hj,assertNonNegativeIntegerDimensions:()=>Z.Mu,isInt:()=>Z.GN,encodeString:()=>Be,tanh:()=>Z.AE,nearestDivisor:()=>Z.jP,fetch:()=>Re,isString:()=>Z.HD,makeZerosNestedTypedArray:()=>Z.l6,rightPad:()=>Z.oj,bytesPerElement:()=>Z.bT,makeZerosTypedArray:()=>Z.wT,sizeFromShape:()=>Z.NA,computeStrides:()=>Z.e3,hasEncodingLoss:()=>Z.QB,inferDtype:()=>Z.D2,now:()=>G,isScalarShape:()=>Z.xH,assertNonNull:()=>Z.Cq,checkConversionForErrors:()=>Z.D5,flatten:()=>nt,arraysEqual:()=>Z.cO});var p=L(6650),ze=L(5830),Z=L(9024),ie=L(6821),P=L.n(ie);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W=P()||ie;function pe(ne){return W.fromString(ne,!0,16)}const ee=pe("c3a5c85c97cb3127"),we=pe("b492b66fbe98f273"),xe=pe("9ae16a3b2f90404f");function K(ne){return ne.xor(ne.shru(47))}function _(ne,Ne,Ve){const ce=ne.slice(Ne,Ne+Ve);return W.fromBytes(Array.from(ce),!0,!0)}function De(ne,Ne){return _(ne,Ne,8)}function Fe(ne,Ne){return _(ne,Ne,4)}function Ke(ne,Ne){return Ne===0?ne:ne.shru(Ne).or(ne.shl(64-Ne))}function rt(ne,Ne,Ve=pe("9ddfea08eb382d69")){let ce=ne.xor(Ne).mul(Ve);ce=ce.xor(ce.shru(47));let me=Ne.xor(ce).mul(Ve);return me=me.xor(me.shru(47)),me=me.mul(Ve),me}function ht(ne,Ne,Ve,ce,me,pt){me=me.add(ne),pt=Ke(pt.add(me).add(ce),21);const ct=me;return me=me.add(Ne),me=me.add(Ve),pt=pt.add(Ke(me,44)),[me.add(ce),pt.add(ct)]}function Vt(ne,Ne,Ve,ce){return ht(De(ne,Ne),De(ne,Ne+8),De(ne,Ne+16),De(ne,Ne+24),Ve,ce)}function on(ne,Ne=ne.length){if(Ne>=8){const Ve=xe.add(Ne*2),ce=De(ne,0).add(xe),me=De(ne,Ne-8),pt=Ke(me,37).mul(Ve).add(ce),ct=Ke(ce,25).add(me).mul(Ve);return rt(pt,ct,Ve)}if(Ne>=4){const Ve=xe.add(Ne*2),ce=Fe(ne,0);return rt(ce.shl(3).add(Ne),Fe(ne,Ne-4),Ve)}if(Ne>0){const Ve=ne[0],ce=ne[Ne>>1],me=ne[Ne-1],pt=Ve+(ce<<8),ct=Ne+(me<<2);return K(xe.mul(pt).xor(ee.mul(ct))).mul(xe)}return xe}function $t(ne,Ne=ne.length){const Ve=xe.add(Ne*2),ce=De(ne,0).mul(we),me=De(ne,8),pt=De(ne,Ne-8).mul(Ve),ct=De(ne,Ne-16).mul(xe);return rt(Ke(ce.add(me),43).add(Ke(pt,30)).add(ct),ce.add(Ke(me.add(xe),18)).add(pt),Ve)}function ve(ne,Ne=ne.length){const Ve=xe.add(Ne*2),ce=De(ne,0).mul(xe),me=De(ne,8),pt=De(ne,Ne-8).mul(Ve),ct=De(ne,Ne-16).mul(xe),Lt=Ke(ce.add(me),43).add(Ke(pt,30)).add(ct),Nt=rt(Lt,ce.add(Ke(me.add(xe),18)).add(pt),Ve),ln=De(ne,16).mul(Ve),Sn=De(ne,24),tn=Lt.add(De(ne,Ne-32)).mul(Ve),kn=Nt.add(De(ne,Ne-24)).mul(Ve);return rt(Ke(ln.add(Sn),43).add(Ke(tn,30)).add(kn),ln.add(Ke(Sn.add(ce),18)).add(tn),Ve)}function y(ne,Ne=ne.length){const Ve=W.fromNumber(81,!0);if(Ne<=32)return Ne<=16?on(ne,Ne):$t(ne,Ne);if(Ne<=64)return ve(ne,Ne);let ce=Ve,me=Ve.mul(we).add(113),pt=K(me.mul(xe).add(113)).mul(xe),ct=[W.UZERO,W.UZERO],Lt=[W.UZERO,W.UZERO];ce=ce.mul(xe).add(De(ne,0));let Nt=0;const ln=(Ne-1>>6)*64,Sn=ln+(Ne-1&63)-63;do ce=Ke(ce.add(me).add(ct[0]).add(De(ne,Nt+8)),37).mul(we),me=Ke(me.add(ct[1]).add(De(ne,Nt+48)),42).mul(we),ce=ce.xor(Lt[1]),me=me.add(ct[0]).add(De(ne,Nt+40)),pt=Ke(pt.add(Lt[0]),33).mul(we),ct=Vt(ne,Nt,ct[1].mul(we),ce.add(Lt[0])),Lt=Vt(ne,Nt+32,pt.add(Lt[1]),me.add(De(ne,Nt+16))),[pt,ce]=[ce,pt],Nt+=64;while(Nt!==ln);const tn=we.add(pt.and(255).shl(1));return Nt=Sn,Lt[0]=Lt[0].add(Ne-1&63),ct[0]=ct[0].add(Lt[0]),Lt[0]=Lt[0].add(ct[0]),ce=Ke(ce.add(me).add(ct[0]).add(De(ne,Nt+8)),37).mul(tn),me=Ke(me.add(ct[1]).add(De(ne,Nt+48)),42).mul(tn),ce=ce.xor(Lt[1].mul(9)),me=me.add(ct[0].mul(9).add(De(ne,Nt+40))),pt=Ke(pt.add(Lt[0]),33).mul(tn),ct=Vt(ne,Nt,ct[1].mul(tn),ce.add(Lt[0])),Lt=Vt(ne,Nt+32,pt.add(Lt[1]),me.add(De(ne,Nt+16))),[pt,ce]=[ce,pt],rt(rt(ct[0],Lt[0],tn).add(K(me).mul(ee)).add(pt),rt(ct[1],Lt[1],tn).add(ce),tn)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qe(ne,Ne){return Ne==="string"?Be(ne):re([ne],Ne)}function V(ne,Ne){return ne instanceof Float32Array&&Ne==="float32"||ne instanceof Int32Array&&Ne==="int32"||ne instanceof Uint8Array&&Ne==="bool"}function re(ne,Ne){if(Ne==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(ne)&&(ne=nt(ne)),(0,p.OB)().getBool("DEBUG")&&Z.D5(ne,Ne),V(ne,Ne))return ne;if(Ne==null||Ne==="float32"||Ne==="complex64")return new Float32Array(ne);if(Ne==="int32")return new Int32Array(ne);if(Ne==="bool"){const Ve=new Uint8Array(ne.length);for(let ce=0;ce<Ve.length;++ce)Math.round(ne[ce])!==0&&(Ve[ce]=1);return Ve}else throw new Error(`Unknown data type ${Ne}`)}function G(){return(0,p.OB)().platform.now()}function Re(ne,Ne){return(0,p.OB)().platform.fetch(ne,Ne)}function Be(ne,Ne="utf-8"){return Ne=Ne||"utf-8",(0,p.OB)().platform.encode(ne,Ne)}function at(ne,Ne="utf-8"){return Ne=Ne||"utf-8",(0,p.OB)().platform.decode(ne,Ne)}function S(ne){return(0,p.OB)().platform.isTypedArray!=null?(0,p.OB)().platform.isTypedArray(ne):(0,ze.j)(ne)}function nt(ne,Ne=[],Ve=!1){if(Ne==null&&(Ne=[]),typeof ne=="boolean"||typeof ne=="number"||typeof ne=="string"||Z.tI(ne)||ne==null||S(ne)&&Ve)Ne.push(ne);else if(Array.isArray(ne)||S(ne))for(let ce=0;ce<ne.length;++ce)nt(ne[ce],Ne,Ve);else{let ce=-1;for(const me of Object.keys(ne))/^([1-9]+[0-9]*|0)$/.test(me)&&(ce=Math.max(ce,Number(me)));for(let me=0;me<=ce;me++)nt(ne[me],Ne,Ve)}return Ne}},9024:function(Wt,dt,L){"use strict";L.d(dt,{AE:()=>ht,Cq:()=>K,D2:()=>ce,D5:()=>Re,DK:()=>Fe,E7:()=>ee,EC:()=>Qe,GN:()=>rt,GX:()=>Nt,HD:()=>ne,JZ:()=>y,KS:()=>ln,LF:()=>P,LP:()=>Be,Mu:()=>bn,NA:()=>_,NE:()=>ps,QB:()=>at,Sm:()=>W,TV:()=>p,U$:()=>on,Ub:()=>nt,WD:()=>ve,WP:()=>re,YP:()=>Vt,bT:()=>S,bj:()=>pe,bp:()=>V,cO:()=>Ke,d7:()=>ze,e3:()=>ct,hj:()=>Ve,hu:()=>we,jP:()=>pt,jn:()=>Ne,k5:()=>xe,l6:()=>kn,mf:()=>me,nY:()=>ie,oj:()=>$t,p8:()=>Sn,qy:()=>nn,rQ:()=>G,tI:()=>Xn,uZ:()=>Z,wT:()=>tn,xH:()=>De});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p(Te){let Je=Te.length,ft=0;for(;Je>0;)ft=Math.random()*Je|0,Je--,P(Te,Je,ft)}function ze(Te,Je){if(Te.length!==Je.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${Te.length}Second array length was ${Je.length}`);let ft=Te.length,Ot=0;for(;ft>0;)Ot=Math.random()*ft|0,ft--,P(Te,ft,Ot),P(Je,ft,Ot)}function Z(Te,Je,ft){return Math.max(Te,Math.min(Je,ft))}function ie(Te){return Te%2===0?Te:Te+1}function P(Te,Je,ft){const Ot=Te[Je];Te[Je]=Te[ft],Te[ft]=Ot}function W(Te){let Je=0;for(let ft=0;ft<Te.length;ft++)Je+=Te[ft];return Je}function pe(Te,Je){const ft=Math.random();return Je*ft+(1-ft)*Te}function ee(Te,Je){let ft=0;for(let Ot=0;Ot<Te.length;Ot++){const cn=Number(Te[Ot])-Number(Je[Ot]);ft+=cn*cn}return ft}function we(Te,Je){if(!Te)throw new Error(typeof Je=="string"?Je:Je())}function xe(Te,Je,ft=""){we(Ke(Te,Je),()=>ft+` Shapes ${Te} and ${Je} must match`)}function K(Te){we(Te!=null,()=>"The input to the tensor constructor must be a non-null value.")}function _(Te){if(Te.length===0)return 1;let Je=Te[0];for(let ft=1;ft<Te.length;ft++)Je*=Te[ft];return Je}function De(Te){return Te.length===0}function Fe(Te,Je){if(Te===Je)return!0;if(Te==null||Je==null||Te.length!==Je.length)return!1;for(let ft=0;ft<Te.length;ft++)if(Te[ft]!==null&&Je[ft]!==null&&Te[ft]!==Je[ft])return!1;return!0}function Ke(Te,Je){if(Te===Je)return!0;if(Te==null||Je==null||Te.length!==Je.length)return!1;for(let ft=0;ft<Te.length;ft++)if(Te[ft]!==Je[ft])return!1;return!0}function rt(Te){return Te%1===0}function ht(Te){if(Math.tanh!=null)return Math.tanh(Te);if(Te===1/0)return 1;if(Te===-1/0)return-1;{const Je=Math.exp(2*Te);return(Je-1)/(Je+1)}}function Vt(Te){const Je=Math.ceil(Math.sqrt(Te));return[Je,Math.ceil(Te/Je)]}function on(Te){const Je=new Uint32Array(Te);for(let ft=0;ft<Te;++ft)Je[ft]=ft;return p(Je),Je}function $t(Te,Je){return Je<=Te.length?Te:Te+" ".repeat(Je-Te.length)}function ve(Te,Je=cn=>0,ft,Ot){return new Promise((cn,Rn)=>{let Un=0;const Kn=()=>{if(Te()){cn();return}Un++;const Us=Je(Un);if(ft!=null&&Un>=ft){Rn();return}Ot!=null?Ot(Kn,Us):setTimeout(Kn,Us)};Kn()})}function y(Te,Je){let ft=1,Ot=-1;for(let Rn=0;Rn<Te.length;++Rn)if(Te[Rn]>=0)ft*=Te[Rn];else if(Te[Rn]===-1){if(Ot!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${Ot} and dim ${Rn}`);Ot=Rn}else if(Te[Rn]<0)throw Error(`Shapes can not be < 0. Found ${Te[Rn]} at dim ${Rn}`);if(Ot===-1){if(Je>0&&Je!==ft)throw Error(`Size(${Je}) must match the product of shape ${Te}`);return Te}if(ft===0)throw Error(`Cannot infer the missing size in [${Te}] when there are 0 elements`);if(Je%ft!==0)throw Error(`The implicit shape can't be a fractional number. Got ${Je} / ${ft}`);const cn=Te.slice();return cn[Ot]=Je/ft,cn}function Qe(Te,Je){const ft=Je.length;return Te=Te==null?Je.map((Ot,cn)=>cn):[].concat(Te),we(Te.every(Ot=>Ot>=-ft&&Ot<ft),()=>`All values in axis param must be in range [-${ft}, ${ft}) but got axis ${Te}`),we(Te.every(Ot=>rt(Ot)),()=>`All values in axis param must be integers but got axis ${Te}`),Te.map(Ot=>Ot<0?ft+Ot:Ot)}function V(Te,Je){const ft=[],Ot=[],cn=Je!=null&&Array.isArray(Je)&&Je.length===0,Rn=Je==null||cn?null:Qe(Je,Te).sort();let Un=0;for(let Kn=0;Kn<Te.length;++Kn){if(Rn!=null){if(Rn[Un]===Kn&&Te[Kn]!==1)throw new Error(`Can't squeeze axis ${Kn} since its dim '${Te[Kn]}' is not 1`);(Rn[Un]==null||Rn[Un]>Kn)&&Te[Kn]===1&&(ft.push(Te[Kn]),Ot.push(Kn)),Rn[Un]<=Kn&&Un++}Te[Kn]!==1&&(ft.push(Te[Kn]),Ot.push(Kn))}return{newShape:ft,keptDims:Ot}}function re(Te,Je){return G(Te,Je)}function G(Te,Je){let ft=null;if(Te==null||Te==="float32")ft=new Float32Array(Je);else if(Te==="int32")ft=new Int32Array(Je);else if(Te==="bool")ft=new Uint8Array(Je);else if(Te==="string")ft=new Array(Je);else throw new Error(`Unknown data type ${Te}`);return ft}function Re(Te,Je){for(let ft=0;ft<Te.length;ft++){const Ot=Te[ft];if(isNaN(Ot)||!isFinite(Ot))throw Error(`A tensor of type ${Je} being uploaded contains ${Ot}.`)}}function Be(Te){return Te==="bool"||Te==="complex64"||Te==="float32"||Te==="int32"||Te==="string"}function at(Te,Je){return!(Je==="complex64"||Je==="float32"&&Te!=="complex64"||Je==="int32"&&Te!=="float32"&&Te!=="complex64"||Je==="bool"&&Te==="bool")}function S(Te){if(Te==="float32"||Te==="int32")return 4;if(Te==="complex64")return 8;if(Te==="bool")return 1;throw new Error(`Unknown dtype ${Te}`)}function nt(Te){if(Te==null)return 0;let Je=0;return Te.forEach(ft=>Je+=ft.length),Je}function ne(Te){return typeof Te=="string"||Te instanceof String}function Ne(Te){return typeof Te=="boolean"}function Ve(Te){return typeof Te=="number"}function ce(Te){return Array.isArray(Te)?ce(Te[0]):Te instanceof Float32Array?"float32":Te instanceof Int32Array||Te instanceof Uint8Array||Te instanceof Uint8ClampedArray?"int32":Ve(Te)?"float32":ne(Te)?"string":Ne(Te)?"bool":"float32"}function me(Te){return!!(Te&&Te.constructor&&Te.call&&Te.apply)}function pt(Te,Je){for(let ft=Je;ft<Te;++ft)if(Te%ft===0)return ft;return Te}function ct(Te){const Je=Te.length;if(Je<2)return[];const ft=new Array(Je-1);ft[Je-2]=Te[Je-1];for(let Ot=Je-3;Ot>=0;--Ot)ft[Ot]=ft[Ot+1]*Te[Ot+1];return ft}function Lt(Te,Je,ft,Ot=!1){const cn=new Array;if(Je.length===1){const Rn=Je[0]*(Ot?2:1);for(let Un=0;Un<Rn;Un++)cn[Un]=ft[Te+Un]}else{const Rn=Je[0],Un=Je.slice(1),Kn=Un.reduce((Us,As)=>Us*As)*(Ot?2:1);for(let Us=0;Us<Rn;Us++)cn[Us]=Lt(Te+Us*Kn,Un,ft,Ot)}return cn}function Nt(Te,Je,ft=!1){if(Te.length===0)return Je[0];const Ot=Te.reduce((cn,Rn)=>cn*Rn)*(ft?2:1);if(Ot===0)return[];if(Ot!==Je.length)throw new Error(`[${Te}] does not match the input size ${Je.length}${ft?" for a complex tensor":""}.`);return Lt(0,Te,Je,ft)}function ln(Te,Je){if(Array.isArray(Te))return Te;if(Je==="float32")return Te instanceof Float32Array?Te:new Float32Array(Te);if(Je==="int32")return Te instanceof Int32Array?Te:new Int32Array(Te);if(Je==="bool"||Je==="string")return Uint8Array.from(new Int32Array(Te));throw new Error(`Unknown dtype ${Je}`)}function Sn(Te,Je){const ft=tn(Te,Je);for(let Ot=0;Ot<ft.length;Ot++)ft[Ot]=1;return ft}function tn(Te,Je){if(Je==null||Je==="float32"||Je==="complex64")return new Float32Array(Te);if(Je==="int32")return new Int32Array(Te);if(Je==="bool")return new Uint8Array(Te);throw new Error(`Unknown data type ${Je}`)}function kn(Te,Je){const ft=Te.reduce((Ot,cn)=>Ot*cn,1);if(Je==null||Je==="float32")return Nt(Te,new Float32Array(ft));if(Je==="int32")return Nt(Te,new Int32Array(ft));if(Je==="bool")return Nt(Te,new Uint8Array(ft));throw new Error(`Unknown data type ${Je}`)}function bn(Te){Te.forEach(Je=>{we(Number.isInteger(Je)&&Je>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${Te}].`)})}function nn(Te,Je,ft){if(Je===0)return 0;if(Je===1)return Te[0];let Ot=Te[Te.length-1];for(let cn=0;cn<Te.length-1;++cn)Ot+=ft[cn]*Te[cn];return Ot}function ps(Te,Je,ft){if(Je===0)return[];if(Je===1)return[Te];const Ot=new Array(Je);for(let cn=0;cn<Ot.length-1;++cn)Ot[cn]=Math.floor(Te/ft[cn]),Te-=Ot[cn]*ft[cn];return Ot[Ot.length-1]=Te,Ot}function Xn(Te){return Te&&Te.then&&typeof Te.then=="function"}},6603:function(Wt,dt,L){"use strict";L.d(dt,{cH:()=>Ag,oV:()=>us});var p={};L.r(p),L.d(p,{json:()=>Lt});var ze={};L.r(ze),L.d(ze,{json:()=>Nt});var Z={};L.r(Z),L.d(Z,{json:()=>ln});var ie={};L.r(ie),L.d(ie,{json:()=>Sn});var P={};L.r(P),L.d(P,{json:()=>tn});var W={};L.r(W),L.d(W,{json:()=>kn});var pe={};L.r(pe),L.d(pe,{json:()=>bn});var ee={};L.r(ee),L.d(ee,{json:()=>nn});var we={};L.r(we),L.d(we,{json:()=>ps});var xe={};L.r(xe),L.d(xe,{json:()=>Xn});var K={};L.r(K),L.d(K,{json:()=>Te});var _={};L.r(_),L.d(_,{json:()=>Je});var De={};L.r(De),L.d(De,{json:()=>ft});var Fe={};L.r(Fe),L.d(Fe,{json:()=>Ot});var Ke={};L.r(Ke),L.d(Ke,{json:()=>cn});var rt={};L.r(rt),L.d(rt,{json:()=>Rn});var ht={};L.r(ht),L.d(ht,{json:()=>Un});var Vt={};L.r(Vt),L.d(Vt,{json:()=>Kn});var on={};L.r(on),L.d(on,{json:()=>Us});var $t={};L.r($t),L.d($t,{OP_SCOPE_SUFFIX:()=>le.zvA,abs:()=>le.WnP,acos:()=>le.Khb,acosh:()=>le.__u,add:()=>le.IHx,addN:()=>le.QBD,all:()=>le.$6P,any:()=>le.YjB,argMax:()=>le.NqF,argMin:()=>le.vHJ,asin:()=>le.ZRM,asinh:()=>le.VfV,atan:()=>le.z4N,atan2:()=>le.fvJ,atanh:()=>le.C80,avgPool:()=>le.wS1,avgPool3d:()=>le.uR5,basicLSTMCell:()=>le.zEQ,batchNorm:()=>le.tgs,batchNorm2d:()=>le.Dxk,batchNorm3d:()=>le.JY5,batchNorm4d:()=>le.p3b,batchToSpaceND:()=>le.E4h,bincount:()=>le.yE8,bitwiseAnd:()=>le.ycw,booleanMaskAsync:()=>le.anm,broadcastArgs:()=>le.XsQ,broadcastTo:()=>le.UFq,buffer:()=>le.f3b,cast:()=>le.pju,ceil:()=>le.mDi,clipByValue:()=>le.iUl,clone:()=>le.d9v,complex:()=>le.PYB,concat:()=>le.zoF,concat1d:()=>le.gME,concat2d:()=>le.Izb,concat3d:()=>le.MNy,concat4d:()=>le.ZaL,conv1d:()=>le.PAt,conv2d:()=>le.Tek,conv2dTranspose:()=>le.bc,conv3d:()=>le.pdZ,conv3dTranspose:()=>le.$QV,cos:()=>le.mCk,cosh:()=>le.f9Y,cosineWindow:()=>le.mew,cumprod:()=>le.$Gn,cumsum:()=>le.zbp,denseBincount:()=>le.ppE,depthToSpace:()=>le.nTT,depthwiseConv2d:()=>le.B10,diag:()=>le.Ka3,dilation2d:()=>le.WmZ,div:()=>le.hiC,divNoNan:()=>le.NTj,dot:()=>le.AKD,dropout:()=>le.rvX,einsum:()=>le.WYO,elu:()=>le.pyx,enclosingPowerOfTwo:()=>le.GRh,ensureShape:()=>le.EDe,equal:()=>le.DgJ,erf:()=>le.qNN,euclideanNorm:()=>le.d2q,exp:()=>le.Qqt,expandDims:()=>le.dt4,expm1:()=>le.t$B,eye:()=>le.iyy,fft:()=>le.kp_,fill:()=>le.hlL,floor:()=>le.GWj,floorDiv:()=>le.qPi,fused:()=>le.imm,gather:()=>le.Iqj,gatherND:()=>le.dbB,greater:()=>le.pjt,greaterEqual:()=>le.brS,ifft:()=>le.Sxn,imag:()=>le.asL,image:()=>le.BHj,inTopKAsync:()=>le.V3u,irfft:()=>le.wx0,isFinite:()=>le.xVT,isInf:()=>le.UWc,isNaN:()=>le.i2d,leakyRelu:()=>le.hi7,less:()=>le.d9m,lessEqual:()=>le.zN1,linalg:()=>le.$r2,linspace:()=>le.SX3,localResponseNormalization:()=>le.G9k,log:()=>le.cM7,log1p:()=>le.Krr,logSigmoid:()=>le.e_t,logSoftmax:()=>le.CmS,logSumExp:()=>le.l_t,logicalAnd:()=>le.HvI,logicalNot:()=>le.hJK,logicalOr:()=>le.K5V,logicalXor:()=>le.egP,losses:()=>le.MB5,lowerBound:()=>le.eab,matMul:()=>le.OI3,max:()=>le.Fp7,maxPool:()=>le._sB,maxPool3d:()=>le.YQQ,maxPoolWithArgmax:()=>le.Ip$,maximum:()=>le.gWQ,mean:()=>le.J69,meshgrid:()=>le.ry_,min:()=>le.VV$,minimum:()=>le.LTh,mirrorPad:()=>le.VdP,mod:()=>le.wQq,moments:()=>le.Gi7,movingAverage:()=>le.p_,mul:()=>le.dC7,multiRNNCell:()=>le.rq4,multinomial:()=>le.SJ_,neg:()=>le.W76,norm:()=>le.KOy,notEqual:()=>le.Quu,oneHot:()=>le.lfX,ones:()=>le.iUs,onesLike:()=>le.JpU,op:()=>le.op,outerProduct:()=>le.N2O,pad:()=>le.vku,pad1d:()=>le.pNR,pad2d:()=>le.koy,pad3d:()=>le.t1L,pad4d:()=>le.lGY,pool:()=>le.d_R,pow:()=>le.sQ3,prelu:()=>le.AL3,print:()=>le.S0v,prod:()=>le.WVs,raggedGather:()=>le.$gW,raggedRange:()=>le.VT$,raggedTensorToTensor:()=>le.N89,rand:()=>le.TN_,randomGamma:()=>le.wzB,randomNormal:()=>le.nGf,randomStandardNormal:()=>le.ruB,randomUniform:()=>le.LGj,randomUniformInt:()=>le.pe5,range:()=>le.w6H,real:()=>le.kwC,reciprocal:()=>le.M25,relu:()=>le.UYe,relu6:()=>le.btT,reshape:()=>le.XLQ,reverse:()=>le.GYS,reverse1d:()=>le.SDf,reverse2d:()=>le.diP,reverse3d:()=>le.sx7,reverse4d:()=>le.mG2,rfft:()=>le.QEs,round:()=>le.NMM,rsqrt:()=>le.bp0,scalar:()=>le.iD$,scatterND:()=>le.snQ,searchSorted:()=>le.zcT,selu:()=>le.U8D,separableConv2d:()=>le.U_I,setdiff1dAsync:()=>le.ODp,sigmoid:()=>le.XD2,sign:()=>le.Xxe,signal:()=>le.tdS,sin:()=>le.O$l,sinh:()=>le.R_K,slice:()=>le.tPi,slice1d:()=>le.jZU,slice2d:()=>le.SmN,slice3d:()=>le.CnO,slice4d:()=>le.p0P,softmax:()=>le.XAC,softplus:()=>le.Wvh,spaceToBatchND:()=>le.fBT,sparse:()=>le.rVs,sparseToDense:()=>le.ers,spectral:()=>le.uN7,split:()=>le.Vl2,sqrt:()=>le._b3,square:()=>le.h62,squaredDifference:()=>le.$i,squeeze:()=>le.L9e,stack:()=>le.knu,step:()=>le.Nbs,stridedSlice:()=>le.NXj,string:()=>le.Z_8,sub:()=>le.luU,sum:()=>le.Smz,tan:()=>le.ORZ,tanh:()=>le.AEp,tensor:()=>le.XeE,tensor1d:()=>le.RRF,tensor2d:()=>le.odF,tensor3d:()=>le.wOQ,tensor4d:()=>le.yXz,tensor5d:()=>le.Bfx,tensor6d:()=>le.xZs,tensorScatterUpdate:()=>le.Pg0,tile:()=>le.Gg6,topk:()=>le.hg7,transpose:()=>le.p4s,truncatedNormal:()=>le.Xu6,unique:()=>le.Two,unsortedSegmentSum:()=>le.pUJ,unstack:()=>le.HHK,upperBound:()=>le.GaM,variable:()=>le.VD$,where:()=>le.arb,whereAsync:()=>le.itS,zeros:()=>le.lls,zerosLike:()=>le.P84});var ve=L(1734),y=L(9677);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,y.OBj)().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var V;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(V||(V={}));var re;(function(n){let e;(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e=n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(re||(re={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G={};function Re(n,e){const t={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:e};G[n]=t}function Be(n){return G[n]}function at(n){delete G[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S(n,e,t,s,a){const u=e.inputParams[n];if(u&&u.inputIndexStart!==void 0){const m=u.inputIndexStart,b=u.inputIndexEnd===0?void 0:u.inputIndexEnd===void 0?m+1:u.inputIndexEnd,T=m<0?e.inputNames.length+m:m;if(u.type==="tensor")return nt(e.inputNames[T],t,s,a);if(u.type==="tensors"){const B=e.inputs.slice(m,b);return e.inputNames.slice(m,b).filter((oe,ue)=>{var he;return((he=B[ue])===null||he===void 0?void 0:he.op)!=="NoOp"}).map(oe=>nt(oe,t,s,a))}const k=nt(e.inputNames[T],t,s,a),R=k.dataSync();return u.type==="number"?R[0]:y.D5U.toNestedArray(k.shape,R)}const d=e.attrParams[n];return d&&d.value}function nt(n,e,t,s){const[a,u]=ce(n,t);if(s!=null){const m=s.getHashTableHandleByName(a);if(m!=null)return m}const d=t.currentContextIds.find(m=>!!e[Ve(a,m)]);return d!==void 0?e[Ve(a,d)][u]:void 0}function ne(n,e,t){return e[Ve(n,t.currentContextId)]}function Ne(n,e){const[t,s,a]=ce(n,e);return[Ve(t,e&&e.currentContextId),s,a]}function Ve(n,e){return e?`${n}-${e}`:n}function ce(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const u=e.parseNodeNameCache.get(n);if(u!=null)return u}const s=n.split(":");let a;if(s.length===1)a=[n,0,void 0];else{const u=s[0],d=s.length===3?s[1]:void 0,m=Number(s[s.length-1]);a=[u,m,d]}return t&&e.parseNodeNameCache.set(n,a),a}function me(n,e){const t=[];for(let s=0;s<n.length;s+=e)t.push(n.slice(s,s+e));return t}function pt(n,e,t){let s=S("pad",n,e,t);if(s==="explicit"){s=S("explicitPaddings",n,e,t);const a=[[0,0],[0,0],[0,0],[0,0]];for(let u=0;u<4;u++)a[u][0]=s[u*2],a[u][1]=s[u*2+1];return a}return s}function ct(n){return n.kept?n:(0,y.d9v)(n)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lt=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nt=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ln=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sn=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tn=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kn=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bn=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nn=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ps=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xn=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Te=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}];/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Je=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}];/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ft=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}];/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ot=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cn=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rn=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Un=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kn=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Us=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class As{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[p,ze,Z,ie,P,W,pe,ee,we,xe,K,_,De,Fe,Ke,rt,ht,Vt,on],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,a)=>(s[a.tfOpName]=a,s),{})}transformGraph(e,t={}){const s=e.node,a=[],u=[],d=[],m=s.reduce((ue,he)=>(ue[he.name]=this.mapNode(he),he.op.startsWith("Placeholder")?a.push(ue[he.name]):he.op==="Const"?u.push(ue[he.name]):(he.input==null||he.input.length===0)&&d.push(ue[he.name]),ue),{});let b=[];const T=[];let k={},R={};t!=null&&(k=this.mapSignatureEntries(t.inputs),R=this.mapSignatureEntries(t.outputs));const B=Object.keys(m);B.forEach(ue=>{const he=m[ue];he.inputNames.forEach((Ue,Xe)=>{const[ot,,it]=Ne(Ue),mt=m[ot];if(mt.outputs!=null){const wt=mt.outputs.indexOf(it);if(wt!==-1){const St=`${ot}:${wt}`;he.inputNames[Xe]=St}}he.inputs.push(mt),mt.children.push(he)})}),Object.keys(R).length===0?B.forEach(ue=>{const he=m[ue];he.children.length===0&&T.push(he)}):Object.keys(R).forEach(ue=>{const[he]=Ne(ue),Ue=m[he];Ue!=null&&(Ue.signatureKey=R[ue],T.push(Ue))}),Object.keys(k).length>0?Object.keys(k).forEach(ue=>{const[he]=Ne(ue),Ue=m[he];Ue&&(Ue.signatureKey=k[ue],b.push(Ue))}):b=a;let X={};e.library!=null&&e.library.function!=null&&(X=e.library.function.reduce((ue,he)=>(ue[he.signature.name]=this.mapFunction(he),ue),{}));const oe={nodes:m,inputs:b,outputs:T,weights:u,placeholders:a,signature:t,functions:X};return d.length>0&&(oe.initNodes=d),oe}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=Be(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(a=>a.startsWith("^")?a.slice(1):a),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((a,u)=>(a[u.name]={type:u.type,inputIndexStart:u.start,inputIndexEnd:u.end},a),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((a,u)=>{const d=u.type;let m;switch(u.type){case"string":m=Ns(e.attr,u.tfName,u.defaultValue),m===void 0&&u.tfDeprecatedName&&(m=Ns(e.attr,u.tfDeprecatedName,u.defaultValue));break;case"string[]":m=wr(e.attr,u.tfName,u.defaultValue),m===void 0&&u.tfDeprecatedName&&(m=wr(e.attr,u.tfDeprecatedName,u.defaultValue));break;case"number":m=Ys(e.attr,u.tfName,u.defaultValue||0),m===void 0&&u.tfDeprecatedName&&(m=Ys(e.attr,u.tfDeprecatedName,u.defaultValue));break;case"number[]":m=br(e.attr,u.tfName,u.defaultValue),m===void 0&&u.tfDeprecatedName&&(m=br(e.attr,u.tfDeprecatedName,u.defaultValue));break;case"bool":m=Jr(e.attr,u.tfName,u.defaultValue),m===void 0&&u.tfDeprecatedName&&(m=Jr(e.attr,u.tfDeprecatedName,u.defaultValue));break;case"bool[]":m=pr(e.attr,u.tfName,u.defaultValue),m===void 0&&u.tfDeprecatedName&&(m=pr(e.attr,u.tfDeprecatedName,u.defaultValue));break;case"shape":m=hr(e.attr,u.tfName,u.defaultValue),m===void 0&&u.tfDeprecatedName&&(m=hr(e.attr,u.tfDeprecatedName,u.defaultValue));break;case"shape[]":m=Ps(e.attr,u.tfName,u.defaultValue),m===void 0&&u.tfDeprecatedName&&(m=Ps(e.attr,u.tfDeprecatedName,u.defaultValue));break;case"dtype":m=to(e.attr,u.tfName,u.defaultValue),m===void 0&&u.tfDeprecatedName&&(m=to(e.attr,u.tfDeprecatedName,u.defaultValue));break;case"dtype[]":m=ks(e.attr,u.tfName,u.defaultValue),m===void 0&&u.tfDeprecatedName&&(m=ks(e.attr,u.tfDeprecatedName,u.defaultValue));break;case"func":m=bo(e.attr,u.tfName,u.defaultValue),m===void 0&&u.tfDeprecatedName&&(m=bo(e.attr,u.tfDeprecatedName,u.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${u.type} for op: ${e.op}`)}return a[u.name]={value:m,type:d},a},{})),s}mapFunction(e){const t=e.nodeDef,s=[],a=[];let u={};t!=null&&(u=t.reduce((R,B)=>(R[B.name]=this.mapNode(B),B.op==="Const"&&a.push(R[B.name]),R),{}));const d=[],m=[];e.signature.inputArg.forEach(R=>{const[B]=Ne(R.name),X={name:B,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:eo(R.type),type:"dtype"}},children:[]};X.signatureKey=R.name,d.push(X),u[B]=X}),Object.keys(u).forEach(R=>{const B=u[R];B.inputNames.forEach((X,oe)=>{const[ue,,he]=Ne(X),Ue=u[ue];if(Ue.outputs!=null){const Xe=Ue.outputs.indexOf(he);if(Xe!==-1){const ot=`${ue}:${Xe}`;B.inputNames[oe]=ot}}B.inputs.push(Ue),Ue.children.push(B)})});const T=e.ret;e.signature.outputArg.forEach(R=>{const[B,X]=Ne(T[R.name]),oe=u[B];oe!=null&&(oe.defaultOutput=X,m.push(oe))});const k=this.mapArgsToSignature(e);return{nodes:u,inputs:d,outputs:m,weights:a,placeholders:s,signature:k}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function _r(n){const e=(0,y.OBj)().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function Ar(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):_r(n);return e?t:t.toLowerCase()}function Ns(n,e,t,s=!1){const a=n[e];return a!=null?Ar(a.s,s):t}function Jr(n,e,t){const s=n[e];return s?s.b:t}function Ys(n,e,t){const s=n[e]||{},a=s.i!=null?s.i:s.f!=null?s.f:t;return typeof a=="number"?a:parseInt(a,10)}function eo(n){switch(typeof n=="string"&&(n=V[n]),n){case V.DT_FLOAT:case V.DT_HALF:return"float32";case V.DT_INT32:case V.DT_INT64:case V.DT_INT8:case V.DT_UINT8:return"int32";case V.DT_BOOL:return"bool";case V.DT_DOUBLE:return"float32";case V.DT_STRING:return"string";case V.DT_COMPLEX64:case V.DT_COMPLEX128:return"complex64";default:return null}}function bo(n,e,t){const s=n[e];return s&&s.func?s.func.name:t}function to(n,e,t){const s=n[e];return s&&s.type?eo(s.type):t}function ks(n,e,t){const s=n[e];return s&&s.list&&s.list.type?s.list.type.map(a=>eo(a)):t}function Gr(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function hr(n,e,t){const s=n[e];return s&&s.shape?Gr(s.shape):t}function br(n,e,t){const s=n[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(a=>typeof a=="number"?a:parseInt(a,10)):t}function wr(n,e,t,s=!1){const a=n[e];return a&&a.list&&a.list.s?a.list.s.map(u=>Ar(u,s)):t}function Ps(n,e,t){const s=n[e];return s&&s.list&&s.list.shape?s.list.shape.map(a=>Gr(a)):t}function pr(n,e,t){const s=n[e];return s&&s.list&&s.list.b?s.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mn{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(a=>this.getInput(a)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((a,u)=>(a[u]=this.getAttr(u),a),{}))}getInput(e){return nt(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return nt(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return Ys(this.node.rawAttrs,e,t);if(s.s!=null)return Ns(this.node.rawAttrs,e,t);if(s.b!=null)return Jr(this.node.rawAttrs,e,t);if(s.shape!=null)return hr(this.node.rawAttrs,e,t);if(s.type!=null)return to(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return br(this.node.rawAttrs,e,t);if(s.list.s!=null)return wr(this.node.rawAttrs,e,t);if(s.list.shape!=null)return Ps(this.node.rawAttrs,e,t);if(s.list.b!=null)return pr(this.node.rawAttrs,e,t);if(s.list.type!=null)return ks(this.node.rawAttrs,e,t)}return t}}var le=L(4337);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dn=(n,e,t,s=$t)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(S("a",n,e,t),S("b",n,e,t))];case"AddN":return[s.addN(S("tensors",n,e,t))];case"FloorMod":case"Mod":return[s.mod(S("a",n,e,t),S("b",n,e,t))];case"Mul":return[s.mul(S("a",n,e,t),S("b",n,e,t))];case"RealDiv":case"Div":return[s.div(S("a",n,e,t),S("b",n,e,t))];case"DivNoNan":return[s.divNoNan(S("a",n,e,t),S("b",n,e,t))];case"FloorDiv":return[s.floorDiv(S("a",n,e,t),S("b",n,e,t))];case"Sub":return[s.sub(S("a",n,e,t),S("b",n,e,t))];case"Minimum":return[s.minimum(S("a",n,e,t),S("b",n,e,t))];case"Maximum":return[s.maximum(S("a",n,e,t),S("b",n,e,t))];case"Pow":return[s.pow(S("a",n,e,t),S("b",n,e,t))];case"SquaredDifference":return[s.squaredDifference(S("a",n,e,t),S("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},wn="arithmetic";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qs=(n,e,t,s=$t)=>{switch(n.op){case"Abs":case"ComplexAbs":return[s.abs(S("x",n,e,t))];case"Acos":return[s.acos(S("x",n,e,t))];case"Acosh":return[s.acosh(S("x",n,e,t))];case"Asin":return[s.asin(S("x",n,e,t))];case"Asinh":return[s.asinh(S("x",n,e,t))];case"Atan":return[s.atan(S("x",n,e,t))];case"Atan2":return[s.atan2(S("x",n,e,t),S("y",n,e,t))];case"Atanh":return[s.atanh(S("x",n,e,t))];case"Ceil":return[s.ceil(S("x",n,e,t))];case"Complex":return[s.complex(S("real",n,e,t),S("imag",n,e,t))];case"Cos":return[s.cos(S("x",n,e,t))];case"Cosh":return[s.cosh(S("x",n,e,t))];case"Elu":return[s.elu(S("x",n,e,t))];case"Erf":return[s.erf(S("x",n,e,t))];case"Exp":return[s.exp(S("x",n,e,t))];case"Expm1":return[s.expm1(S("x",n,e,t))];case"Floor":return[s.floor(S("x",n,e,t))];case"Log":return[s.log(S("x",n,e,t))];case"Log1p":return[s.log1p(S("x",n,e,t))];case"Imag":return[s.imag(S("x",n,e,t))];case"Neg":return[s.neg(S("x",n,e,t))];case"Reciprocal":return[s.reciprocal(S("x",n,e,t))];case"Real":return[s.real(S("x",n,e,t))];case"Relu":return[s.relu(S("x",n,e,t))];case"Round":return[s.round(S("x",n,e,t))];case"Selu":return[s.selu(S("x",n,e,t))];case"Sigmoid":return[s.sigmoid(S("x",n,e,t))];case"Sin":return[s.sin(S("x",n,e,t))];case"Sign":return[s.sign(S("x",n,e,t))];case"Sinh":return[s.sinh(S("x",n,e,t))];case"Softplus":return[s.softplus(S("x",n,e,t))];case"Sqrt":return[s.sqrt(S("x",n,e,t))];case"Square":return[s.square(S("x",n,e,t))];case"Tanh":return[s.tanh(S("x",n,e,t))];case"Tan":return[s.tan(S("x",n,e,t))];case"ClipByValue":return[s.clipByValue(S("x",n,e,t),S("clipValueMin",n,e,t),S("clipValueMax",n,e,t))];case"Relu6":return[s.relu6(S("x",n,e,t))];case"Rsqrt":return[s.rsqrt(nt(n.inputNames[0],e,t))];case"LeakyRelu":return[s.leakyRelu(S("x",n,e,t),S("alpha",n,e,t))];case"Prelu":return[s.prelu(S("x",n,e,t),S("alpha",n,e,t))];case"IsNan":return[s.isNaN(nt(n.inputNames[0],e,t))];case"IsInf":return[s.isInf(nt(n.inputNames[0],e,t))];case"IsFinite":return[s.isFinite(nt(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},ws="basic_math";/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ns(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){y.D5U.assert(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let s=0;s<n.length;s++){const a=n[s],u=e[s];y.D5U.assert(a<0||u<0||a===u,()=>t+` Shapes ${n} and ${e} must match`)}}}function Pr(n){return!(typeof n=="number"||n.some(e=>e<0))}function ls(n,e,t){let s=vr(n,t);const a=!Pr(s);if(a&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(a&&e.forEach(u=>{s=vr(u.shape,s)}),!Pr(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function vr(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let s=0;s<n.length;++s){const a=n[s],u=e[s];if(a>=0&&u>=0&&a!==u)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[s]=a>=0?a:u}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Or{constructor(e,t,s,a,u,d,m){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=a,this.identicalElementShapes=u,this.dynamicSize=d,this.clearAfterRead=m,this.tensors=[],this.closed_=!1,this.idTensor=(0,y.iD$)(0),(0,y.CnY)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),ns(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,(0,y.CnY)(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,a)=>this.write(s,t[a]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let a=0;a<this.size();a++)e.push(a)}if(e.length===0)return(0,y.XeE)([],[0].concat(this.elementShape));const s=this.readMany(e);return ns(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),(0,y.knu)(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return(0,y.XeE)([],[0].concat(this.elementShape));const t=[];for(let a=0;a<this.size();a++)t.push(a);const s=this.readMany(t);return ns(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),(0,y.zoF)(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,(0,y.HHK)(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const a=e.map(b=>(s+=b,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const u=s===0?0:t.size/s,d=[];(0,y.lub)(()=>{t=(0,y.XLQ)(t,[1,s,u]);for(let b=0;b<e.length;++b){const k=[0,b===0?0:a[b-1],0],R=[1,e[b],u];d[b]=(0,y.XLQ)((0,y.tPi)(t,k,R),this.elementShape)}return d});const m=[];for(let b=0;b<e.length;b++)m[b]=b;this.writeMany(m,d)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Os{get id(){return this.idTensor.id}constructor(e,t,s,a=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e?.forEach(u=>{if(s!==u.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${u.dtype}`);ns(t,u.shape,"TensorList shape mismatch: "),(0,y.CnY)(u)}),this.idTensor=(0,y.iD$)(0),this.maxNumElements=a,(0,y.CnY)(this.idTensor)}copy(){return new Os([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);ns(e,this.elementShape,"TensorList shape mismatch: ");const a=ls(this.elementShape,this.tensors,e);return(0,y.lub)(()=>{const u=this.tensors.map(d=>(0,y.XLQ)(d,a));return(0,y.knu)(u,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=ls(this.elementShape,this.tensors,e),a=this.tensors.pop();return a.kept=!1,ns(a.shape,e,"TensorList shape mismatch: "),(0,y.XLQ)(a,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(ns(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");(0,y.CnY)(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new Os([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);ns(this.tensors[e].shape,t,"TensorList shape mismatch: ");const a=ls(this.elementShape,this.tensors,t);return(0,y.XLQ)(this.tensors[e],a)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);ns(this.elementShape,t.shape,"TensorList shape mismatch: "),(0,y.CnY)(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);ns(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const a=ls(this.elementShape,this.tensors,s);return e.length===0?(0,y.XeE)([],[0].concat(a)):(0,y.lub)(()=>{const u=e.map(d=>(0,y.XLQ)(this.tensors[d],a));return(0,y.knu)(u,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);ns(this.elementShape,t,"TensorList shape mismatch: ");const s=ls(this.elementShape,this.tensors,t);return this.size()===0?(0,y.XeE)([],[0].concat(s)):(0,y.lub)(()=>{const a=this.tensors.map(u=>(0,y.XLQ)(u,s));return(0,y.zoF)(a,0)})}}function Qs(n,e,t){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const a=n.shape.slice(1);ns(a,e,"TensorList shape mismatch: ");const u=(0,y.HHK)(n);return new Os(u,e,s)}function Jo(n,e,t,s){return new Os([],n,e,s)}function Zs(n,e,t,s){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const a=Math.max(...e);if(s!=null&&s!==-1&&a>=s)throw new Error(`Max index must be < array size (${a}  vs. ${s})`);const u=new Os([],t,n.dtype,s),d=(0,y.HHK)(n,0);return e.forEach((m,b)=>{u.setItem(m,d[b])}),u}function Ms(n,e,t){let s=0;const a=e.map(k=>(s+=k,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);const u=n.shape.slice(1),d=vr(u,t),m=s===0?0:n.size/s,b=(0,y.lub)(()=>{const k=[];n=(0,y.XLQ)(n,[1,s,m]);for(let R=0;R<e.length;++R){const X=[0,R===0?0:a[R-1],0],oe=[1,e[R],m];k[R]=(0,y.XLQ)((0,y.tPi)(n,X,oe),d)}return n.dispose(),k}),T=new Os([],t,n.dtype,e.length);for(let k=0;k<b.length;k++)T.setItem(k,b[k]);return T}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Js=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const s=S("thenBranch",n,e,t),a=S("elseBranch",n,e,t),u=S("cond",n,e,t),d=S("args",n,e,t);return(await u.data())[0]?t.functionMap[s].executeFunctionAsync(d,t.tensorArrayMap,t.tensorListMap):t.functionMap[a].executeFunctionAsync(d,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=S("body",n,e,t),a=S("cond",n,e,t),u=S("args",n,e,t),d=await t.functionMap[a].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap),m=u.map(k=>k.id);let b=await d[0].data();d.forEach(k=>{!k.kept&&m.indexOf(k.id)===-1&&k.dispose()});let T=u;for(;b[0];){const k=T;T=await t.functionMap[s].executeFunctionAsync(T,t.tensorArrayMap,t.tensorListMap);const R=T.map(X=>X.id);k.forEach(X=>{!X.kept&&m.indexOf(X.id)===-1&&R.indexOf(X.id)===-1&&X.dispose()});const B=await t.functionMap[a].executeFunctionAsync(T,t.tensorArrayMap,t.tensorListMap);b=await B[0].data(),B.forEach(X=>{!X.kept&&m.indexOf(X.id)===-1&&R.indexOf(X.id)===-1&&X.dispose()})}return T}case"LoopCond":{const s=S("pred",n,e,t);return[ct(s)]}case"Switch":{const s=S("pred",n,e,t);let a=S("data",n,e,t);return a.kept||(a=ct(a)),(await s.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{const s=n.inputNames.find(a=>nt(a,e,t)!==void 0);if(s){const a=nt(s,e,t);return[ct(a)]}return}case"Enter":{const s=S("frameName",n,e,t),a=S("tensor",n,e,t);return t.enterFrame(s),[ct(a)]}case"Exit":{const s=S("tensor",n,e,t);return t.exitFrame(),[ct(s)]}case"NextIteration":{const s=S("tensor",n,e,t);return t.nextIteration(),[ct(s)]}case"TensorArrayV3":{const s=S("size",n,e,t),a=S("dtype",n,e,t),u=S("elementShape",n,e,t),d=S("dynamicSize",n,e,t),m=S("clearAfterRead",n,e,t),b=S("identicalElementShapes",n,e,t),T=S("name",n,e,t),k=new Or(T,a,s,u,b,d,m);return t.addTensorArray(k),[k.idTensor,(0,y.iD$)(1)]}case"TensorArrayWriteV3":{const s=S("tensorArrayId",n,e,t),a=S("index",n,e,t),u=S("tensor",n,e,t),d=t.getTensorArray(s.id);return d.write(a,u),[d.idTensor]}case"TensorArrayReadV3":{const s=S("tensorArrayId",n,e,t),a=S("index",n,e,t);return[t.getTensorArray(s.id).read(a)]}case"TensorArrayGatherV3":{const s=S("tensorArrayId",n,e,t),a=S("indices",n,e,t),u=S("dtype",n,e,t);return[t.getTensorArray(s.id).gather(a,u)]}case"TensorArrayScatterV3":{const s=S("tensorArrayId",n,e,t),a=S("indices",n,e,t),u=S("tensor",n,e,t),d=t.getTensorArray(s.id);return d.scatter(a,u),[d.idTensor]}case"TensorArrayConcatV3":{const s=S("tensorArrayId",n,e,t),a=t.getTensorArray(s.id),u=S("dtype",n,e,t);return[a.concat(u)]}case"TensorArraySplitV3":{const s=S("tensorArrayId",n,e,t),a=S("tensor",n,e,t),u=S("lengths",n,e,t),d=t.getTensorArray(s.id);return d.split(u,a),[d.idTensor]}case"TensorArraySizeV3":{const s=S("tensorArrayId",n,e,t),a=t.getTensorArray(s.id);return[(0,y.iD$)(a.size(),"int32")]}case"TensorArrayCloseV3":{const s=S("tensorArrayId",n,e,t),a=t.getTensorArray(s.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{const s=S("tensorListId",n,e,t),a=S("index",n,e,t),u=S("tensor",n,e,t),d=t.getTensorList(s.id);return d.setItem(a,u),[d.idTensor]}case"TensorListGetItem":{const s=S("tensorListId",n,e,t),a=S("index",n,e,t),u=S("elementShape",n,e,t),d=S("elementDType",n,e,t);return[t.getTensorList(s.id).getItem(a,u,d)]}case"TensorListScatterV2":case"TensorListScatter":{const s=S("indices",n,e,t),a=S("tensor",n,e,t),u=S("elementShape",n,e,t),d=S("numElements",n,e,t),m=Zs(a,s,u,d);return t.addTensorList(m),[m.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=S("elementShape",n,e,t),a=S("elementDType",n,e,t);let u;n.op==="TensorListReserve"?u="numElements":u="maxNumElements";const d=S(u,n,e,t),m=n.op==="TensorListReserve"?-1:d,b=Jo(s,a,d,m);return t.addTensorList(b),[b.idTensor]}case"TensorListGather":{const s=S("tensorListId",n,e,t),a=S("indices",n,e,t),u=S("elementShape",n,e,t),d=S("elementDType",n,e,t);return[t.getTensorList(s.id).gather(a,d,u)]}case"TensorListStack":{const s=S("tensorListId",n,e,t),a=S("elementShape",n,e,t),u=S("elementDType",n,e,t),d=S("numElements",n,e,t);return[t.getTensorList(s.id).stack(a,u,d)]}case"TensorListFromTensor":{const s=S("tensor",n,e,t),a=S("elementShape",n,e,t),u=S("elementDType",n,e,t),d=Qs(s,a,u);return t.addTensorList(d),[d.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=S("tensorListId",n,e,t),a=t.getTensorList(s.id),u=S("dtype",n,e,t),d=S("elementShape",n,e,t);return[a.concat(u,d)]}case"TensorListPushBack":{const s=S("tensorListId",n,e,t),a=S("tensor",n,e,t),u=t.getTensorList(s.id);return u.pushBack(a),[u.idTensor]}case"TensorListPopBack":{const s=S("tensorListId",n,e,t),a=S("elementShape",n,e,t),u=S("elementDType",n,e,t);return[t.getTensorList(s.id).popBack(a,u)]}case"TensorListSplit":{const s=S("tensor",n,e,t),a=S("elementShape",n,e,t),u=S("lengths",n,e,t),d=Ms(s,u,a);return t.addTensorList(d),[d.idTensor]}case"TensorListLength":{const s=S("tensorListId",n,e,t),a=t.getTensorList(s.id);return[(0,y.iD$)(a.size(),"int32")]}case"TensorListResize":{const s=S("tensorListId",n,e,t),a=S("size",n,e,t),d=t.getTensorList(s.id).resize(a);return t.addTensorList(d),[d.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},Fr="control";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hr(n,e,t){const[s,a]=S("fusedOps",n,e,t),u=s==="biasadd",d=!u,m=a==="prelu",b=s==="fusedbatchnorm",T=S("numArgs",n,e,t);if(u){if(m&&T!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!m&&u&&T!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(b)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const k=S("strides",n,e,t),R=pt(n,e,t),B=S("dataFormat",n,e,t).toUpperCase(),X=S("dilations",n,e,t);let[oe,ue]=S("args",n,e,t);d&&(ue=oe,oe=void 0);const he=S("leakyreluAlpha",n,e,t);return{stride:k,pad:R,dataFormat:B,dilations:X,biasArg:oe,preluArg:ue,activationFunc:a,leakyreluAlpha:he}}const Zn=(n,e,t,s=$t)=>{switch(n.op){case"Conv1D":{const a=S("stride",n,e,t),u=S("pad",n,e,t),d=S("dataFormat",n,e,t).toUpperCase(),m=S("dilation",n,e,t);return[s.conv1d(S("x",n,e,t),S("filter",n,e,t),a,u,d,m)]}case"Conv2D":{const a=S("strides",n,e,t),u=pt(n,e,t),d=S("dataFormat",n,e,t).toUpperCase(),m=S("dilations",n,e,t);return[s.conv2d(S("x",n,e,t),S("filter",n,e,t),[a[1],a[2]],u,d,[m[1],m[2]])]}case"_FusedConv2D":{const{stride:a,pad:u,dataFormat:d,dilations:m,biasArg:b,preluArg:T,activationFunc:k,leakyreluAlpha:R}=Hr(n,e,t);return[s.fused.conv2d({x:S("x",n,e,t),filter:S("filter",n,e,t),strides:[a[1],a[2]],pad:u,dataFormat:d,dilations:[m[1],m[2]],bias:b,activation:k,preluActivationWeights:T,leakyreluAlpha:R})]}case"FusedDepthwiseConv2dNative":{const{stride:a,pad:u,dataFormat:d,dilations:m,biasArg:b,preluArg:T,activationFunc:k,leakyreluAlpha:R}=Hr(n,e,t);return[s.fused.depthwiseConv2d({x:S("x",n,e,t),filter:S("filter",n,e,t),strides:[a[1],a[2]],pad:u,dataFormat:d,dilations:[m[1],m[2]],bias:b,activation:k,preluActivationWeights:T,leakyreluAlpha:R})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const a=S("outputShape",n,e,t),u=S("strides",n,e,t),d=pt(n,e,t);return[s.conv2dTranspose(S("x",n,e,t),S("filter",n,e,t),a,[u[1],u[2]],d)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const a=S("strides",n,e,t),u=pt(n,e,t),d=S("dilations",n,e,t),m=S("dataFormat",n,e,t).toUpperCase();return[s.depthwiseConv2d(S("input",n,e,t),S("filter",n,e,t),[a[1],a[2]],u,m,[d[1],d[2]])]}case"Conv3D":{const a=S("strides",n,e,t),u=S("pad",n,e,t),d=S("dataFormat",n,e,t).toUpperCase(),m=S("dilations",n,e,t);return[s.conv3d(S("x",n,e,t),S("filter",n,e,t),[a[1],a[2],a[3]],u,d,[m[1],m[2],m[3]])]}case"AvgPool":{const a=S("strides",n,e,t),u=S("pad",n,e,t),d=S("kernelSize",n,e,t);return[s.avgPool(S("x",n,e,t),[d[1],d[2]],[a[1],a[2]],u)]}case"MaxPool":{const a=S("strides",n,e,t),u=S("pad",n,e,t),d=S("kernelSize",n,e,t);return[s.maxPool(S("x",n,e,t),[d[1],d[2]],[a[1],a[2]],u)]}case"MaxPoolWithArgmax":{const a=S("strides",n,e,t),u=S("pad",n,e,t),d=S("kernelSize",n,e,t),m=S("includeBatchInIndex",n,e,t),{result:b,indexes:T}=s.maxPoolWithArgmax(S("x",n,e,t),[d[1],d[2]],[a[1],a[2]],u,m);return[b,T]}case"AvgPool3D":{const a=S("strides",n,e,t),u=S("pad",n,e,t),d=S("kernelSize",n,e,t);return[s.avgPool3d(S("x",n,e,t),[d[1],d[2],d[3]],[a[1],a[2],a[3]],u)]}case"MaxPool3D":{const a=S("strides",n,e,t),u=S("pad",n,e,t),d=S("kernelSize",n,e,t);return[s.maxPool3d(S("x",n,e,t),[d[1],d[2],d[3]],[a[1],a[2],a[3]],u)]}case"Dilation2D":{const a=S("strides",n,e,t),u=S("pad",n,e,t),d=S("dilations",n,e,t),m=a[1],b=a[2],T=d[1],k=d[2];return[s.dilation2d(S("x",n,e,t),S("filter",n,e,t),[m,b],u,[T,k],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},vs="convolution";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const no=(n,e,t,s=$t)=>{switch(n.op){case"Fill":{const a=S("shape",n,e,t),u=S("dtype",n,e,t),d=S("value",n,e,t);return[s.fill(a,d,u)]}case"LinSpace":{const a=S("start",n,e,t),u=S("stop",n,e,t),d=S("num",n,e,t);return[s.linspace(a,u,d)]}case"Multinomial":{const a=S("logits",n,e,t),u=S("numSamples",n,e,t),d=S("seed",n,e,t);return[s.multinomial(a,u,d)]}case"OneHot":{const a=S("indices",n,e,t),u=S("depth",n,e,t),d=S("onValue",n,e,t),m=S("offValue",n,e,t),b=S("dtype",n,e,t);return[s.oneHot(a,u,d,m,b)]}case"Ones":return[s.ones(S("shape",n,e,t),S("dtype",n,e,t))];case"OnesLike":return[s.onesLike(S("x",n,e,t))];case"RandomStandardNormal":return[s.randomStandardNormal(S("shape",n,e,t),S("dtype",n,e,t),S("seed",n,e,t))];case"RandomUniform":return[s.randomUniform(S("shape",n,e,t),S("minval",n,e,t),S("maxval",n,e,t),S("dtype",n,e,t))];case"RandomUniformInt":return[s.randomUniformInt(S("shape",n,e,t),S("minval",n,e,t),S("maxval",n,e,t),S("seed",n,e,t))];case"Range":{const a=S("start",n,e,t),u=S("stop",n,e,t),d=S("step",n,e,t);return[s.range(a,u,d,S("dtype",n,e,t))]}case"TruncatedNormal":{const a=S("shape",n,e,t),u=S("mean",n,e,t),d=S("stdDev",n,e,t),m=S("seed",n,e,t);return[s.truncatedNormal(a,u,d,S("dtype",n,e,t),m)]}case"Zeros":return[s.zeros(S("shape",n,e,t),S("dtype",n,e,t))];case"ZerosLike":return[s.zerosLike(S("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},Ro="creation";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cr(n,e,t){const s=S("boxes",n,e,t),a=S("scores",n,e,t),u=S("maxOutputSize",n,e,t),d=S("iouThreshold",n,e,t),m=S("scoreThreshold",n,e,t),b=S("softNmsSigma",n,e,t);return{boxes:s,scores:a,maxOutputSize:u,iouThreshold:d,scoreThreshold:m,softNmsSigma:b}}const Cs=async(n,e,t,s,a=$t)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:u,scores:d,maxOutputSize:m,iouThreshold:b,scoreThreshold:T,softNmsSigma:k}=Cr(n,e,t),R=await a.image.nonMaxSuppressionWithScoreAsync(u,d,m,b,T,k);return[R.selectedIndices,R.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:u,scores:d,maxOutputSize:m,iouThreshold:b,scoreThreshold:T}=Cr(n,e,t),k=S("padToMaxOutputSize",n,e,t),R=await a.image.nonMaxSuppressionPaddedAsync(u,d,m,b,T,k);return[R.selectedIndices,R.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:u,scores:d,maxOutputSize:m,iouThreshold:b,scoreThreshold:T}=Cr(n,e,t);return[await a.image.nonMaxSuppressionAsync(u,d,m,b,T)]}case"Where":{const u=a.cast(S("condition",n,e,t),"bool"),d=[await a.whereAsync(u)];return u.dispose(),d}case"ListDiff":return a.setdiff1dAsync(S("x",n,e,t),S("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}},fr="dynamic";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sr=(n,e,t,s=$t)=>{switch(n.op){case"LowerBound":{const a=S("sortedSequence",n,e,t),u=S("values",n,e,t);return[s.lowerBound(a,u)]}case"TopKV2":{const a=S("x",n,e,t),u=S("k",n,e,t),d=S("sorted",n,e,t),m=s.topk(a,u,d);return[m.values,m.indices]}case"UpperBound":{const a=S("sortedSequence",n,e,t),u=S("values",n,e,t);return[s.upperBound(a,u)]}case"Unique":{const a=S("x",n,e,t),u=s.unique(a);return[u.values,u.indices]}case"UniqueV2":{const a=S("x",n,e,t),u=S("axis",n,e,t),d=s.unique(a,u);return[d.values,d.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},so="evaluation";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ro=(n,e,t,s=$t)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const a=S("default",n,e,t);return[nt(n.name,e,t)||a];case"Placeholder":return[nt(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const k=S("x",n,e,t);return[ct(k)]}case"IdentityN":return S("x",n,e,t).map(k=>ct(k));case"Snapshot":const u=S("x",n,e,t);return[ct(u)];case"Shape":return[s.tensor1d(S("x",n,e,t).shape,"int32")];case"ShapeN":return S("x",n,e,t).map(k=>s.tensor1d(k.shape));case"Size":return[s.scalar(S("x",n,e,t).size,"int32")];case"Rank":return[s.scalar(S("x",n,e,t).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const d=S("x",n,e,t),m=S("data",n,e,t),b=S("message",n,e,t),T=S("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(b);for(let k=0;k<m.length;k++)console.log(Array.prototype.slice.call(m[k].dataSync()).slice(0,T));return[d];default:throw TypeError(`Node type ${n.op} is not implemented`)}},wo="graph";var oo=L(528);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class js{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=(0,y.iD$)(0),this.tensorMap=new Map,(0,y.CnY)(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return oo.i(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(a=>a.dispose()),this.tensorMap.clear(),(0,y.lub)(()=>{const a=(0,y.HHK)(t),u=s.length,d=a.length;y.D5U.assert(u===d,()=>`The number of elements doesn't match, keys has ${u} elements, the values has ${d} elements.`);for(let m=0;m<u;m++){const b=s[m],T=a[m];(0,y.CnY)(T),this.tensorMap.set(b,T)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return(0,y.lub)(()=>{const a=[];for(let u=0;u<s.length;u++){const d=s[u],m=this.findWithDefault(d,t);a.push(m)}return(0,y.knu)(a)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const er=async(n,e,t,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{const a=s.getHashTableHandleByName(n.name);if(a!=null)return[a];{const u=S("keyDType",n,e,t),d=S("valueDType",n,e,t),m=new js(u,d);return s.addHashTable(n.name,m),[m.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const a=S("tableHandle",n,e,t,s),u=S("keys",n,e,t),d=S("values",n,e,t);return[await s.getHashTableById(a.id).import(u,d)]}case"LookupTableFind":case"LookupTableFindV2":{const a=S("tableHandle",n,e,t,s),u=S("keys",n,e,t),d=S("defaultValue",n,e,t);return[await s.getHashTableById(a.id).find(u,d)]}case"LookupTableSize":case"LookupTableSizeV2":{const a=S("tableHandle",n,e,t,s);return[s.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},Br="hash_table";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tr=(n,e,t,s=$t)=>{switch(n.op){case"ResizeBilinear":{const a=S("images",n,e,t),u=S("size",n,e,t),d=S("alignCorners",n,e,t),m=S("halfPixelCenters",n,e,t);return[s.image.resizeBilinear(a,[u[0],u[1]],d,m)]}case"ResizeNearestNeighbor":{const a=S("images",n,e,t),u=S("size",n,e,t),d=S("alignCorners",n,e,t),m=S("halfPixelCenters",n,e,t);return[s.image.resizeNearestNeighbor(a,[u[0],u[1]],d,m)]}case"CropAndResize":{const a=S("image",n,e,t),u=S("boxes",n,e,t),d=S("boxInd",n,e,t),m=S("cropSize",n,e,t),b=S("method",n,e,t),T=S("extrapolationValue",n,e,t);return[s.image.cropAndResize(a,u,d,m,b,T)]}case"ImageProjectiveTransformV3":{const a=S("images",n,e,t),u=S("transforms",n,e,t),d=S("outputShape",n,e,t),m=S("fillValue",n,e,t),b=S("interpolation",n,e,t),T=S("fillMode",n,e,t);return[s.image.transform(a,u,b.toLowerCase(),T.toLowerCase(),m,d)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},Do="image";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _o=(n,e,t,s=$t)=>{switch(n.op){case"Equal":return[s.equal(S("a",n,e,t),S("b",n,e,t))];case"NotEqual":return[s.notEqual(S("a",n,e,t),S("b",n,e,t))];case"Greater":return[s.greater(S("a",n,e,t),S("b",n,e,t))];case"GreaterEqual":return[s.greaterEqual(S("a",n,e,t),S("b",n,e,t))];case"Less":return[s.less(S("a",n,e,t),S("b",n,e,t))];case"LessEqual":return[s.lessEqual(S("a",n,e,t),S("b",n,e,t))];case"LogicalAnd":return[s.logicalAnd(S("a",n,e,t),S("b",n,e,t))];case"LogicalNot":return[s.logicalNot(S("a",n,e,t))];case"LogicalOr":return[s.logicalOr(S("a",n,e,t),S("b",n,e,t))];case"Select":case"SelectV2":return[s.where(S("condition",n,e,t),S("a",n,e,t),S("b",n,e,t))];case"BitwiseAnd":return[s.bitwiseAnd(S("a",n,e,t),S("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},ao="logical";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ms=(n,e,t,s=$t)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(S("a",n,e,t),S("b",n,e,t),S("transposeA",n,e,t),S("transposeB",n,e,t))];case"Einsum":return[s.einsum(S("equation",n,e,t),...S("tensors",n,e,t))];case"Transpose":return[s.transpose(S("x",n,e,t),S("perm",n,e,t))];case"_FusedMatMul":const[a,u]=S("fusedOps",n,e,t),d=a==="biasadd",m=u==="prelu",b=S("numArgs",n,e,t),T=S("leakyreluAlpha",n,e,t);if(d){if(m&&b!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!m&&b!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[k,R]=S("args",n,e,t);return[s.fused.matMul({a:S("a",n,e,t),b:S("b",n,e,t),transposeA:S("transposeA",n,e,t),transposeB:S("transposeB",n,e,t),bias:k,activation:u,preluActivationWeights:R,leakyreluAlpha:T})];case"MatrixBandPart":return[s.linalg.bandPart(S("a",n,e,t),S("numLower",n,e,t),S("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},Ao="matrices";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jr=(n,e,t,s=$t)=>{switch(n.op){case"EuclideanNorm":return[s.euclideanNorm(S("x",n,e,t),S("axis",n,e,t),S("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(S("x",n,e,t),S("mean",n,e,t),S("variance",n,e,t),S("offset",n,e,t),S("scale",n,e,t),S("epsilon",n,e,t))];case"FusedBatchNormV3":return[s.batchNorm(S("x",n,e,t),S("mean",n,e,t),S("variance",n,e,t),S("offset",n,e,t),S("scale",n,e,t),S("epsilon",n,e,t))];case"LRN":return[s.localResponseNormalization(S("x",n,e,t),S("radius",n,e,t),S("bias",n,e,t),S("alpha",n,e,t),S("beta",n,e,t))];case"Softmax":return[s.softmax(S("x",n,e,t))];case"LogSoftmax":return[s.logSoftmax(S("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},Ws="normalization";/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kr=(n,e,t,s=$t)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:a,outputDenseValues:u}=s.raggedGather(S("paramsNestedSplits",n,e,t),S("paramsDenseValues",n,e,t),S("indices",n,e,t),S("outputRaggedRank",n,e,t));return a.concat(u)}case"RaggedRange":{const{rtNestedSplits:a,rtDenseValues:u}=s.raggedRange(S("starts",n,e,t),S("limits",n,e,t),S("splits",n,e,t));return[a,u]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(S("shape",n,e,t),S("values",n,e,t),S("defaultValue",n,e,t),S("rowPartitionTensors",n,e,t),S("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},zo="ragged";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vo=(n,e,t,s=$t)=>{switch(n.op){case"Max":{const m=S("axis",n,e,t),b=S("keepDims",n,e,t);return[s.max(S("x",n,e,t),m,b)]}case"Mean":{const m=S("axis",n,e,t),b=S("keepDims",n,e,t);return[s.mean(S("x",n,e,t),m,b)]}case"Min":{const m=S("axis",n,e,t),b=S("keepDims",n,e,t);return[s.min(S("x",n,e,t),m,b)]}case"Sum":{const m=S("axis",n,e,t),b=S("keepDims",n,e,t);return[s.sum(S("x",n,e,t),m,b)]}case"All":{const m=S("axis",n,e,t),b=S("keepDims",n,e,t);return[s.all(S("x",n,e,t),m,b)]}case"Any":{const m=S("axis",n,e,t),b=S("keepDims",n,e,t);return[s.any(S("x",n,e,t),m,b)]}case"ArgMax":{const m=S("axis",n,e,t);return[s.argMax(S("x",n,e,t),m)]}case"ArgMin":{const m=S("axis",n,e,t);return[s.argMin(S("x",n,e,t),m)]}case"Prod":{const m=S("axis",n,e,t),b=S("keepDims",n,e,t);return[s.prod(S("x",n,e,t),m,b)]}case"Cumprod":{const m=S("axis",n,e,t),b=S("exclusive",n,e,t),T=S("reverse",n,e,t);return[s.cumprod(S("x",n,e,t),m,b,T)]}case"Cumsum":{const m=S("axis",n,e,t),b=S("exclusive",n,e,t),T=S("reverse",n,e,t);return[s.cumsum(S("x",n,e,t),m,b,T)]}case"Bincount":const a=S("x",n,e,t),u=S("weights",n,e,t),d=S("size",n,e,t);return[s.bincount(a,u,d)];case"DenseBincount":{const m=S("x",n,e,t),b=S("weights",n,e,t),T=S("size",n,e,t),k=S("binaryOutput",n,e,t);return[s.denseBincount(m,b,T,k)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},Po="reduction";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cs=(n,e,t,s=$t)=>{switch(n.op){case"ConcatV2":case"Concat":{const a=S("n",n,e,t),u=S("axis",n,e,t);let d=S("tensors",n,e,t);return d=d.slice(0,a),[s.concat(d,u)]}case"Gather":{const a=S("x",n,e,t),u=S("indices",n,e,t);return[s.gather(a,s.cast(u,"int32"),0)]}case"GatherV2":{const a=S("axis",n,e,t),u=S("batchDims",n,e,t),d=S("x",n,e,t),m=S("indices",n,e,t);return[s.gather(d,s.cast(m,"int32"),a,u)]}case"Reverse":{const a=S("dims",n,e,t),u=[];for(let m=0;m<a.length;m++)a[m]&&u.push(m);const d=S("x",n,e,t);return[s.reverse(d,u)]}case"ReverseV2":{const a=S("axis",n,e,t),u=S("x",n,e,t);return[s.reverse(u,a)]}case"Slice":{const a=S("begin",n,e,t),u=S("size",n,e,t);return[s.slice(S("x",n,e,t),a,u)]}case"StridedSlice":{const a=S("begin",n,e,t),u=S("end",n,e,t),d=S("strides",n,e,t),m=S("beginMask",n,e,t),b=S("endMask",n,e,t),T=S("ellipsisMask",n,e,t),k=S("newAxisMask",n,e,t),R=S("shrinkAxisMask",n,e,t),B=S("x",n,e,t);return[s.stridedSlice(B,a,u,d,m,b,T,k,R)]}case"Pack":return(0,y.lub)(()=>{const a=S("axis",n,e,t),u=S("tensors",n,e,t),d=u[0].shape,m=s.squeeze(u[0]).shape,b=u.map(T=>{const k=y.D5U.arraysEqual(T.shape,d);if(!k&&!y.D5U.arraysEqual(s.squeeze(T).shape,m))throw new Error("the input tensors shape does not match");return k?T:s.reshape(T,d)});return[s.stack(b,a)]});case"Unpack":{const a=S("axis",n,e,t),u=S("tensor",n,e,t);return s.unstack(u,a)}case"Tile":{const a=S("reps",n,e,t);return[s.tile(S("x",n,e,t),a)]}case"Split":case"SplitV":{const a=S("axis",n,e,t),u=S("numOrSizeSplits",n,e,t),d=S("x",n,e,t);return s.split(d,u,a)}case"ScatterNd":{const a=S("indices",n,e,t),u=S("values",n,e,t),d=S("shape",n,e,t);return[s.scatterND(a,u,d)]}case"GatherNd":{const a=S("x",n,e,t),u=S("indices",n,e,t);return[s.gatherND(a,u)]}case"SparseToDense":{const a=S("sparseIndices",n,e,t),u=S("outputShape",n,e,t),d=S("sparseValues",n,e,t),m=S("defaultValue",n,e,t);return[s.sparseToDense(a,d,u,d.dtype===m.dtype?m:s.cast(m,d.dtype))]}case"TensorScatterUpdate":{const a=S("indices",n,e,t),u=S("values",n,e,t),d=S("tensor",n,e,t);return[s.tensorScatterUpdate(d,a,u)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},as="slice_join";/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oo=(n,e,t,s=$t)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:a,outputValues:u,emptyRowIndicator:d,reverseIndexMap:m}=s.sparse.sparseFillEmptyRows(S("indices",n,e,t),S("values",n,e,t),S("denseShape",n,e,t),S("defaultValue",n,e,t));return[a,u,d,m]}case"SparseReshape":{const{outputIndices:a,outputShape:u}=s.sparse.sparseReshape(S("inputIndices",n,e,t),S("inputShape",n,e,t),S("newShape",n,e,t));return[a,u]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(S("data",n,e,t),S("indices",n,e,t),S("segmentIds",n,e,t))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(S("data",n,e,t),S("indices",n,e,t),S("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},Lr="sparse";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Co=(n,e,t,s=$t)=>{switch(n.op){case"FFT":return[s.fft(S("x",n,e,t))];case"IFFT":return[s.ifft(S("x",n,e,t))];case"RFFT":return[s.rfft(S("x",n,e,t))];case"IRFFT":return[s.irfft(S("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},Ss="spectral";/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fs=(n,e,t,s=$t)=>{switch(n.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(S("input",n,e,t),S("pattern",n,e,t),S("rewrite",n,e,t),S("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:a,nGramsSplits:u}=s.string.stringNGrams(S("data",n,e,t),S("dataSplits",n,e,t),S("separator",n,e,t),S("nGramWidths",n,e,t),S("leftPad",n,e,t),S("rightPad",n,e,t),S("padWidth",n,e,t),S("preserveShortSequences",n,e,t));return[a,u]}case"StringSplit":{const{indices:a,values:u,shape:d}=s.string.stringSplit(S("input",n,e,t),S("delimiter",n,e,t),S("skipEmpty",n,e,t));return[a,u,d]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(S("input",n,e,t),S("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},uo="string";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const An=(n,e,t,s=$t)=>{switch(n.op){case"Cast":return[s.cast(S("x",n,e,t),S("dtype",n,e,t))];case"ExpandDims":{const a=S("axis",n,e,t);return[s.expandDims(S("x",n,e,t),a)]}case"Squeeze":{const a=S("axis",n,e,t);return[s.squeeze(S("x",n,e,t),a)]}case"Reshape":return[s.reshape(S("x",n,e,t),S("shape",n,e,t))];case"EnsureShape":return[s.ensureShape(S("x",n,e,t),S("shape",n,e,t))];case"MirrorPad":return[s.mirrorPad(S("x",n,e,t),S("padding",n,e,t),S("mode",n,e,t))];case"PadV2":case"Pad":return[s.pad(S("x",n,e,t),S("padding",n,e,t),S("constantValue",n,e,t))];case"SpaceToBatchND":{const a=S("blockShape",n,e,t),u=S("paddings",n,e,t);return[s.spaceToBatchND(S("x",n,e,t),a,u)]}case"BatchToSpaceND":{const a=S("blockShape",n,e,t),u=S("crops",n,e,t);return[s.batchToSpaceND(S("x",n,e,t),a,u)]}case"DepthToSpace":{const a=S("blockSize",n,e,t),u=S("dataFormat",n,e,t).toUpperCase();return[s.depthToSpace(S("x",n,e,t),a,u)]}case"BroadcastTo":return[s.broadcastTo(S("x",n,e,t),S("shape",n,e,t))];case"BroadcastArgs":return[s.broadcastArgs(S("s0",n,e,t),S("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},Ur="transformation";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ar(n,e,t,s,a=y.lub){const u=((d,m,b)=>{switch(d.category){case"arithmetic":return a(()=>Dn(d,m,b));case"basic_math":return a(()=>qs(d,m,b));case"control":return Js(d,m,b);case"convolution":return a(()=>Zn(d,m,b));case"creation":return a(()=>no(d,m,b));case"dynamic":return Cs(d,m,b);case"evaluation":return a(()=>Sr(d,m,b));case"image":return a(()=>tr(d,m,b));case"graph":return a(()=>ro(d,m,b));case"logical":return a(()=>_o(d,m,b));case"matrices":return a(()=>ms(d,m,b));case"normalization":return a(()=>jr(d,m,b));case"ragged":return a(()=>Kr(d,m,b));case"reduction":return a(()=>vo(d,m,b));case"slice_join":return a(()=>cs(d,m,b));case"sparse":return a(()=>Oo(d,m,b));case"spectral":return a(()=>Co(d,m,b));case"string":return a(()=>fs(d,m,b));case"transformation":return a(()=>An(d,m,b));case"hash_table":return er(d,m,b,s);case"custom":const T=Be(d.op);if(T&&T.customExecutor)return T.customExecutor(new mn(d,m,b));throw TypeError(`Custom op ${d.op} is not registered.`);default:throw TypeError(`Unknown op '${d.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return y.D5U.isPromise(u)?u.then(d=>[].concat(d)):[].concat(u)}class nr{constructor(e={},t={},s={},a={},u){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=a,this.parseNodeNameCache=u,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ir(n,e,t,s){const a=new Set,u=[];let d=null,m=null;const b=new Set,T=new Set(Object.keys(n).map(B=>ce(B)[0]));s=s||[];const k=new Set(s.map(B=>ce(B.name)[0])),R=[...e];for(;R.length>0;){const B=R.pop();if((ur(B)||Se(B)||fe(B))&&d==null&&(d=B,m=d.children.map(X=>X.name).filter(X=>a.has(X))),a.add(B.name),t[B.name]==null&&!T.has(B.name)&&!k.has(B.name)){if(B.inputs.length===0){u.push(B.name);continue}B.inputs.forEach(X=>{b.has(X.name)||(b.add(X.name),R.push(X))})}}return{inputs:n,outputs:e,usedNodes:a,missingInputs:u,dynamicNode:d,syncInputs:m}}function So(n,e){const{usedNodes:t,inputs:s}=e,a=Object.keys(s).map(he=>ce(he)[0]).map(he=>n.nodes[he]),u=n.initNodes||[],d=he=>t.has(typeof he=="string"?he:he.name);function m(he){return[...new Map(he.map(Ue=>[Ue.name,Ue])).values()]}const b=m([...a,...n.weights,...u]).filter(d),T=m([...b,...Object.values(n.nodes)]).filter(d),k=new Map(T.map(he=>[he.name,he])),R={};for(const he of T){R[he.name]=R[he.name]||0;for(const Ue of he.children)d(Ue)||(R[Ue.name]=Number.POSITIVE_INFINITY),R[Ue.name]=(R[Ue.name]||0)+1}const B=Object.entries(R).filter(([,he])=>he===0).map(([he])=>he),X=[...B];for(;B.length>0;){const he=B.pop(),Ue=k.get(he);for(const Xe of Ue.children.filter(d))--R[Xe.name]===0&&(X.push(Xe.name),B.push(Xe.name))}const oe=X.map(he=>k.get(he)),ue=Mr(oe,b);return Ir(ue,b),ue}function Mr(n,e){const t=new Map(n.map(d=>[d.name,d])),s=e.map(d=>d.name),a=new Set(s);for(;s.length>0;){const d=s.pop(),m=t.get(d);for(const b of m.children)!t.has(b.name)||a.has(b.name)||(a.add(b.name),s.push(b.name))}return n.filter(d=>a.has(d.name))}class Ye extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function Ir(n,e){const t=new Map(n.map((m,b)=>[m.name,b])),s=new Set(e.map(m=>m.name)),a=m=>s.has(typeof m=="string"?m:m.name),u=new Set(n.map(m=>m.name)),d=m=>u.has(typeof m=="string"?m:m.name);for(const m of n){for(const b of m.children.filter(d)){if(!t.has(b.name))throw new Ye(`Child ${b.name} of node ${m.name} is unreachable.`);if(t.get(m.name)>t.get(b.name))throw new Ye(`Node ${m.name} is scheduled to run after its child ${b.name}.`)}if(!a(m))for(const b of m.inputs){if(!t.has(b.name))throw new Ye(`Input ${b.name} of node ${m.name} is unreachable.`);if(t.get(b.name)>t.get(m.name))throw new Ye(`Node ${m.name} is scheduled to run before its input ${b.name}.`)}}}function Jn(n){const e=new Map(n.map((m,b)=>[m.name,b])),t=Number.MAX_SAFE_INTEGER,s=n.map((m,b)=>ur(m)?t:b),a=m=>{const b=s[e.get(m.name)];return b??-1},u=n.map((m,b)=>m.children.map(a).reduce((T,k)=>Math.max(T,k),s[b])),d=new Map;for(let m=0;m<n.length;++m){const b=u[m];if(b===t)continue;const T=n[m],k=n[b];d.has(k.name)||d.set(k.name,[]),d.get(k.name).push(T)}return d}const Er=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Wr=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Fs=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function ur(n){return Er.has(n.op)}function Se(n){return Wr.has(n.op)}function fe(n){return Fs.has(n.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class de{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(a=>a.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new de(e.functions[s],this)})}getCompilationKey(e,t){const s=e.map(u=>u.name).sort(),a=t.map(u=>u.name).sort();return s.join(this.SEPARATOR)+"--"+a.join(this.SEPARATOR)}compile(e,t){const s=ir(e,t,this.weightMap,this._initNodes),{missingInputs:a,dynamicNode:u,syncInputs:d}=s;if(u!=null)throw new Error(`This execution contains the node '${u.name}', which has the dynamic op '${u.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${d}]`);if(a.length>0){const T=t.map(R=>R.name),k=Object.keys(e);throw new Error(`Cannot compute the outputs [${T}] from the provided inputs [${k}]. Missing the following inputs: [${a}]`)}const m=So(this.graph,s),b=Jn(m);return{orderedNodes:m,nodeLiveUntilMap:b}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return(0,y.CnY)(t),t}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,s])=>[t,this.cloneTensorList(s)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const a=s.map(B=>this.graph.nodes[ce(B)[0]]),u=t.map(B=>ce(B)[0]),d=new Set(u);let m=u.map(B=>this.graph.nodes[B]);m.length===0&&(m=this._outputs);const b=this.getCompilationKey(a,m);let T=this.compiledMap.get(b);T==null&&(T=this.compile(e,m),this.compiledMap.set(b,T));try{this.keepIntermediateTensors=(0,y.OBj)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(B){this.keepIntermediateTensors=!1,console.warn(B.message)}const k={},R={};return(0,y.lub)(()=>{const B=new nr(this.weightMap,k,R,this.functionExecutorMap,this.parseNodeNameCache),X=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(Ue=>{const[Xe,ot]=ce(Ue,B),it=[];it[ot]=e[Ue],X[Xe]=it,this.keepIntermediateTensors&&(this.clonedTensorsMap[Xe]=this.cloneTensorList(it))});const oe=this.getFrozenTensorIds(X),{orderedNodes:ue,nodeLiveUntilMap:he}=T;for(const Ue of ue){if(X[Ue.name])continue;const Xe=ar(Ue,X,B,this._resourceManager);if(y.D5U.isPromise(Xe))throw new Error(`The execution of the op '${Ue.op}' returned a promise. Please use model.executeAsync() instead.`);X[Ue.name]=Xe,this.keepIntermediateTensors&&(this.clonedTensorsMap[Ue.name]=this.cloneTensorList(Xe)),this.checkTensorForDisposalWithNodeLiveUntilInfo(Ue,X,B,oe,d,he.get(Ue.name))}return this.parent==null&&B.dispose(oe),t.map(Ue=>nt(Ue,X,B))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(a=>a.id)));return new Set(t)}checkTensorForDisposal(e,t,s,a,u,d,m){if(!(ur(t)||d.has(e))){for(const b of s[e])b!=null&&(m[b.id]=(m[b.id]||0)+t.children.length);for(const b of t.inputs){if(ur(b))continue;const T=ne(b.name,s,a);if(T!=null)for(const k of T){if(!k||k.kept||u.has(k.id))continue;const R=m[k.id];R===1?(k.dispose(),delete m[k.id]):R!=null&&m[k.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,s,a,u,d){function m(b){return ur(b)||u.has(b.name)}if(!(ur(e)||d==null))for(const b of d){if(m(b))continue;const T=ne(b.name,t,s);for(const k of T)!k||k.kept||a.has(k.id)||k.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,s=!1,a={},u={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=(0,y.OBj)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(B){this.keepIntermediateTensors=!1,console.warn(B.message)}const d=new nr(this.weightMap,a,u,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const m=await this.executeWithControlFlow(e,d,t,s),b=t.map(B=>nt(B,m,d)),T=b.map(B=>B.id),k=Object.keys(e).map(B=>e[B].id),R=new Set([...T,...k,...this.weightIds]);return Object.values(m).forEach(B=>{B.forEach(X=>{X&&!X.isDisposed&&!R.has(X.id)&&X.dispose()})}),this.parent==null&&d.dispose(R),b}async executeFunctionAsync(e,t,s){const a=e.reduce((u,d,m)=>(u[this.inputs[m].name]=d,u),{});return this._executeAsync(a,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,a){const u=Object.keys(e),d=u.map(it=>this.graph.nodes[ce(it)[0]]),m=s.map(it=>ce(it)[0]),b=new Set(m);let T=m.map(it=>this.graph.nodes[it]);T.length===0&&(T=this._outputs);const{usedNodes:k,missingInputs:R,dynamicNode:B,syncInputs:X}=ir(e,T,this.weightMap,this._initNodes),oe=[...d,...this.graph.weights,...this._initNodes||[]].map(it=>({node:it,contexts:t.currentContext})),ue=Object.assign({},this.weightMap);Object.keys(e).forEach(it=>{const[mt,wt]=ce(it),St=[];St[wt]=e[it],ue[mt]=St});const he={},Ue=this.getFrozenTensorIds(ue),Xe={};for(;oe.length>0;){const it=this.processStack(d,oe,t,ue,Xe,Ue,b,he,k);await Promise.all(it)}B==null&&!a&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const ot=T.filter(it=>!ur(it)&&!nt(it.name,ue,t)).map(it=>it.name);if(ot.length>0){let it="";throw B!=null&&(it=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${X}]`),new Error(`Cannot compute the outputs [${ot}] from the provided inputs [${u}]. Consider providing the following inputs: [${R}]. ${it}`)}return ue}processStack(e,t,s,a,u,d,m,b,T){const k=[];for(;t.length>0;){const R=t.pop();s.currentContext=R.contexts;let B="";if(R.node.op==="Enter"&&S("isConstant",R.node,a,s)&&([B]=Ne(R.node.name,s)),a[R.node.name]==null){const X=ar(R.node,a,s,this._resourceManager);B||([B]=Ne(R.node.name,s));const oe=s.currentContext;y.D5U.isPromise(X)?k.push(X.then(ue=>(a[B]=ue,this.keepIntermediateTensors&&(this.clonedTensorsMap[B]=this.cloneTensorList(ue)),s.currentContext=oe,this.checkTensorForDisposal(B,R.node,a,s,d,m,b),this.processChildNodes(R.node,t,s,a,u,T),ue))):(a[B]=X,this.keepIntermediateTensors&&(this.clonedTensorsMap[B]=this.cloneTensorList(X)),this.checkTensorForDisposal(B,R.node,a,s,d,m,b),this.processChildNodes(R.node,t,s,a,u,T))}else this.processChildNodes(R.node,t,s,a,u,T)}return k}processChildNodes(e,t,s,a,u,d){e.children.forEach(m=>{const[b]=Ne(m.name,s);u[b]||!d.has(m.name)||(m.op==="Merge"?m.inputNames.some(T=>!!nt(T,a,s))&&(u[b]=!0,t.push({contexts:s.currentContext,node:m})):m.inputNames.every(T=>!!nt(T,a,s))&&(u[b]=!0,t.push({contexts:s.currentContext,node:m})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[a]=ce(t),u=this.graph.nodes[a];if(u.attrParams.shape&&u.attrParams.shape.value){const d=u.attrParams.shape.value,m=d.length===s.shape.length&&s.shape.every((b,T)=>d[T]===-1||d[T]===b);y.D5U.assert(m,()=>`The shape of dict['${u.name}'] provided in model.execute(dict) must be [${d}], but was [${s.shape}]`)}u.attrParams.dtype&&u.attrParams.dtype.value&&y.D5U.assert(s.dtype===u.attrParams.dtype.value,()=>`The dtype of dict['${u.name}'] provided in model.execute(dict) must be ${u.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var t,s;const a={};for(const u in e){const d=(s=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||s===void 0?void 0:s[u];d!=null?a[d.name]=e[u]:a[u]=e[u]}return a}checkInputs(e){const t=Object.keys(e).filter(s=>{const[a]=ce(s);return this.graph.nodes[a]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var s,a;const u=(a=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||a===void 0?void 0:a[t];return u!=null?u.name:t},{})}checkOutputs(e){e.forEach(t=>{const[s]=ce(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class Ee{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}var Ae=L(1146);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pe="?tfjs-format=file",We="model.json";class je{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},s=y.io){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=s,t==null&&(this.loadOptions={}),this.resourceManager=new Ee}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return y.D5U.isPromise(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await(0,Ae.r)(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const s=this.artifacts.modelTopology;let a=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const u=this.artifacts.userDefinedMetadata;u.signature!=null&&(a=u.signature),u.structuredOutputKeys!=null&&(this.structuredOutputKeys=u.structuredOutputKeys)}if(this.signature=a,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new de(As.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const u=As.Instance.transformGraph(e.modelInitializer);this.initializer=new de(u),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof y.esB?[e]:e,s={};return t.forEach((a,u)=>s[this.structuredOutputKeys[u]]=a),s}return e}predict(e,t){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,t){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var t;if(!(e instanceof y.esB)&&!Array.isArray(e)){const u=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(u!=null)for(const d in u){const m=u[d];m.resourceId!=null&&(e[d]=this.resourceIdToCapturedInput[m.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let a=0;return this.inputNodes.reduce((u,d)=>{var m,b,T;const k=(T=(b=(m=this.signature)===null||m===void 0?void 0:m.inputs)===null||b===void 0?void 0:b[d])===null||T===void 0?void 0:T.resourceId;return k!=null?u[d]=this.resourceIdToCapturedInput[k]:u[d]=e[a++],u},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,s=Object.keys(t);for(let a=0;a<s.length;a++){const u=s[a],d=t[u];this.resourceIdToCapturedInput[d.resourceId]=e[a]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&(0,y.B90)(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Oe(n,e={},t=y.io){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=ut(n));const s=new je(n,e,t);return await s.load(),s}function st(n){if(n==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(n instanceof Array){const[s,a]=n;if(!s)throw new Error("modelJSON must be the first element of the array");if(!a||!(a instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in s))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in s))throw new Error("Model JSON is missing 'weightsManifest'");const u=io.getWeightSpecs(s.weightsManifest),d=io.getModelArtifactsForJSONSync(s,u,a);e=io.fromMemorySync(d)}else if("load"in n)e=n;else if("modelTopology"in n&&"weightSpecs"in n&&"weightData"in n)e=io.fromMemorySync(n);else throw new Error("Unknown model format");const t=new je(e);return t.load(),t}function ut(n){return n.endsWith("/")||(n=n+"/"),`${n}${We}${Pe}`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tt=(0,y.OBj)();tt.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15),tt.registerFlag("WEBGPU_CPU_FORWARD",()=>!0),tt.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1),tt.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0),tt.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1),tt.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3),tt.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1),tt.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0),tt.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1),tt.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1),tt.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1),tt.registerFlag("WEBGPU_PRINT_SHADER",()=>""),tt.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yt{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class At{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,t,s=!1,a=!0){let u;const d=xt(e,t);return a?(this.freeBuffers.has(d)||this.freeBuffers.set(d,[]),this.freeBuffers.get(d).length>0?(u=this.freeBuffers.get(d).pop(),this.numFreeBuffers--):(u=this.device.createBuffer({size:e,usage:t,mappedAtCreation:s}),this.numBytesAllocated+=e)):(u=this.device.createBuffer({size:e,usage:t,mappedAtCreation:s}),this.numBytesAllocated+=e),this.usedBuffers.has(d)||this.usedBuffers.set(d,[]),this.usedBuffers.get(d).push(u),this.numUsedBuffers++,this.numBytesUsed+=e,u}releaseBuffer(e,t=!0){if(this.freeBuffers.size===0)return;const s=e.size,a=e.usage,u=xt(s,a),d=this.usedBuffers.get(u),m=d.indexOf(e);if(m<0)throw new Error("Cannot find the buffer in buffer manager");d[m]=d[d.length-1],d.pop(),this.numUsedBuffers--,this.numBytesUsed-=s,t?(this.freeBuffers.get(u).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=s)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function xt(n,e){return`${n}_${e}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qt{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,s,a){const u=Ct(s),d=e*t*u,m=gt(e,t,s,a);if(this.freeTextures.has(m)||this.freeTextures.set(m,[]),this.usedTextures.has(m)||this.usedTextures.set(m,[]),this.numBytesUsed+=d,this.numUsedTextures++,this.freeTextures.get(m).length>0){this.numFreeTextures--;const T=this.freeTextures.get(m).shift();return this.usedTextures.get(m).push(T),T}this.numBytesAllocated+=d;const b=this.device.createTexture({size:[e,t],format:s,usage:a});return this.usedTextures.get(m).push(b),b}releaseTexture(e){if(this.freeTextures.size===0)return;const t=e.width,s=e.height,a=e.format,u=e.usage,d=gt(t,s,a,u);this.freeTextures.has(d)||this.freeTextures.set(d,[]),this.freeTextures.get(d).push(e),this.numFreeTextures++,this.numUsedTextures--;const m=this.usedTextures.get(d),b=m.indexOf(e);if(b<0)throw new Error("Cannot release a texture that was never provided by this texture manager");m.splice(b,1);const T=Ct(a),k=t*s*T;this.numBytesUsed-=k}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.usedTextures.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function gt(n,e,t,s){return`${n}_${e}_${t}_${s}`}function Ct(n){if(n==="rgba8unorm")return 16;throw new Error(`${n} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pt(n,e){if(Math.max(...n)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const t=n.length,s="xyzwuv",a=n.map(d=>`${e}.${s[d]}`),u=new Array(t-1);u[t-2]=a[t-1];for(let d=t-3;d>=0;--d)u[d]=`(${u[d+1]} * ${a[d+1]})`;return u}const fn=(n,e,t)=>t==="int32"?`atomicAdd(${n}, bitcast<i32>(${e}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${n}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var pn;(function(n){n[n.FROM_PIXELS=0]="FROM_PIXELS",n[n.DRAW=1]="DRAW"})(pn||(pn={}));const Pn=(n,e,t,s,a)=>{const u={dtype:s.dtype,shape:s.shape},d=lo(t,u,e),m=n.createShaderModule({code:d,label:e.constructor.name});let b=(0,y.OBj)().get("WEBGPU_PRINT_SHADER");if(b!==""){b=b.toLowerCase();const T=b.split(",");(b==="all"||T.some(k=>e.shaderKey.toLowerCase().includes(k)))&&(console.group(e.shaderKey),console.debug(d),console.groupEnd())}return a?n.createComputePipelineAsync({compute:{module:m,entryPoint:"_start"},label:e.constructor.name,layout:"auto"}):n.createComputePipeline({compute:{module:m,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})},Jt=(n,e="f32")=>{switch(n){case 1:return`${e}`;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${n}-component ${e} is not supported.`)}};function Cn(n){if(n<=1)return"i32";if(n===2)return"vec2<i32>";if(n===3)return"vec3<i32>";if(n===4)return"vec4<i32>";if(n===5)return"vec5";if(n===6)return"vec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Hn(n){if(n===0)return"x";if(n===1)return"y";if(n===2)return"z";if(n===3)return"w";if(n===4)return"u";if(n===5)return"v";throw Error(`Index ${n} is not yet supported`)}function kt(...n){let e;switch(n.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${n[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function Tr(n,e){let t;return t=`
     ${Vr(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${n?"main(getGlobalIndex());":"main();"};
      }
    `,t}function Vr(n){return`
  @compute @workgroup_size(${n.workgroupSize[0]}, ${n.workgroupSize[1]}, ${n.workgroupSize[2]})
`}function lo(n,e,t){const s=[],a=t.workgroupSize[0]*t.workgroupSize[1]*t.workgroupSize[2];if(t.outputComponent=t.outputComponent?t.outputComponent:1,s.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${Ho(t)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${a}u +
                localIndex);
        `}
      }
    `),t.pixelsOpType!=null){const oe=t.pixelsOpType===pn.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${Rs(e.dtype,t.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${Rs(n[0].dtype,t.outputComponent)}>;`,ue=e.shape.length===3?"vec2<i32>":"i32";s.push(`
        struct Uniform {
          outShapeStrides : ${ue},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${oe}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const he=Bo(t);return[Io,s.join(`
`),zr(e.shape),t.getUserCode(),Tr(he,t)].join(`
`)}let u,d,m="struct Uniforms { NAN : f32, INFINITY : f32, ";t.variableNames.forEach((oe,ue)=>{const he=Cn(n[ue].shape.length);m+=`${oe.charAt(0).toLowerCase()+oe.slice(1)}Shape : ${he}, `,u=n[ue].shape.length-1,d=Cn(u),m+=`${oe.charAt(0).toLowerCase()+oe.slice(1)}ShapeStrides: ${d}, `});const b=Cn(e.shape.length);m+=`outShape : ${b}, `,u=e.shape.length-1,d=Cn(u),m+=`
         outShapeStrides: ${d}, `,t.size&&(m+="size : i32, "),t.uniforms&&(m+=t.uniforms),m+="};",m=$r(m),s.push(m),t.atomic?s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${Rs(e.dtype,t.outputComponent)}>;
    `),t.variableNames.forEach((oe,ue)=>{s.push(`
      @group(0) @binding(${1+ue}) var<storage, read> ${oe}: array<${t.variableComponents?Rs(n[ue].dtype,t.variableComponents[ue]):Rs(n[ue].dtype,t.outputComponent)}>;
        `)}),m!==""&&s.push(`
      @group(0) @binding(${1+t.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const T=lr(e.shape,t.dispatchLayout),k=[Io,s.join(`
`)+co,zr(e.shape),T,Go(e.shape.length)];t.atomic||k.push(Eo(e.shape,e.dtype,t.outputComponent)),t.variableNames.forEach((oe,ue)=>{k.push(`${zr(n[ue].shape,oe)}`)});const R=n.map((oe,ue)=>Fo(oe,e.shape,t.variableComponents?t.variableComponents[ue]:t.outputComponent,t.dispatchLayout.x.length===e.shape.length)).join(`
`);k.push(R),k.push(t.getUserCode());const B=Bo(t);return k.push(Tr(B,t)),k.join(`
`)}function Xr(n,e,t){let s=n.shaderKey;if(n.pixelsOpType!=null)return s;const a=[],u=[];e.forEach(k=>{a.push(k.shape),u.push(k.dtype)}),a.push(t.shape),u.push(t.dtype);const d=e.map(k=>y.Wap.getBroadcastDims(k.shape,t.shape)),m=e.map(k=>y.D5U.arraysEqual(k.shape,t.shape)).join("_"),b=d.map(k=>k.join("_")).join(";"),T=Ho(n)?"flatDispatch":"";return s+="_"+(n.workgroupSize?n.workgroupSize.join(","):"")+a.map(k=>k.length).join(",")+u.join(",")+n.variableNames.join(",")+b+m+T,s}const Io=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,co=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function zr(n,e=""){const t=n.length,s=e!==""?`get${e.charAt(0).toUpperCase()+e.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",a=e!==""?`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides`:"outShapeStrides";if(t<=1)return`fn ${s}(index : i32) -> i32 { return index; }`;const u=y.D5U.computeStrides(n),d=Cn(t),m=[];for(let T=0;T<t;T++)m.push(`d${T}`);if(u.length===1)return`    fn ${s}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${a}; let d1 = index - d0 * uniforms.${a};
      return vec2<i32>(d0, d1);
    }`;let b;return b="var index2 = index;"+u.map((T,k)=>{const R=`let ${m[k]} = index2 / uniforms.${a}.${Hn(k)}`,B=k===u.length-1?`let ${m[k+1]} = index2 - ${m[k]} * uniforms.${a}.${Hn(k)}`:`index2 = index2 - ${m[k]} * uniforms.${a}.${Hn(k)}`;return`${R}; ${B};`}).join(""),`
    fn ${s}(index : i32) -> ${d} {
      ${b}
      return ${d}(${m.join(",")});
    }
  `}function Wn(n,e){const t=n.name,s=n.shape.length,a=Cn(s),u="get"+t.charAt(0).toUpperCase()+t.slice(1),d=["d0","d1","d2","d3","d4","d5"].slice(0,s),m=d.map(k=>`${k} : i32`).join(", ");if(s<1)return`
      fn ${u}() -> ${Jt(e)} {
        return ${Jt(e)}(${t}[0]);
      }
    `;const b=`uniforms.${t.charAt(0).toLowerCase()+t.slice(1)}Shape`;let T=`${s}D`;return s===0&&(T="1D"),`
    fn ${u}(${m}) -> ${Jt(e)} {
      return ${Jt(e)}(${t}[getIndexFromCoords${T}(${a}(${d.join(",")}),
        ${b})${e===1?"":` / ${e}`}]);
    }
   `}function ea(n,e,t,s){const a=n.name,u=a.charAt(0).toUpperCase()+a.slice(1),d="get"+u+"ByOutput",m=n.shape.length,b=e.length,T=Cn(b);if(y.D5U.arraysEqual(n.shape,e)&&s)return`
    fn ${d}Index(globalIndex : i32) -> ${Jt(t)} {
      return ${Jt(t)}(${a}[globalIndex]);
    }

    fn ${d}Coords(coords : ${T}) -> ${Jt(t)} {
      return ${Jt(t)}(${a}[${b>1?"getOutputIndexFromCoords(coords)":"coords"}${t===1?"":` / ${t}`}]);
    }
    `;const k=y.Wap.getBroadcastDims(n.shape,e),R=b-m;let B="";if(m===0)return`
    fn ${d}Index(globalIndex : i32) -> ${Jt(t)}{
      return get${u}();
    }

    fn ${d}Coords(coords : ${T}) -> ${Jt(t)}{
      return get${u}();
    }
  `;b<2&&k.length>=1?B="coords = 0;":B=k.map(he=>`coords.${Hn(he+R)} = 0;`).join(`
`);let X="";if(b<2&&m>0)X="coords";else if(b>1){const he=Cn(m),Ue=n.shape.map((Xe,ot)=>`coords.${Hn(ot+R)}`).join(", ");X=`${he}(${Ue})`}else X="coords";const oe=`uniforms.${a.charAt(0).toLowerCase()+a.slice(1)}Shape`,ue=`${m}D`;return`
  fn ${d}Index(globalIndex : i32) -> ${Jt(t)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${B}
    return ${Jt(t)}(${a}[getIndexFromCoords${ue}(${X}, ${oe})${t===1?"":` / ${t}`}]);
  }

  fn ${d}Coords(coordsIn : ${T}) -> ${Jt(t)} {
    var coords = coordsIn;
    ${B}
    return ${Jt(t)}(${a}[getIndexFromCoords${ue}(${X}, ${oe})${t===1?"":` / ${t}`}]);
  }
`}function Fo(n,e,t,s){let a=Wn(n,t);return n.shape.length<=e.length&&(a+=ea(n,e,t,s)),a}function lr(n,e){const{x:t,y:s=[],z:a=[]}=e,u=n.length,d=t.length+s.length+a.length;if(d!==u)return"";if(t.length===u)return`fn getOutputCoords() -> ${Cn(u)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let m="";const b=[t,s,a];for(let B=0;B<b.length;B++){const X=b[B];if(X.length!==0)if(X.length===1)m+=`let d${X[0]} = i32(globalId[${B}]);`;else{const oe=Pt(X,"uniforms.outShape");m+=`var index${B} = i32(globalId[${B}]);`;for(let ue=0;ue<oe.length;ue++)m+=`let d${X[ue]} = index${B} / ${oe[ue]};`,ue===oe.length-1?m+=`let d${X[ue+1]} = index${B} - d${X[ue]} * ${oe[ue]};`:m+=`index${B} = index${B} - d${X[ue]} * ${oe[ue]};`}}const T=[];for(let B=0;B<d;B++)T.push(`d${B}`);const k=Cn(d);let R=`fn getOutputCoords() -> ${k} {
  ${m}
`;return T.length===0?R+=`return ${k}(0); }`:R+=`return ${k}(${T.join(",")}); }`,R}function Go(n){let e="";switch(n){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:y.D5U.assert(!1,()=>`Unsupported ${n}D shape`);break}return e}function Ho(n){return n.dispatch[1]===1&&n.dispatch[2]===1}function Rs(n,e=1){if(n==="float32")return Jt(e,"f32");if(n==="int32"||n==="bool")return Jt(e,"i32");throw new Error(`type ${n} is not supported.`)}function Eo(n,e,t){const s=n.length,a=Rs(e,t);let u=`fn setOutputAtIndex(flatIndex : i32, value : ${Jt(t)}) {
      result[flatIndex] = ${a}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${Jt(t,"i32")}) {
      result[flatIndex] = ${a}(value);
    }
    `;if(s>=2){const d=["d0","d1","d2","d3","d4","d5"].slice(0,s),m=Cn(s);u+=`
      fn setOutputAtCoords(${d.map(b=>`${b} : i32`).join(", ")}, value : ${Jt(t)}) {
        let flatIndex = getOutputIndexFromCoords(${m}(${d.join(", ")}));
        setOutputAtIndex(flatIndex${t===1?"":` / ${t}`}, value);
      }
      fn setOutputAtCoordsI32(${d.map(b=>`${b} : i32`).join(", ")}, value : ${Jt(t,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${m}(${d.join(", ")}));
        setOutputAtIndexI32(flatIndex${t===1?"":` / ${t}`}, value);
      }
    `}return u}function $r(n){const e=/(\w+)\s*:\s*vec(5|6)/g;n=n.replace(e,s=>"@align(16) "+s);const t=/vec(5|6)\s*,\s*(\w+)/g;return n=n.replace(t,(s,a,u)=>`vec${a}, @align(16) ${u}`),n}function Bo(n){return!(n.dispatchLayout.hasOwnProperty("y")&&n.dispatchLayout.y.length!==0||n.dispatchLayout.hasOwnProperty("z")&&n.dispatchLayout.z.length!==0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ho=n=>{let e=1;for(let t=0;t<n.length;t++)e*=n[t];return e};function Ha(n,e){if(n.length!==e.length)throw new Error(`Cannot compute whether rank ${n.length} tiles fit evenly into rank ${e.length} shape - ranks must match.`);return e.every((t,s)=>t%n[s]===0)}function Ut(n,e,t=[1,1,1],s=[1,1,1]){const[a,u,d]=[Math.ceil(ho(n.x.map(m=>e[m]))/(t[0]*s[0])),n.y?Math.ceil(ho(n.y.map(m=>e[m]))/(t[1]*s[1])):1,n.z?Math.ceil(ho(n.z.map(m=>e[m]))/(t[2]*s[2])):1];return[a,u,d]}function ta(n,e,t,s=!1){const a=[8,8,1],u=[4,4,1];return s||(n<=8&&(u[1]=1),e<=16&&t<=16&&(a[0]=4)),{workgroupSize:a,elementsPerThread:u}}function To(n,e,t=!1){if(t)return[8,8,1];const s=ho(n.x.map(u=>e[u])),a=ho(n.y.map(u=>e[u]));return s<=4?[4,16,1]:a<=4?[16,4,1]:[16,16,1]}function ma(n,e,t=!1){if(t)return[4,4,1];const s=ho(n.x.map(u=>e[u])),a=ho(n.y.map(u=>e[u]));return s<=4?[1,2,1]:a<=4?[2,1,1]:[2,2,1]}function Gt(n){return{x:n.map((e,t)=>t)}}function Nr(n){if(n==="float32"||n==="int32"||n==="bool"||n==="string")return 4;if(n==="complex64")return 8;throw new Error(`Unknown dtype ${n}`)}function ga(){return!!(typeof globalThis<"u"&&globalThis.navigator&&globalThis.navigator.gpu)}function mr(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&y.D5U.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGPU backend.`)})}var gr;(function(n){n[n.MatMulReduceProgram=0]="MatMulReduceProgram",n[n.MatMulSplitKProgram=1]="MatMulSplitKProgram",n[n.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",n[n.MatMulPackedProgram=3]="MatMulPackedProgram",n[n.MatMulMax=4]="MatMulMax"})(gr||(gr={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const na=(0,y.OBj)().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),h=(n,e)=>{const t=n.limits.maxComputeWorkgroupsPerDimension,s=e.dispatchLayout,a=e.dispatch;if(a.every(d=>d<=t))return a;y.D5U.assert(a[0]>t&&s.y===void 0&&s.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let u=Math.ceil(Math.sqrt(a[0]));return u>t?(u=Math.ceil(Math.cbrt(a[0])),y.D5U.assert(u<=t,()=>"Total dispatch size exceeds WebGPU maximum."),[u,u,u]):[u,u,1]};class N extends y.Zuw{nextDataId(){return N.nextDataId++}constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!ga())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new yt(t),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new At(this.device),this.textureManager=new Qt(this.device),this.tensorMap=new y.JLz(this,(0,y.SRH)()),(0,y.OBj)().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,t=!1){if(!this.tensorMap.has(e))return!0;const s=this.tensorMap.get(e);return t?s.refCount=0:s.refCount--,s.refCount>0?!1:(s.complexTensorInfos!=null&&(this.disposeData(s.complexTensorInfos.real.dataId),this.disposeData(s.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);if(!(!t||!t.resource)){if(t.external){t.resource=null;return}t.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(t.resource):t.resource instanceof GPUTexture&&this.textureManager.releaseTexture(t.resource),t.resource=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){const t=this.tensorMap.get(e);t.refCount++}decRef(e){if(this.tensorMap.has(e)){const t=this.tensorMap.get(e);t.refCount--}}write(e,t,s){if(s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={id:this.nextDataId()};return this.tensorMap.set(a,{dtype:s,shape:t,values:e,refCount:1}),a}move(e,t,s,a,u){if(a==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:a,shape:s,values:t,refCount:u})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(t){throw new Error(t.message)}Object.keys(this.pipelineCache).map((t,s)=>{this.pipelineCache[t]=e[s]})}async getBufferData(e){if((0,y.OBj)().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const t=e.size,s=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,t),this.submitQueue(),await s.mapAsync(GPUMapMode.READ);const a=s.getMappedRange().slice(0);return s.unmap(),s!=null&&this.bufferManager.releaseBuffer(s),(0,y.OBj)().getBool("WEBGPU_USE_PROFILE_TOOL")&&(y.D5U.assert(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),a}convertAndCacheOnCPU(e,t){const s=this.tensorMap.get(e);return s.values=t,s.values}readSync(e){const t=this.tensorMap.get(e),{values:s,complexTensorInfos:a}=t;if(s!=null||t.dtype==="string")return s;if(t.dtype==="complex64"){const ue=this.readSync(a.real.dataId),he=this.readSync(a.imag.dataId),Ue=y.D5U.convertBackendValuesAndArrayBuffer(y.Wap.mergeRealAndImagArrays(ue,he).buffer,"float32");return this.convertAndCacheOnCPU(e,Ue),Ue}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const u=["opaque","premultiplied"],d=t.resource,m=d.size;y.D5U.assert(m%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const b=m/4,T=new ArrayBuffer(m),k=256,R=256,B=u.map(ue=>new OffscreenCanvas(k,R)),X=new OffscreenCanvas(k,R);this.endComputePassEncoder(),B.map((ue,he)=>{const Ue=ue.getContext("webgpu");return Ue.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:u[he]}),Ue.getCurrentTexture()}).map((ue,he)=>{const Ue=k*4,Xe=(Mt,Bt,en)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:d,bytesPerRow:Ue,offset:en},{texture:ue},{width:Mt,height:Bt}),this.submitQueue();const hn=X.getContext("2d",{willReadFrequently:!0});hn.clearRect(0,0,Mt,Bt),hn.drawImage(B[he],0,0);const Nn=hn.getImageData(0,0,Mt,Bt).data,vn=u[he],On=new Uint8ClampedArray(T,en,Mt*Bt*4);for(let Qn=0;Qn<On.length;Qn+=4)if(vn==="premultiplied")On[Qn+3]=Nn[Qn+3];else{const ts=Nn[Qn];On[Qn]=Nn[Qn+2],On[Qn+1]=Nn[Qn+1],On[Qn+2]=ts}},ot=Math.floor(b/(k*R));let it=k,mt=R,wt=0;for(let Mt=0;Mt<ot;Mt++)Xe(it,mt,wt),wt+=k*R*4;const St=b%(k*R);mt=Math.floor(St/k),mt>0&&(Xe(it,mt,wt),wt+=mt*(k*4)),it=St%k,it>0&&Xe(it,1,wt)});const oe=y.D5U.convertBackendValuesAndArrayBuffer(T,t.dtype);return this.convertAndCacheOnCPU(e,oe),oe}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:s}=t;if(s!=null)return s;let a;if(t.dtype==="complex64"){const u=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),d=u[0],m=u[1];a=y.Wap.mergeRealAndImagArrays(d,m)}else{const u=await this.getBufferData(t.resource);a=y.D5U.convertBackendValuesAndArrayBuffer(u,t.dtype)}return this.convertAndCacheOnCPU(e,a),a}copyBuffer(e){const t=e.size,s=e.usage,a=this.bufferManager.acquireBuffer(t,s);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,a,0,t),this.submitQueue(),a}createTensorFromGPUData(e,t,s){let a=e.buffer;if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const u={id:this.nextDataId()};this.tensorMap.set(u,{dtype:s,shape:t,values:null,refCount:1,external:e.zeroCopy});const d=this.tensorMap.get(u),m=Nr(d.dtype)*y.D5U.sizeFromShape(d.shape);if(e.buffer.size<m)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${m})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return e.zeroCopy!==!0&&(a=this.copyBuffer(a)),d.resource=a,(0,y.SRH)().makeTensorFromDataId(u,t,s,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:s,dtype:a,shape:u,resource:d}=t;if(a==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(d==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const m=d,b=m.size,T=m.usage,k=this.bufferManager.acquireBuffer(b,T);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(d,0,k,0,b),this.submitQueue();const R=this.makeTensorInfo(u,a),B=(0,y.SRH)().makeTensorFromTensorInfo(R),X=this.tensorMap.get(R.dataId);return X.resource=k,{tensorRef:B,buffer:k}}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(a=>y.D5U.decodeString(a));return(0,y.f3b)(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,y.f3b)(e.shape,e.dtype,t)}async time(e){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const t=this.activeTimers,s=[];let a=!1;this.programTimersStack==null?(this.programTimersStack=s,a=!0):this.activeTimers.push(s),this.activeTimers=s,e();const u=y.D5U.flatten(this.activeTimers.map(T=>T.query)).filter(T=>T!=null),d=y.D5U.flatten(this.activeTimers.map(T=>T.name)).filter(T=>T!=null);this.activeTimers=t,a&&(this.programTimersStack=null);const m={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},b=await Promise.all(u);return m.kernelMs=y.D5U.sum(b),m.getExtraProfileInfo=()=>b.map((T,k)=>({name:d[k],ms:T})).map(T=>`${T.name}: ${T.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,m}makeTensorInfo(e,t,s){return t==="string"&&s!=null&&s.length>0&&y.D5U.isString(s[0])&&(s=s.map(u=>y.D5U.encodeString(u))),{dataId:this.write(s,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const s=this.tensorMap.get(e.dataId).resource;return s instanceof GPUBuffer?{buffer:s}:s instanceof GPUTexture?s.createView():s}uploadToGPU(e){const t=this.tensorMap.get(e);if(t.resource!=null)return;const s=Nr(t.dtype)*y.D5U.sizeFromShape(t.shape);let a;const u=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(t.values){if(a=this.bufferManager.acquireBuffer(s,u,!0),a.mapState==="unmapped"){const d=this.bufferManager.acquireBuffer(s,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),m=d.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(m).set(t.values):new Float32Array(m).set(t.values),d.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(d,0,a,0,s),this.stagingPendingDisposal.push(d)}else{const d=a.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(d).set(t.values):new Float32Array(d).set(t.values),a.unmap()}t.values=null}else a=this.bufferManager.acquireBuffer(s,u);t.resource=a}makeUniforms(e){let t=0,s=0;const a=[];let u=1;e.forEach(b=>{b.data.length===0&&(b.data=[1]);let T;switch(b.data.length){case 1:T=4;break;case 2:T=8;break;case 3:T=16;break;case 4:T=16;break;case 5:T=16;break;case 6:T=16;break;default:y.D5U.assert(!1,()=>`Unsupported ${b.data.length}D shape`)}(s===5||s===6)&&(T=16),T>u&&(u=T),t=Math.ceil(t/T)*T,s=b.data.length,a.push(t),t+=b.data.length*4}),t=Math.ceil(t/u)*u;const d=new ArrayBuffer(t);e.forEach((b,T)=>{const k=a[T];b.type==="int32"?new Int32Array(d,k,b.data.length).set(b.data):b.type==="uint32"?new Uint32Array(d,k,b.data.length).set(b.data):new Float32Array(d,k,b.data.length).set(b.data)});const m=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(m,0,d,0,t),this.uniformPendingDisposal.push(m),{offset:0,size:t,buffer:m}}runWebGPUProgram(e,t,s,a,u){if(u||(u=this.makeTensorInfo(e.outputShape,s)),y.D5U.sizeFromShape(u.shape)===0)return this.tensorMap.get(u.dataId).values=y.D5U.getTypedArrayFromDType(u.dtype,0),u;this.uploadToGPU(u.dataId),e.dispatch=h(this.device,e);const d=t.map((b,T)=>{if(b.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(b.dataId),{dtype:this.tensorMap.get(b.dataId).dtype,shape:b.shape,name:e.variableNames[T]}});e.shaderKey=Xr(e,d,u);const m=(0,y.OBj)().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=Pn(this.device,e,d,u,m)),e.pipeline=this.pipelineCache[e.shaderKey],m||this.recordAndSubmit(e,u,t,a),u}recordAndSubmit(e,t,s,a){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let u=[],d=[];const m="int32";if(e.pixelsOpType==null){u.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),d=s.concat(t).map(X=>X.shape);const B="int32";d.map(X=>{u.push({type:B,data:X});const oe=y.D5U.computeStrides(X);u.push({type:B,data:oe})})}else{const B=y.D5U.computeStrides(t.shape);u.push({type:m,data:B})}if(e.size){const B=y.D5U.sizeFromShape(e.outputShape);u.push({type:m,data:[e.outputComponent?B/e.outputComponent:B]})}a&&(u=[...u,...a]);const b=[this.tensorToBinding(t),...s.map(B=>this.tensorToBinding(B)),this.makeUniforms(u)];s.forEach(B=>{this.commandQueueOwnedIds.add(B.dataId)}),this.commandQueueOwnedIds.add(t.dataId);const T=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:b.map((B,X)=>({binding:X,resource:B}))}),k=this.activeTimers!=null;this.ensureCommandEncoderReady();const R={};k&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),R.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(R)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(R)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,T),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(k||(0,y.OBj)().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===pn.DRAW)&&(this.endComputePassEncoder(),k?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.querySetCount*8),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const t=new BigUint64Array(e.getMappedRange()),s=Number(t[1]-t[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),s}shouldExecuteOnCPU(e,t=na){return(0,y.OBj)().getBool("WEBGPU_CPU_FORWARD")&&e.every(s=>this.tensorMap.get(s.dataId).resource==null&&y.D5U.sizeFromShape(s.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}N.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ga()&&(0,y.jqO)("webgpu",async()=>{const n={powerPreference:(0,y.OBj)().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(n),t={},s=[];e.features.has("timestamp-query")&&s.push("timestamp-query"),e.features.has("bgra8unorm-storage")&&s.push(["bgra8unorm-storage"]),t.requiredFeatures=s;const a=e.limits;t.requiredLimits={maxComputeWorkgroupStorageSize:a.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:a.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:a.maxStorageBufferBindingSize,maxBufferSize:a.maxBufferSize,maxComputeWorkgroupSizeX:a.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:a.maxComputeInvocationsPerWorkgroup};const u=await e.requestDevice(t),d="info"in e?e.info:"requestAdapterInfo"in e?await e.requestAdapterInfo():void 0;return new N(u,d)},3);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var A;(function(n){n[n.ADD=0]="ADD",n[n.ATAN2=1]="ATAN2",n[n.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",n[n.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",n[n.DIV=4]="DIV",n[n.ELU_DER=5]="ELU_DER",n[n.EQUAL=6]="EQUAL",n[n.FLOOR_DIV=7]="FLOOR_DIV",n[n.GREATER=8]="GREATER",n[n.GREATER_EQUAL=9]="GREATER_EQUAL",n[n.LESS=10]="LESS",n[n.LESS_EQUAL=11]="LESS_EQUAL",n[n.LOGICAL_AND=12]="LOGICAL_AND",n[n.LOGICAL_OR=13]="LOGICAL_OR",n[n.MAX=14]="MAX",n[n.MIN=15]="MIN",n[n.MOD=16]="MOD",n[n.MUL=17]="MUL",n[n.NOT_EQUAL=18]="NOT_EQUAL",n[n.POW=19]="POW",n[n.PRELU=20]="PRELU",n[n.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",n[n.SUB=22]="SUB"})(A||(A={}));const Q="let resultTemp = a + b;",ge="let resultTemp = atan2(a, b);",ke="let resultTemp = areal * breal - aimag * bimag;",Ie="let resultTemp = areal * bimag + aimag * breal;",He="let resultTemp = a / b;",lt="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",Rt=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,zt=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,yn=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,an=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,Xt=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,xn=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,Tn="return f32(a >= 1.0 && b >= 1.0);",ss=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,Yn="return f32(a >= 1.0 || b >= 1.0);",gs=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,cr="let resultTemp = max(a, b);",Is="let resultTemp = min(a, b);",Fn=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,Es=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,os="let resultTemp = a * b;",Ta=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,$a=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,ya=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,jo=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,$o="if (a < 0.0) { return b * a; }  return a;",kr=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,Ko="let resultTemp = (a - b) * (a - b);",ii="let resultTemp = a - b;";function Na(n,e){let t;do{switch(n){case A.ATAN2:t=ge;break;case A.MAX:t=cr;break;case A.MIN:t=Is;break;case A.MOD:t=e?Es:Fn;break;case A.NOT_EQUAL:t=e?$a:Ta;break;case A.POW:t=e?jo:ya;break;default:continue}let s,a,u;return e?(s="isnanVec4",a="vec4<f32>",u="vec4<bool>"):(s="isnan",a="f32",u="bool"),`
      let aIsNaN = ${s}(a);
      let aPostLegalization = select(a, ${a}(42), aIsNaN);
      let bIsNaN = ${s}(b);
      let bPostLegalization = select(b, ${a}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${t}
        return select(
            resultTemp, ${a}(valueForNaN),
            ${u}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(n){case A.ADD:t=Q;break;case A.COMPLEX_MULTIPLY_IMAG:t=Ie;break;case A.COMPLEX_MULTIPLY_REAL:t=ke;break;case A.DIV:t=He;break;case A.ELU_DER:t=lt;break;case A.EQUAL:t=Rt;break;case A.FLOOR_DIV:t=zt;break;case A.GREATER:t=yn;break;case A.GREATER_EQUAL:t=an;break;case A.LESS:t=Xt;break;case A.LESS_EQUAL:t=xn;break;case A.LOGICAL_AND:return e?ss:Tn;case A.LOGICAL_OR:return e?gs:Yn;case A.MUL:t=os;break;case A.PRELU:return e?kr:$o;case A.SQUARED_DIFFERENCE:t=Ko;break;case A.SUB:t=ii;break;default:}return`
    ${t}
    return resultTemp;
  `}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ft;(function(n){n[n.ABS=0]="ABS",n[n.ACOS=1]="ACOS",n[n.ACOSH=2]="ACOSH",n[n.ASIN=3]="ASIN",n[n.ASINH=4]="ASINH",n[n.ATAN=5]="ATAN",n[n.ATANH=6]="ATANH",n[n.CEIL=7]="CEIL",n[n.COS=8]="COS",n[n.COSH=9]="COSH",n[n.ELU=10]="ELU",n[n.ERF=11]="ERF",n[n.EXP=12]="EXP",n[n.EXPM1=13]="EXPM1",n[n.FLOOR=14]="FLOOR",n[n.IS_FINITE=15]="IS_FINITE",n[n.IS_INF=16]="IS_INF",n[n.IS_NAN=17]="IS_NAN",n[n.LINEAR=18]="LINEAR",n[n.LOG=19]="LOG",n[n.LOG1P=20]="LOG1P",n[n.LOGICAL_NOT=21]="LOGICAL_NOT",n[n.NEG=22]="NEG",n[n.RELU=23]="RELU",n[n.RELU6=24]="RELU6",n[n.LEAKYRELU=25]="LEAKYRELU",n[n.RECIPROCAL=26]="RECIPROCAL",n[n.ROUND=27]="ROUND",n[n.RSQRT=28]="RSQRT",n[n.SELU=29]="SELU",n[n.SIGMOID=30]="SIGMOID",n[n.SIGN=31]="SIGN",n[n.SIN=32]="SIN",n[n.SINH=33]="SINH",n[n.SOFTPLUS=34]="SOFTPLUS",n[n.SQRT=35]="SQRT",n[n.SQUARE=36]="SQUARE",n[n.STEP=37]="STEP",n[n.TAN=38]="TAN",n[n.TANH=39]="TANH",n[n.TO_INT=40]="TO_INT"})(Ft||(Ft={}));const ja="return abs(a);",Yr=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,yr=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,ui=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,Ka="return asinh(a);",Vi=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,li=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,ci="return ceil(a);",di="return cos(a);",No=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,hi="return exp(a) - 1.0;",Xa="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",ka=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,pi=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${y.Wap.ERF_P};
  let a1 = ${y.Wap.ERF_A1};
  let a2 = ${y.Wap.ERF_A2};
  let a3 = ${y.Wap.ERF_A3};
  let a4 = ${y.Wap.ERF_A4};
  let a5 = ${y.Wap.ERF_A5};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,Ya="return exp(a);",U="return floor(a);",E="return f32(!isnan(a) && !isinf(a));",z="return f32(isinf(a));",q="return f32(isnan(a));",se="return a;",_e=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,Me=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,et="return f32(!(a >= 1.0));",bt="return -a;",It="if (a < 0.0) { return uniforms.alpha * a; } return a;",sn=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,_t="return 1.0 / a;",Tt="return select(a, 0.0, a < 0.0);",Kt="return clamp(a, 0.0, 6.0);",$n="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",qn=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,es="return round(a);",Vs="return inverseSqrt(a);",xa=`
  if (a >= 0.0) {
    return ${y.Wap.SELU_SCALE} * a;
  } else {
    return ${y.Wap.SELU_SCALEALPHA} * (exp(a) - 1.0);
  }
`,un="return 1.0 / (1.0 + exp(-1.0 * a));",Ts="return sign(a);",rs="return sin(a);",qa=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,po=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,Ra="return sqrt(a);",fo="return a * a;",sa=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,Xo="return tan(a);",Da=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,zi="return f32(i32((a)));";function Yo(n,e){switch(n){case Ft.ABS:return ja;case Ft.ACOS:return Yr;case Ft.ACOSH:return yr;case Ft.ASIN:return ui;case Ft.ASINH:return Ka;case Ft.ATAN:return Vi;case Ft.ATANH:return li;case Ft.COS:return di;case Ft.COSH:return No;case Ft.CEIL:return ci;case Ft.ELU:return e?ka:Xa;case Ft.ERF:return pi;case Ft.EXP:return Ya;case Ft.EXPM1:return hi;case Ft.FLOOR:return U;case Ft.IS_FINITE:return E;case Ft.IS_INF:return z;case Ft.IS_NAN:return q;case Ft.LINEAR:return se;case Ft.LOG:return _e;case Ft.LOG1P:return Me;case Ft.LOGICAL_NOT:return et;case Ft.NEG:return bt;case Ft.LEAKYRELU:return e?sn:It;case Ft.RECIPROCAL:return _t;case Ft.RELU:return e?qn:Tt;case Ft.RELU6:return e?$n:Kt;case Ft.ROUND:return es;case Ft.RSQRT:return Vs;case Ft.SELU:return xa;case Ft.SIGMOID:return un;case Ft.SIGN:return Ts;case Ft.SIN:return rs;case Ft.SINH:return qa;case Ft.SOFTPLUS:return po;case Ft.SQRT:return Ra;case Ft.SQUARE:return fo;case Ft.STEP:return sa;case Ft.TAN:return Xo;case Ft.TANH:return Da;case Ft.TO_INT:return zi;default:throw new Error(`BinaryType ${n} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mo(n,e=!1,t=!1,s=3){if(n===null)return"";let a="";if(n==="linear")a=Yo(Ft.LINEAR);else if(n==="relu")a=Yo(Ft.RELU,t);else if(n==="elu")a=Yo(Ft.ELU,t);else if(n==="relu6")a=Yo(Ft.RELU6,t);else if(n==="prelu")a=Na(A.PRELU,t);else if(n==="sigmoid")a=Yo(Ft.SIGMOID,t);else if(n==="leakyrelu")a=Yo(Ft.LEAKYRELU,t);else throw new Error(`Activation ${n} has not been implemented for the WebGPU backend.`);const d=Jt(t?4:1);let m="";return e?m=`
      fn activation(a : ${d}, coords : vec${s}<i32>) -> ${d} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${a}
      }`:m=`
      fn activation(a : ${d}, coords : vec${s}<i32>) -> ${d} {
        ${a}
      }`,m}function Lo(n,e){return`
      ${n?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ra(n,e,t=!1,s=!1,a=!1,u=1){y.D5U.assert(n&&u===1||!n,()=>`transposeA ${n} is not compatible with component size ${u}`);const d=`
      ${n?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,m=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${Jt(u)} {
    var value = ${Jt(u)}(0.0);
    ${t&&a?d:`
    ${n?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${d}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${Jt(u)} {
    var value = ${Jt(u)}(0.0);
    ${m}
    return value;
  }
  `}function Bn(n,e,t,s,a=!1,u=!1,d=!1,m=1){return`
  ${ra(t,s,a,u,d,m)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${Jt(m)}) {
    ${a&&u?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Lo(n,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const sr=(n,e)=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${e});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${e});
        `,Qa=(n,e,t,s)=>{if(n)return`
      for (var k = 0; k < ${s}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${t}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let a="",u="";for(let d=0;d<e;d++)a+=`let BCached${d} = mm_Bsub[k * ${e} + ${d}][tileCol];`,u+=`acc[i] = fma(BCached${d}, vec4<f32>(ACached[${d}]), acc[i]);`;return`
      for (var k = 0; k < ${s/e}; k++) {
        ${a}
        for (var i = 0; i < ${t}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${u}
        }
      }`}};function oa(n,e,t=!1,s=32,a=!1,u=32,d=!1){const m=e[1]*n[1],b=e[0]*n[0],T=t?m:s,k=t?s:m,R=T/e[0],B=s/e[1],X=n[1],oe=n[0];return y.D5U.assert((t&&R===4&&n[1]===4||!t&&(R===3||R===4))&&T%e[0]===0&&s%e[1]===0&&n[0]===4,()=>`If transposeA ${t} is true, innerElementSize ${R} and workPerThread[1] ${n[1]} must be 4.
          Otherwise, innerElementSize ${R} must be 3 or 4.
      tileAWidth ${T} must be divisible by workgroupSize[0]${e[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${n[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${R}<f32>, ${T/R}>, ${k}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${b/n[0]}>, ${s}>;

  ${kt()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${X};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${X};
    let globalCol = i32(globalId.x) * ${oe};
    let batch = ${a?"0":"i32(globalId.z)"};
    let batchA = ${a||!d?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${a||!d?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${m};

    let numTiles = ${a?`${Math.ceil(u/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
    var kStart = ${a?`i32(globalId.z) * ${u}`:"0"};

    var acc: array<vec4<f32>, ${X}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${B};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${X}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${sr(t,R)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${B}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${Qa(t,R,X,s)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${X}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const fi=n=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,Gi=n=>n?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function _a(n,e,t=!1,s=32,a=!1,u=32,d=!1,m=!1){const b=n[1]*e[1],T=n[0]*e[0],k=t?b:s,R=t?s:b;y.D5U.assert(R%e[1]===0&&k%e[0]===0&&s%e[1]===0,()=>`tileAHight ${R} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${k} must be divisible by workgroupSize[0]${e[0]}, tileInner ${s} must be divisible by workgroupSize[1]${e[1]}`);const B=R/e[1],X=k/e[0],oe=s/e[1],ue=n[1],he=n[0],Ue=d?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${b};
      let globalColStart = i32(workgroupId.x) * ${T};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${R}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${k}; inputCol = inputCol + ${e[0]}) {
            ${fi(t)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${T}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${he}>;
        for (var k = 0; k < ${s}; k++) {
          for (var inner = 0; inner < ${he}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${ue}; innerRow++) {
            let ACached = ${t?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${he}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${ue}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${he}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${ue};
  let tileCol = i32(localId.x) * ${he};

  let globalRow = i32(globalId.y) * ${ue};
  let globalCol = i32(globalId.x) * ${he};
  let globalRowStart = i32(workgroupId.y) * ${b};

  let tileRowA = i32(localId.y) * ${B};
  let tileColA = i32(localId.x) * ${X};
  let tileRowB = i32(localId.y) * ${oe};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${B}; innerRow++) {
      for (var innerCol = 0; innerCol < ${X}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${fi(t)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${oe}; innerRow++) {
      for (var innerCol = 0; innerCol < ${he}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${s};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${he}>;
    for (var k = 0; k < ${s}; k++) {
      for (var inner = 0; inner < ${he}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${ue}; innerRow++) {
        ${Gi(t)}
        for (var innerCol = 0; innerCol < ${he}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${ue}; innerRow++) {
    for (var innerCol = 0; innerCol < ${he}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${k}>, ${R}>;
    var<workgroup> mm_Bsub : array<array<f32, ${T}>, ${s}>;

    ${kt()} {
      let batch = ${a?"0":"i32(globalId.z)"};
      let batchA = ${a||!m?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${a||!m?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${a?`${Math.ceil(u/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
      var kStart = ${a?`i32(globalId.z) * ${u}`:"0"};

      var acc : array<array<f32, ${he}>, ${ue}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${ue}; innerRow++) {
        for (var innerCol = 0; innerCol < ${he}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${Ue}
    }
  `}const mi=n=>n?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function _u(n,e=!1){y.D5U.assert(n[1]===1&&n[2]===1,()=>`A linear work group size is required. But got ${n}.`);const t=n[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${n[0]}>;

    ${kt()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${t} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${t} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${mi(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${t/4}; k++) {
          let rowB = t * ${t} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}class Au{constructor(e,t,s=!1,a=!1,u=null,d=null,m=null,b=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const T=s?e[1]:e[2];if(this.isVec4=(T%4===0&&!s||t[1]%4===0&&s)&&t[2]%4===0&&!a,this.outputComponent=this.isVec4?4:1,this.isVectorA=t[1]===1&&!s,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const B=ta(t[1],T,t[2],s);this.workgroupSize=B.workgroupSize,this.elementsPerThread=B.elementsPerThread}this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const k=u!=null,R=m!=null;k&&this.variableNames.push("bias"),R&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=b,this.transposeA=s,this.transposeB=a,this.addBias=k,this.activation=d,this.hasPreluActivationWeights=R,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],T),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${s}_${a}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,s){const a=this.workgroupSize[1]*this.elementsPerThread[1],u=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=u;const d=e%a===0,m=t%u===0,b=s%this.tileInner===0;return[d,m,b]}getUserCode(){return`
      ${mo(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${Bn(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?oa(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?_u(this.workgroupSize,this.transposeA):_a(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ht(n){return`
    var<workgroup> sumValues : array<f32, ${n}>;
    ${kt()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${n}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${n/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class Pu{constructor(e,t=!1,s=!1,a=null,u=null,d=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize);const m=a!=null,b=d!=null;m&&this.variableNames.push("bias"),b&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=s,this.addBias=m,this.activation=u,this.hasPreluActivationWeights=b,this.shaderKey=`matMulReduce_${this.activation}_${t}_${s}`}getUserCode(){return`
      ${mo(this.activation,this.hasPreluActivationWeights)}
      ${Bn(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${Ht(this.workgroupSize[0])}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hi(n){const e=n[1],t=n[0],s=e>t?e:t;return`
  var<workgroup> mm_Asub : array<array<f32, ${s}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${t}>, ${s}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${kt()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${s} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${s};
    globalRowB = globalRowB + ${s};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${s};
      globalRowB = globalRowB + ${s};

      for (var k = 0; k < ${s}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class Ou{constructor(e,t,s,a=!1,u=!1,d=null,m=null,b=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=s,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(s[2]/this.workgroupSize[0]),Math.ceil(s[1]/this.workgroupSize[1]),s[0]];const T=d!=null;T&&this.variableNames.push("bias");const k=b!=null;k&&this.variableNames.push("preluActivationWeights"),this.transposeA=a,this.transposeB=u,this.addBias=T,this.activation=m,this.hasPreluActivationWeights=k,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${a}_${u}`}getUserCode(){return`
      ${mo(this.activation,this.hasPreluActivationWeights)}
      ${Bn(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${Hi(this.workgroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gi{constructor(e,t,s=!1,a=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,y.D5U.assert(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const u=(s&&this.outputShape[1]%4===0||!s&&t%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=u?4:1,u||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=Ut(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=s,this.transposeB=a,this.shaderKey=`matMulSplitK_${s}_${a}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`
      ${ra(!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${Jt(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${fn("&result[flatIndex + i]",`${e>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${e===4?oa(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):_a(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class aa{constructor(e,t=null,s=null,a=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t!=null,this.hasPreluActivationWeights=a!=null,this.activation=s,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${s}`}getUserCode(){return`
    ${mo(this.activation,this.hasPreluActivationWeights)}
    ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Lo(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fu{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${kt("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zs(n){const{backend:e,attrs:t}=n,{shape:s,value:a}=t;let{dtype:u}=t;if(u=u||y.D5U.inferDtype(a),u==="string"){const d=y.D5U.getArrayFromDType(u,y.D5U.sizeFromShape(s));return d.fill(a),e.makeTensorInfo(s,u,d)}else{const d=new Fu(s),m=[{type:"float32",data:[a]}];return e.runWebGPUProgram(d,[],u,m)}}const Bu={kernelName:y.deh,backendName:"webgpu",kernelFunc:zs};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zt(n){const{inputs:e,attrs:t}=n,{x:s}=e,{shape:a}=t,u=y.D5U.sizeFromShape(s.shape),d=y.D5U.inferFromImplicitShape(a,u),m=y.D5U.sizeFromShape(d);return y.D5U.assert(u===m,()=>`The new shape (${d}) has ${m} elements and the old shape (${s.shape}) has ${u} elements. The new shape and old shape must have the same number of elements.`),n.backend.incRef(s.dataId),{dataId:s.dataId,shape:d,dtype:s.dtype}}const Lu={kernelName:y.HZH,backendName:"webgpu",kernelFunc:Zt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ia({a:n,b:e,transposeA:t,transposeB:s,backend:a,bias:u=null,preluActivationWeights:d=null,leakyreluAlpha:m=0,activation:b=null}){const T=n.shape.length,k=e.shape.length,R=t?n.shape[T-2]:n.shape[T-1],B=s?e.shape[k-1]:e.shape[k-2],X=t?n.shape[T-1]:n.shape[T-2],oe=s?e.shape[k-2]:e.shape[k-1],ue=n.shape.slice(0,-2),he=e.shape.slice(0,-2),Ue=y.D5U.sizeFromShape(ue),Xe=y.D5U.sizeFromShape(he),it=y.Jyw.assertAndGetBroadcastShape(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([X,oe]);y.D5U.assert(R===B,()=>`Error in matMul: inner shapes (${R}) and (${B}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const mt=t?[Ue,R,X]:[Ue,X,R],wt=s?[Xe,oe,B]:[Xe,B,oe],St=Zt({inputs:{x:n},backend:a,attrs:{shape:mt}}),Mt=Zt({inputs:{x:e},backend:a,attrs:{shape:wt}}),Bt=[St,Mt],en=Math.max(Ue,Xe),hn=[St,Mt],Nn=[{type:"int32",data:[X]},{type:"int32",data:[oe]},{type:"int32",data:[R]}];let vn,On;const Qn=[en,X,oe];let ts=(0,y.OBj)().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(ts<0){const Wo=(0,y.OBj)().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),Vo=Wo>0?Wo:a.thresholdToIncreaseWorkgroups,ai=en*Math.ceil(X/32)*Math.ceil(oe/32);ai<=Vo||X<=8&&ai<=Vo*2?en*X*oe<=128?ts=gr.MatMulReduceProgram:en===1&&B>=2e3?ts=gr.MatMulSplitKProgram:ts=gr.MatMulSmallOutputSizeProgram:ts=gr.MatMulPackedProgram}switch(ts){case gr.MatMulReduceProgram:vn=new Pu(Qn,t,s,u,b,d);break;case gr.MatMulSplitKProgram:{if(On=zs({backend:a,attrs:{shape:Qn,value:0,dtype:n.dtype}}),vn=new gi(Qn,B,t,s),u||b){On=a.runWebGPUProgram(vn,hn,n.dtype,Nn,On);const Vo=new aa(On.shape,u,b,d);let ai=null;const Ga=[On];u&&Ga.push(u),d&&Ga.push(d),b==="leakyrelu"&&(ai=[{type:"float32",data:[m]}],Vo.uniforms+=" alpha : f32,");const cg=a.runWebGPUProgram(Vo,Ga,On.dtype,ai);Bt.push(On);const Pg=Zt({inputs:{x:cg},backend:a,attrs:{shape:it}});Bt.push(cg);for(const Og of Bt)a.disposeData(Og.dataId);return Pg}break}case gr.MatMulSmallOutputSizeProgram:vn=new Ou(mt,wt,Qn,t,s,u,b,d);break;case gr.MatMulPackedProgram:const Wo=a.adapterInfo.isIntel();vn=new Au(mt,Qn,t,s,u,b,d,Wo);break;default:throw new Error(`Unsupported MatMulProgramType ${ts}.`)}u&&hn.push(u),d&&hn.push(d),b==="leakyrelu"&&(Nn.push({type:"float32",data:[m]}),vn.uniforms+=" alpha : f32,"),On=a.runWebGPUProgram(vn,hn,n.dtype,Nn,On);const xo=Zt({inputs:{x:On},backend:a,attrs:{shape:it}});Bt.push(On);for(const Wo of Bt)a.disposeData(Wo.dataId);return xo}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yi(n){const{inputs:e,backend:t,attrs:s}=n,{a,b:u,bias:d,preluActivationWeights:m}=e,{transposeA:b,transposeB:T,activation:k,leakyreluAlpha:R}=s;return ia({a,b:u,transposeA:b,transposeB:T,backend:t,bias:d,preluActivationWeights:m,leakyreluAlpha:R,activation:k})}const dr={kernelName:y.usg,backendName:"webgpu",kernelFunc:yi};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ji{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=y.Wap.assertAndGetBroadcastShape(t,s),this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${Na(this.op,!1)}
      }

      ${kt("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class go{constructor(e,t,s){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=y.Wap.assertAndGetBroadcastShape(t,s),this.dispatchLayout=Gt(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&s.length>1&&t[0]<128,this.useSharedMemoryWithB=s.length<=1&&t.length>1&&s[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?s[0]:t[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const a=t.length>0&&t[t.length-1]%4===0,u=s.length>0&&s[s.length-1]%4===0;a&&u?(this.outputComponent=4,this.variableComponents=[4,4]):a&&(y.D5U.isScalarShape(s)||s[s.length-1]===1)||u&&(y.D5U.isScalarShape(t)||t[t.length-1]===1)?(this.outputComponent=4,this.variableComponents=a?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const t=this.outputComponent===4?"vec4<f32>":"f32",s=`
    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {
      ${Na(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const a=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",u=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${a}];`:`let a = sharedBuf[${a}];
          let b = getBByOutputIndex(index);`;e=`
        ${s}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${kt("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${u}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${s}
       ${kt("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${t}(getAByOutputCoords(coords));
           let b = ${t}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rr(n){const{inputs:e}=n,{x:t}=e;return n.backend.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}const Uu={kernelName:y.iJz,backendName:"webgpu",kernelFunc:rr};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ua(n){const{inputs:e,backend:t}=n,{real:s,imag:a}=e,u=t.makeTensorInfo(s.shape,"complex64"),d=t.tensorMap.get(u.dataId),m=rr({inputs:{x:s},backend:t}),b=rr({inputs:{x:a},backend:t});return d.complexTensorInfos={real:m,imag:b},u}const Ki={kernelName:y.Zz9,backendName:"webgpu",kernelFunc:ua};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ba{constructor(e,t,s=""){this.variableNames=["A"],this.size=!0;const a=128;this.workgroupSize=[a,1,1],this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,s!==""&&(this.uniforms=s),this.shaderKey=`unary_${t}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${Yo(this.op,!1)}
      }
      ${kt("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vn({opType:n,cpuKernelImpl:e,dtype:t}){return({inputs:s,backend:a})=>{const{x:u}=s,d=a,m=t||u.dtype;if(d.shouldExecuteOnCPU([u])&&e!=null){const T=d.tensorMap.get(u.dataId),k=e(T.values,m);return d.makeTensorInfo(u.shape,m,k)}const b=new ba(u.shape,n);return d.runWebGPUProgram(b,[u],m)}}function Gs({opType:n,cpuKernelImpl:e,supportsComplex:t=!1,dtype:s}){return({inputs:a,backend:u})=>{const{a:d,b:m}=a,b=u;if(t&&d.dtype==="complex64"){const R=b.tensorMap.get(d.dataId),B=b.tensorMap.get(m.dataId);let X,oe;if(n!==A.MUL)[X,oe]=[[R.complexTensorInfos.real,B.complexTensorInfos.real],[R.complexTensorInfos.imag,B.complexTensorInfos.imag]].map(he=>{const[Ue,Xe]=he,ot={dataId:Ue.dataId,dtype:Ue.dtype,shape:d.shape},it={dataId:Xe.dataId,dtype:Xe.dtype,shape:m.shape},mt=new go(n,d.shape,m.shape);return b.runWebGPUProgram(mt,[ot,it],(0,y.x8V)(Ue.dtype,Xe.dtype))});else{const he=new ji(A.COMPLEX_MULTIPLY_REAL,d.shape,m.shape),Ue=new ji(A.COMPLEX_MULTIPLY_IMAG,d.shape,m.shape),Xe=[{dataId:R.complexTensorInfos.real.dataId,dtype:R.complexTensorInfos.real.dtype,shape:d.shape},{dataId:R.complexTensorInfos.imag.dataId,dtype:R.complexTensorInfos.imag.dtype,shape:d.shape},{dataId:B.complexTensorInfos.real.dataId,dtype:B.complexTensorInfos.real.dtype,shape:m.shape},{dataId:B.complexTensorInfos.imag.dataId,dtype:B.complexTensorInfos.imag.dtype,shape:m.shape}];X=b.runWebGPUProgram(he,Xe,"float32"),oe=b.runWebGPUProgram(Ue,Xe,"float32")}const ue=ua({inputs:{real:X,imag:oe},backend:b});return b.disposeData(X.dataId),b.disposeData(oe.dataId),ue}const T=s||(0,y.x8V)(d.dtype,m.dtype);if((d.dtype==="string"||m.dtype==="string"||b.shouldExecuteOnCPU([d,m]))&&e!=null){const R=b.tensorMap.get(d.dataId).values,B=b.tensorMap.get(m.dataId).values,X=d.dtype==="string"?y.Wap.fromUint8ToStringArray(R):R,oe=d.dtype==="string"?y.Wap.fromUint8ToStringArray(B):B,[ue,he]=e(d.shape,m.shape,X,oe,T);return b.makeTensorInfo(he,T,ue)}const k=new go(n,d.shape,m.shape);return b.runWebGPUProgram(k,[d,m],T)}}var Mu=L(1172);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:Wu,castImpl:Xi,ceilImpl:Vu,concatImpl:zu,equalImpl:Yi,expImpl:Gu,expm1Impl:Hu,floorImpl:ju,floorDivImpl:Ku,gatherNdImpl:Za,gatherV2Impl:Xu,greaterEqualImpl:Yu,greaterImpl:qu,lessEqualImpl:Qu,lessImpl:Zu,logImpl:Ju,maxImpl:el,maximumImpl:qi,minimumImpl:Qi,multiplyImpl:Zi,negImpl:tl,notEqualImpl:nl,prodImpl:sl,rangeImpl:rl,rsqrtImpl:ol,scatterImpl:al,simpleAbsImpl:il,sliceImpl:xi,stridedSliceImpl:ul,stringNGramsImpl:Ja,subImpl:ll,tileImpl:Ji,topKImpl:cl,transposeImpl:Aa,uniqueImpl:od}=Mu;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bi=Vn({opType:Ft.ABS,cpuKernelImpl:il}),dl={kernelName:y.SYM,backendName:"webgpu",kernelFunc:bi};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eu=Vn({opType:Ft.ACOS}),hl={kernelName:y.VGw,backendName:"webgpu",kernelFunc:eu};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wi=Vn({opType:Ft.ACOSH}),Pa={kernelName:y.SpW,backendName:"webgpu",kernelFunc:wi};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const la=Gs({opType:A.ADD,cpuKernelImpl:Wu,supportsComplex:!0}),pl={kernelName:y.mm_,backendName:"webgpu",kernelFunc:la};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fl{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((t,s)=>`T${s}`),this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(a=>{e.push(`let v${a} = get${a}ByOutputCoords(coords);`)});const t=this.variableNames.map(a=>`v${a}`).join(" + ");return`
      ${kt("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${t});
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ml(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return rr({inputs:{x:s[0]},backend:t});const a=s.map(m=>m.dtype).reduce((m,b)=>(0,y.x8V)(m,b)),u=s.map(m=>m.shape),d=new fl(u);return t.runWebGPUProgram(d,s,a)}const gl={kernelName:y.Xze,backendName:"webgpu",kernelFunc:ml};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yl{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[t[a]];this.outputShape=s,this.dispatchLayout={x:[0],y:[1]},this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){y.D5U.assert(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${kt()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vi{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[t[a]];this.outputShape=s,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){const e=Cn(this.outputShape.length),t=wa(this.newDim);return`
      ${kt("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `}}function wa(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=new Array(e);for(let s=0;s<n.length;s++)t[n[s]]=`coords.${Hn(s)}`;return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ds(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{perm:u}=s,d=t,m=a.shape.length,b=new Array(m);for(let k=0;k<b.length;k++)b[k]=a.shape[u[k]];if(t.shouldExecuteOnCPU([a])){const R=d.tensorMap.get(a.dataId).values,B=Aa(R,a.shape,a.dtype,u,b);return t.makeTensorInfo(b,a.dtype,B)}if(a.shape.length===2&&y.D5U.arraysEqual(u,[1,0])){const k=new yl(a.shape,u);return d.runWebGPUProgram(k,[a],a.dtype)}const T=new vi(a.shape,u);return d.runWebGPUProgram(T,[a],a.dtype)}const Oa={kernelName:y.G3Y,backendName:"webgpu",kernelFunc:Ds};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xl{constructor(e,t,s){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[a]=y.Wap.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=a.length===0?[1]:a,e.inSize>=32768&&s>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";const s=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,t="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",t="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const a=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${s}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${kt("index")} {
         let outputIndex = index / ${s};
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${s}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${s}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${s}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${a}
        }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bl={mean:"float32",all:"bool",any:"bool"};function ca(n,e,t,s,a){const u=n.shape.length,d=[],m=y.D5U.parseAxisParam(e,n.shape);let b=m;const T=y.Wap.getAxesPermutation(b,u);let k=n;T!=null&&(k=Ds({inputs:{x:n},attrs:{perm:T},backend:a}),b=y.Wap.getInnerMostAxes(b.length,u),d.push(k)),y.Wap.assertAxesAreInnerMostDims(s,b,u);const[R,B]=y.Wap.computeOutAndReduceShapes(k.shape,b);let X=R;t&&(X=y.Wap.expandShapeToKeepDim(R,m));let oe;if((s==="max"||s==="prod")&&a.shouldExecuteOnCPU([k])){const ue=a.tensorMap.get(k.dataId).values;switch(s){case"max":const he=el(ue,y.D5U.sizeFromShape(B),X,n.dtype);oe=a.makeTensorInfo(X,n.dtype,he);break;case"prod":const{outVals:Ue,outShape:Xe,outDtype:ot}=sl(k.shape,k.dtype,ue,b);oe=a.makeTensorInfo(Xe,ot,Ue);break;default:throw new Error(`${s} CPU implementation is not yet supported.`)}}else{const ue=y.D5U.sizeFromShape(B),Ue=y.D5U.sizeFromShape(k.shape)/ue,Xe={windowSize:ue,inSize:ue,batchSize:Ue,outSize:1},ot=bl[s]||(0,y.z4k)(n.dtype),it=[{type:"int32",data:[ue]}],mt=new xl(Xe,s,a.device.limits.maxComputeWorkgroupSizeX),wt=a.runWebGPUProgram(mt,[k],ot,it);d.push(wt),oe=Zt({inputs:{x:wt},attrs:{shape:X},backend:a})}return d.forEach(ue=>a.disposeData(ue.dataId)),oe}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wl(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{keepDims:u,axis:d}=s;return ca(a,d,u,"all",t)}const tu={kernelName:y.oT6,backendName:"webgpu",kernelFunc:wl};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vl(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{keepDims:u,axis:d}=s;return ca(a,d,u,"any",t)}const Cl={kernelName:y.IKK,backendName:"webgpu",kernelFunc:vl};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nu{constructor(e,t,s){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const a=[t];this.op=s==="min"?"<":">";const[u,d]=y.Wap.computeOutAndReduceShapes(e,a);this.outputShape=u.length===0?[1]:u,this.dispatchLayout=Gt(this.outputShape),y.D5U.sizeFromShape(d)<32?(this.type="plain",this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=Ut(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],t=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${Hn(this.inputShape.length-1)}`,s=()=>{let a="";if(this.outputShape.length===1)this.inputShape.length!==1&&(a+="outputCoords,");else for(let u=0;u<this.outputShape.length;u++)a+=`outputCoords.${Hn(u)},`;return a};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${kt("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${t()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${s()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${kt("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${s()} 0);
          let reduceLength = ${t()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${s()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ci(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{axis:u}=s;let d=y.D5U.parseAxisParam(u,a.shape);const m=y.Wap.getAxesPermutation(d,a.shape.length);let b=a;const T=[];m!=null&&(b=Ds({inputs:{x:a},backend:t,attrs:{perm:m}}),T.push(b),d=y.Wap.getInnerMostAxes(d.length,b.shape.length)),y.Wap.assertAxesAreInnerMostDims("argMax",[d[0]],b.shape.length);const k=new nu(b.shape,d[0],"max"),R=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],B=t.runWebGPUProgram(k,[b],"int32",R);return T.forEach(X=>t.disposeData(X.dataId)),B}const Sl={kernelName:y.sJF,backendName:"webgpu",kernelFunc:Ci};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Il(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{axis:u}=s;let d=y.D5U.parseAxisParam(u,a.shape);const m=y.Wap.getAxesPermutation(d,a.shape.length);let b=a;const T=[];m!=null&&(b=Ds({inputs:{x:a},backend:t,attrs:{perm:m}}),T.push(b),d=y.Wap.getInnerMostAxes(d.length,b.shape.length)),y.Wap.assertAxesAreInnerMostDims("argMin",[d[0]],b.shape.length);const k=new nu(b.shape,d[0],"min"),R=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],B=t.runWebGPUProgram(k,[b],"int32",R);return T.forEach(X=>t.disposeData(X.dataId)),B}const El={kernelName:y.aJk,backendName:"webgpu",kernelFunc:Il};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const va=Vn({opType:Ft.ASIN}),Tl={kernelName:y.M2y,backendName:"webgpu",kernelFunc:va};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $l=Vn({opType:Ft.ASINH}),Nl={kernelName:y.qw7,backendName:"webgpu",kernelFunc:$l};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Si=Vn({opType:Ft.ATAN}),kl={kernelName:y.jMg,backendName:"webgpu",kernelFunc:Si};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rl=Gs({opType:A.ATAN2}),Dl={kernelName:y.QCc,backendName:"webgpu",kernelFunc:Rl};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _l=Vn({opType:Ft.ATANH}),su={kernelName:y.Oyi,backendName:"webgpu",kernelFunc:_l};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Al{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fa{constructor(e,t,s=!1,a=!1,u=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=s,this.flattenPositions=a,this.includeBatchIndex=u,this.shaderKey=`pool2D_${t}_${s}_${a}_${u}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}}class Ii{constructor(e,t,s=!1,a=!1,u=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=s,this.flattenPositions=a,this.includeBatchIndex=u,this.shaderKey=`pool3D_${t}_${s}_${a}_${u}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue += value; count += 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ei(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{reductionIndices:u,keepDims:d}=s;return ca(a,u,d,"max",t)}const Ti={kernelName:y.YoZ,backendName:"webgpu",kernelFunc:Ei};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ca(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{keepDims:u,axis:d}=s;return ca(a,d,u,"mean",t)}const Pl={kernelName:y.q2K,backendName:"webgpu",kernelFunc:Ca};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ru(n,e,t,s){if(e.filterWidth===1&&e.filterHeight===1&&y.D5U.arraysEqual(e.inShape,e.outShape))return rr({inputs:{x:n},backend:s});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){const d=n.shape.length,m=Zt({inputs:{x:n},backend:s,attrs:{shape:[n.shape[d-3]*n.shape[d-2],n.shape[d-1]]}});let b;t==="avg"?b=Ca({inputs:{x:m},backend:s,attrs:{axis:0,keepDims:!1}}):(y.D5U.assert(t==="max",()=>`Invalid pool type ${t}`),b=Ei({inputs:{x:m},backend:s,attrs:{reductionIndices:0,keepDims:!1}}));const T=Zt({inputs:{x:b},backend:s,attrs:{shape:e.outShape}});return s.disposeData(m.dataId),s.disposeData(b.dataId),T}let a;const u=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?a=new Al(e):(t==="avg"?a=new Fa(e,"avg"):(y.D5U.assert(t==="max",()=>`Invalid pool type ${t}`),a=new Fa(e,"max")),u.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),s.runWebGPUProgram(a,[n],n.dtype,u)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ol(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{filterSize:u,strides:d,pad:m,dimRoundingMode:b}=s,k=y.Wap.computePool2DInfo(a.shape,u,d,1,m,b);return ru(a,k,"avg",t)}const $i={kernelName:y.JhU,backendName:"webgpu",kernelFunc:Ol};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fl(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{filterSize:u,strides:d,pad:m,dataFormat:b,dimRoundingMode:T}=s,k=[1,1,1],R=y.Wap.computePool3DInfo(a.shape,u,d,k,m,T,b),B=new Ii(R,"avg"),X=[{type:"int32",data:[R.strideDepth,R.strideHeight,R.strideWidth]},{type:"int32",data:[R.padInfo.front,R.padInfo.top,R.padInfo.left]},{type:"int32",data:[R.inDepth,R.inHeight,R.inWidth]},{type:"int32",data:[R.effectiveFilterDepth,R.effectiveFilterHeight,R.effectiveFilterWidth]}];return t.runWebGPUProgram(B,[a],a.dtype,X)}const ou={kernelName:y._k9,backendName:"webgpu",kernelFunc:Fl};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bl{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class Ll{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ul(n){const{inputs:e,backend:t,attrs:s}=n,{dy:a,input:u}=e,d=u,{filterSize:m,strides:b,pad:T,dimRoundingMode:k}=s,R=y.Wap.computePool3DInfo(d.shape,m,b,1,T,k),B=new Ll(R),X=1/(R.filterDepth*R.filterHeight*R.filterWidth),oe=[{type:"int32",data:[R.strideDepth,R.strideHeight,R.strideWidth]},{type:"int32",data:[R.effectiveFilterDepth-1-R.padInfo.front,R.effectiveFilterHeight-1-R.padInfo.top,R.effectiveFilterWidth-1-R.padInfo.left]},{type:"int32",data:[R.effectiveFilterDepth,R.effectiveFilterHeight,R.effectiveFilterWidth]},{type:"int32",data:[R.outDepth]},{type:"int32",data:[R.outHeight]},{type:"int32",data:[R.outWidth]},{type:"float32",data:[X]}];return t.runWebGPUProgram(B,[a],d.dtype,oe)}const Ml={kernelName:y.IMb,backendName:"webgpu",kernelFunc:Ul};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wl(n){const{inputs:e,backend:t,attrs:s}=n,{dy:a,input:u}=e,d=u;mr([a,u],"avgPoolGrad");const{filterSize:m,strides:b,pad:T}=s,k=y.Wap.computePool2DInfo(d.shape,m,b,1,T),R=new Bl(k),B=1/(k.filterHeight*k.filterWidth),X=[{type:"int32",data:[k.strideHeight,k.strideWidth]},{type:"int32",data:[k.effectiveFilterHeight-1-k.padInfo.top,k.effectiveFilterWidth-1-k.padInfo.left]},{type:"int32",data:[k.dilationHeight,k.dilationWidth]},{type:"int32",data:[k.effectiveFilterHeight,k.effectiveFilterWidth]},{type:"int32",data:[k.outHeight]},{type:"int32",data:[k.outWidth]},{type:"float32",data:[B]}];return t.runWebGPUProgram(R,[a],d.dtype,X)}const au={kernelName:y.ROF,backendName:"webgpu",kernelFunc:Wl};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ni(n){const{inputs:e,backend:t,attrs:s}=n,{a,b:u}=e,{transposeA:d,transposeB:m}=s;return ia({a,b:u,transposeA:d,transposeB:m,backend:t})}const iu={kernelName:y.XLW,backendName:"webgpu",kernelFunc:Ni};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vl{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${Cn(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=Cn(this.rank),t=zl(this.rank);let s;return this.start.length===1?s=this.outputShape.map((u,d)=>"sourceLoc = uniforms.start + coords;"):s=this.outputShape.map((u,d)=>`sourceLoc.${ki[d]} = uniforms.start.${Hn(d)} + coords.${ki[d]};`),`
      ${kt("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${s.join(`
`)}
          setOutputAtIndex(index, getSource(${t}));
        }
      }
    `}}const ki=["x","y","z","w","u","v"];function zl(n){if(n===1)return"sourceLoc";if(n<=6)return ki.slice(0,n).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function or(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{begin:u,size:d}=s,[m,b]=y.kuN.parseSliceParams(a,u,d);if(y.kuN.assertParamsValid(a,m,b),t.shouldExecuteOnCPU([a])||a.dtype==="string"){const R=t.tensorMap.get(a.dataId),B=xi(R.values,m,b,a.shape,a.dtype);return t.makeTensorInfo(b,a.dtype,B)}if(y.D5U.sizeFromShape(b)===0)return t.makeTensorInfo(b,a.dtype,[]);const T=new Vl(m,b),k=[{type:"int32",data:m}];return t.runWebGPUProgram(T,[a],a.dtype,k)}const ei={kernelName:y.p2w,backendName:"webgpu",kernelFunc:or};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ti=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{blockShape:u,crops:d}=s;y.D5U.assert(a.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const m=u.reduce((Xe,ot)=>Xe*ot),b=y.Wap.getReshaped(a.shape,u,m),T=y.Wap.getPermuted(b.length,u.length),k=y.Wap.getReshapedPermuted(a.shape,u,m),R=y.Wap.getSliceBeginCoords(d,u.length),B=y.Wap.getSliceSize(k,d,u.length),X=[],oe=Zt({inputs:{x:a},backend:t,attrs:{shape:b}}),ue=Ds({inputs:{x:oe},backend:t,attrs:{perm:T}}),he=Zt({inputs:{x:ue},backend:t,attrs:{shape:k}}),Ue=or({inputs:{x:he},backend:t,attrs:{begin:R,size:B}});return X.push(oe),X.push(ue),X.push(he),X.forEach(Xe=>t.disposeData(Xe.dataId)),Ue},Gl={kernelName:y.zws,backendName:"webgpu",kernelFunc:ti};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ba=`
  fn bincount_write(index: i32, value: f32) {
    ${fn("&result[index]","value","float32")}
  }
`,Hl=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class Ri{constructor(e,t,s=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=s,s&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?Hl:Ba}
  ${kt("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jl(n){const{inputs:e,backend:t,attrs:s}=n,{x:a,weights:u}=e,{size:d}=s,m=y.D5U.sizeFromShape(a.shape),T=y.D5U.sizeFromShape(u.shape)>0,k=[d],R=u.dtype,B=zs({backend:t,attrs:{shape:k,value:0,dtype:R}}),X=new Ri([m],T),oe=[{type:"int32",data:[d]}],ue=T?[a,u]:[a];return t.runWebGPUProgram(X,ue,R,oe,B)}const uu={kernelName:y.zvY,backendName:"webgpu",kernelFunc:jl};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kl{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${kt("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lu(n){const{inputs:e,backend:t}=n,{s0:s,s1:a}=e;if(t.shouldExecuteOnCPU([s,a])){const k=t.tensorMap.get(s.dataId),R=t.tensorMap.get(a.dataId),B=k.values,X=R.values,oe=y.Wap.assertAndGetBroadcastShape(Array.from(B),Array.from(X));return t.makeTensorInfo([oe.length],"int32",Int32Array.from(oe))}const u=y.D5U.sizeFromShape(s.shape),d=y.D5U.sizeFromShape(a.shape),m=Math.max(u,d),b=new Kl(m),T=[{type:"int32",data:[u]},{type:"int32",data:[d]}];return t.runWebGPUProgram(b,[s,a],"int32",T)}const Xl={kernelName:y.eEB,backendName:"webgpu",kernelFunc:lu};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const La=Gs({opType:A.NOT_EQUAL,dtype:"bool",cpuKernelImpl:nl}),cu={kernelName:y.yQU,backendName:"webgpu",kernelFunc:La};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function da(n){const{inputs:e,backend:t}=n,{input:s}=e,a=t.tensorMap.get(s.dataId);return rr({inputs:{x:a.complexTensorInfos.real},backend:t})}const Yl={kernelName:y.xJR,backendName:"webgpu",kernelFunc:da};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function du(n,e){const t=new ba(n.shape,Ft.TO_INT),s=e.runWebGPUProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Di(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{dtype:u}=s;if(u==="complex64"){if(a.dtype==="complex64")return rr({inputs:{x:a},backend:t});const d=y.lls(a.shape),m=Di({inputs:{x:a},backend:t,attrs:{dtype:"float32"}}),b=ua({inputs:{real:m,imag:d},backend:t});return d.dispose(),t.disposeData(m.dataId),b}if(a.dtype==="complex64"){const d=da({inputs:{input:a},backend:t}),m=Di({inputs:{x:d},backend:t,attrs:{dtype:u}});return t.disposeData(d.dataId),m}if(!y.D5U.hasEncodingLoss(a.dtype,u)){const d=rr({inputs:{x:a},backend:t});return{dataId:d.dataId,shape:d.shape,dtype:u}}if(t.shouldExecuteOnCPU([a])){const d=t.tensorMap.get(a.dataId).values,[m,b,T]=Xi(d,a.shape,a.dtype,u);return t.makeTensorInfo(m,b,T)}if(u==="int32")return du(a,t);if(u==="bool"){const d=t.makeTensorInfo([],"bool",y.D5U.getTypedArrayFromDType("bool",1)),b=La({inputs:{a,b:d},backend:t});return t.disposeData(d.dataId),b}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${u}`)}const ql={kernelName:y.RFZ,backendName:"webgpu",kernelFunc:Di};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ql=Vn({opType:Ft.CEIL,cpuKernelImpl:Vu}),Zl={kernelName:y.gJX,backendName:"webgpu",kernelFunc:Ql};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jl{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${kt("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ec{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${kt("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tc(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{clipValueMin:u,clipValueMax:d}=s;let m;const b=[{type:"float32",data:[u]},{type:"float32",data:[d]}];return y.D5U.sizeFromShape(a.shape)%4===0?m=new Jl(a.shape):m=new ec(a.shape),t.runWebGPUProgram(m,[a],a.dtype,b)}const nc={kernelName:y.xnO,backendName:"webgpu",kernelFunc:tc};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sc{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${kt("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hu(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function rc(n){const{inputs:e,backend:t}=n,{x:s}=e,a=t.tensorMap.get(s.dataId),u=new sc(s.shape),d=[hu(s,a.complexTensorInfos.real),hu(s,a.complexTensorInfos.imag)];return t.runWebGPUProgram(u,d,d[0].dtype)}const oc={kernelName:y.yj2,backendName:"webgpu",kernelFunc:rc};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sa{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=y.Wap.computeOutShape(e,1),this.variableNames=e.map((t,s)=>`T${s}`),this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+=`offset${t} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let u=1;u<this.offsetLength;u++)e.push(`else if (yC < uniforms.offset${[u]}){ setOutputAtCoords(coords.x, coords.y, getT${u}(yR, yC - uniforms.offset${u-1})); }`);const s=this.offsetLength,a=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${a})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${kt("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ni(n){const{inputs:e,backend:t}=n,{input:s}=e,a=t.tensorMap.get(s.dataId);return rr({inputs:{x:a.complexTensorInfos.imag},backend:t})}const ac={kernelName:y.J_u,backendName:"webgpu",kernelFunc:ni};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ha(n,e,t){const s=n[0].dtype;if(s==="complex64"){const oe=n.map(ot=>da({inputs:{input:ot},backend:t})),ue=n.map(ot=>ni({inputs:{input:ot},backend:t})),he=ha(oe,e,t),Ue=ha(ue,e,t),Xe=ua({inputs:{real:he,imag:Ue},backend:t});return oe.forEach(ot=>t.disposeData(ot.dataId)),ue.forEach(ot=>t.disposeData(ot.dataId)),t.disposeData(he.dataId),t.disposeData(Ue.dataId),Xe}let a=t.shouldExecuteOnCPU(n);if(s==="string"&&(a=!0),a){const oe=n.map(mt=>{const St=[-1,y.D5U.sizeFromShape(mt.shape.slice(e))];return Zt({inputs:{x:mt},backend:t,attrs:{shape:St}})}),ue=oe.map(mt=>({vals:t.readSync(mt.dataId),shape:mt.shape})),he=y.Wap.computeOutShape(oe.map(mt=>mt.shape),1),Ue=oe[0].shape[0]===1,Xe=zu(ue,he,s,Ue),ot=y.Wap.computeOutShape(n.map(mt=>mt.shape),e),it=t.makeTensorInfo(ot,s,Xe);return oe.forEach(mt=>t.disposeData(mt.dataId)),it}const u=t.device.limits.maxStorageBuffersPerShaderStage-1;if(n.length>u){const oe=[];for(let he=0;he<n.length;he+=u){const Ue=n.slice(he,he+u);oe.push(ha(Ue,e,t))}const ue=ha(oe,e,t);for(const he of oe)t.disposeData(he.dataId);return ue}const{tensors2D:d,outShape:m}=ic(n,e,t),b=d.map(oe=>oe.shape),T=new Sa(b),k=[],R=new Array(b.length-1);if(R.length>0){R[0]=b[0][1],k.push({type:"int32",data:[R[0]]});for(let oe=1;oe<R.length;oe++)R[oe]=R[oe-1]+b[oe][1],k.push({type:"int32",data:[R[oe]]})}const B=t.runWebGPUProgram(T,d,d[0].dtype,k);d.forEach(oe=>t.disposeData(oe.dataId));const X=Zt({inputs:{x:B},backend:t,attrs:{shape:m}});return t.disposeData(B.dataId),X}function ic(n,e,t){const s=y.Wap.computeOutShape(n.map(u=>u.shape),e);return{tensors2D:n.map(u=>Zt({inputs:{x:u},backend:t,attrs:{shape:[y.D5U.sizeFromShape(u.shape.slice(0,e)),y.D5U.sizeFromShape(u.shape.slice(e))]}})),outShape:s}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pu(n){const{inputs:e,backend:t,attrs:s}=n,{axis:a}=s,u=y.D5U.parseAxisParam(a,e[0].shape)[0],d=e.map(T=>T.shape);y.Wap.assertParamsConsistent(d,u);const m=y.Wap.computeOutShape(e.map(T=>T.shape),u);if(y.D5U.sizeFromShape(m)===0)return t.makeTensorInfo(m,e[0].dtype,[]);const b=e.filter(T=>y.D5U.sizeFromShape(T.shape)>0);return b.length===1?rr({inputs:{x:b[0]},backend:t}):ha(b,u,t)}const uc={kernelName:y.Eh3,backendName:"webgpu",kernelFunc:pu};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ad(n,e,t,s,a=!1,u=null,d=!1,m=4,b=4,T=4){const k=Bt=>{switch(Bt){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${Bt} is not supported.`)}},R=Bt=>{switch(Bt){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${Bt} is not supported.`)}},B=n?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,X=n?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,oe=n?"uniforms.xShape[1]":"uniforms.xShape[2]",ue=n?"uniforms.xShape[2]":"uniforms.xShape[3]",he=n?"row":"col",Ue=n?"col":"row",Xe=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${he} / outWidth;
      let outCol = ${he} % outWidth;

      let WRow = ${Ue} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${Ue} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${Ue} % inChannels;
      var resData = ${Jt(m)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${oe} && xCol >= 0 && xCol < ${ue}) {
        ${B}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${k(m)}
      }
      return resData;`,ot=n?e&&s?`
      ${Xe}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${Xe}
      }
      return ${Jt(m)}(0.0);`:s&&t?`
      ${Xe}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${Xe}
      }
      return ${Jt(m)}(0.0);`,it=`${R(b)}`,mt=Jt(T),wt=Jt(n?m:b),St=Jt(n?b:m);return`
      ${mo(u,d,T===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${wt} {
        ${n?ot:it}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${St} {
        ${n?it:ot}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${mt}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${X}
        ${Lo(a,u)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class lc{constructor(e,t,s,a,u=!1,d=null,m=!1,b=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=To(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=ma(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),u&&(this.variableNames.push("bias"),this.variableComponents.push(4)),m&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],u&&this.variableNames.push("bias"),m&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=b,this.addBias=u,this.activation=d,this.hasPreluActivationWeights=m,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter===0,this.fitBOuter=s%this.tileBOuter===0,this.fitInner=a%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?oa(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):_a(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${ad(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}
    ${e}
  `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cc{constructor(e,t=!1,s=null,a=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=s,this.hasPreluActivationWeights=a,t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${mo(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${Lo(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${kt("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dc{constructor(e,t){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,s=this.isChannelsLast?"coords[1]":"coords[2]",a=this.isChannelsLast?"coords[2]":"coords[1]",u=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${kt("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${s};
        let col = ${a};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {
            value = ${u};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function si(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function hc({x:n,filter:e,convInfo:t,backend:s,bias:a=null,preluActivationWeights:u=null,leakyreluAlpha:d=0,activation:m=null}){const b=t.dataFormat==="channelsLast",T=!b,k=!1,R=b&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",B=[];let X,oe;if(R){const Ue=t.inHeight*t.inWidth*t.inChannels;X=Zt({inputs:{x:n},backend:s,attrs:{shape:[1,t.batchSize,Ue]}}),oe=Zt({inputs:{x:e},backend:s,attrs:{shape:[1,Ue,t.outChannels]}})}else X=Zt({inputs:{x:n},backend:s,attrs:{shape:b?[t.batchSize,t.inHeight*t.inWidth,t.inChannels]:[t.batchSize,t.inChannels,t.inHeight*t.inWidth]}}),oe=Zt({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});if(B.push(X),B.push(oe),u!=null){const Ue=si(u.shape,b);Ue!=null&&(u=Zt({inputs:{x:u},backend:s,attrs:{shape:Ue}}),B.push(u))}if(a!=null){const Ue=si(a.shape,b);Ue!=null&&(a=Zt({inputs:{x:a},backend:s,attrs:{shape:Ue}}),B.push(a))}const ue=ia({a:b?X:oe,b:b?oe:X,transposeA:T,transposeB:k,backend:s,bias:a,activation:m,preluActivationWeights:u,leakyreluAlpha:d}),he=Zt({inputs:{x:ue},backend:s,attrs:{shape:t.outShape}});B.push(ue);for(const Ue of B)s.disposeData(Ue.dataId);return he}function Ua({x:n,filter:e,convInfo:t,backend:s,bias:a=null,preluActivationWeights:u=null,leakyreluAlpha:d=0,activation:m=null}){const{filterWidth:b,filterHeight:T,inChannels:k,strideWidth:R,strideHeight:B,padInfo:X,outWidth:oe,outHeight:ue,dilationWidth:he,dilationHeight:Ue,dataFormat:Xe}=t,ot=Xe==="channelsLast",it=b*T*k,mt=ue*oe,wt=ot?[t.batchSize,mt,it]:[t.batchSize,it,mt],St=new dc(wt,ot),Mt=[{type:"int32",data:[X.top,X.left]},{type:"int32",data:[B,R]},{type:"int32",data:[Ue,he]},{type:"int32",data:[oe]},{type:"int32",data:[k*b]},{type:"int32",data:[k]}],Bt=s.runWebGPUProgram(St,[n],n.dtype,Mt),en=[];en.push(Bt);const hn=Zt({inputs:{x:e},backend:s,attrs:{shape:[1,it,-1]}});if(en.push(hn),u!=null){const ts=si(u.shape,ot);ts!=null&&(u=Zt({inputs:{x:u},backend:s,attrs:{shape:ts}}),en.push(u))}if(a!=null){const ts=si(a.shape,ot);ts!=null&&(a=Zt({inputs:{x:a},backend:s,attrs:{shape:ts}}),en.push(a))}const On=ia({a:ot?Bt:hn,b:ot?hn:Bt,transposeA:!ot,transposeB:!1,backend:s,bias:a,activation:m,preluActivationWeights:u,leakyreluAlpha:d}),Qn=Zt({inputs:{x:On},backend:s,attrs:{shape:t.outShape}});en.push(On);for(const ts of en)s.disposeData(ts.dataId);return Qn}function _i({x:n,filter:e,convInfo:t,backend:s,bias:a=null,preluActivationWeights:u=null,leakyreluAlpha:d=0,activation:m=null}){const b=a!=null,T=u!=null,k=t.dataFormat==="channelsLast",R=k&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",B=(0,y.OBj)().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!B&&(R||t.filterHeight===1&&t.filterWidth===1&&t.dilationHeight===1&&t.dilationWidth===1&&t.strideHeight===1&&t.strideWidth===1&&(t.padInfo.type==="SAME"||t.padInfo.type==="VALID")))return hc({x:n,filter:e,convInfo:t,backend:s,bias:a,activation:m,preluActivationWeights:u,leakyreluAlpha:d});const X=(0,y.OBj)().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),oe=X>-1?X:s.thresholdToIncreaseWorkgroups,ue=t.batchSize*Math.ceil(t.outHeight*t.outWidth/32)*Math.ceil(t.outChannels/32);if((0,y.OBj)().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||ue<=oe)return Ua({x:n,filter:e,convInfo:t,backend:s,bias:a,preluActivationWeights:u,leakyreluAlpha:d,activation:m});let he;const Ue=[t.padInfo.top,t.padInfo.left],Xe=[{type:"int32",data:[t.filterHeight,t.filterWidth]},{type:"int32",data:[...Ue]},{type:"int32",data:[t.strideHeight,t.strideWidth]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]}];if(B)he=new cc(t,b,m,T);else{const wt=k?t.outHeight*t.outWidth:t.outChannels,St=k?t.outChannels:t.outHeight*t.outWidth,Mt=t.filterHeight*t.filterWidth*t.inChannels;Xe.push({type:"int32",data:[wt]},{type:"int32",data:[St]},{type:"int32",data:[Mt]});const Bt=s.adapterInfo.isIntel();he=new lc(t,wt,St,Mt,b,m,T,Bt)}const ot=[],it=[n,e];b&&(!k&&a.shape.length===1&&(a=Zt({inputs:{x:a},backend:s,attrs:{shape:[a.shape[0],1,1]}}),ot.push(a)),it.push(a)),T&&(!k&&u.shape.length===1&&(u=Zt({inputs:{x:u},backend:s,attrs:{shape:[u.shape[0],1,1]}}),ot.push(u)),it.push(u)),m==="leakyrelu"&&(Xe.push({type:"float32",data:[d]}),he.uniforms+=" alpha : f32,");const mt=s.runWebGPUProgram(he,it,n.dtype,Xe);for(const wt of ot)s.disposeData(wt.dataId);return mt}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fu(n){const{inputs:e,attrs:t,backend:s}=n,{x:a,filter:u}=e,{strides:d,pad:m,dataFormat:b,dilations:T,dimRoundingMode:k}=t,R=y.Wap.convertConv2DDataFormat(b),B=y.Wap.computeConv2DInfo(a.shape,u.shape,d,T,m,k,!1,R);return _i({x:a,filter:u,convInfo:B,backend:s})}const mu={kernelName:y.mhS,backendName:"webgpu",kernelFunc:fu};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gu{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,s=this.isChannelsLast?3:1,a=`
    ${kt()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${a}
    `:`
    ${kt("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${s}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class pc{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${kt("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class fc{constructor(e){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${kt("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class mc{constructor(e){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${kt("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gc(n){const{inputs:e,backend:t,attrs:s}=n,{x:a,dy:u}=e,{strides:d,pad:m,dataFormat:b,dimRoundingMode:T,filterShape:k}=s,R=y.Wap.convertConv2DDataFormat(b),B=y.Wap.computeConv2DInfo(a.shape,k,d,1,m,T,!1,R),X=new pc(B),oe=[{type:"int32",data:[B.padInfo.top,B.padInfo.left]},{type:"int32",data:[B.strideHeight,B.strideWidth]},{type:"int32",data:[B.batchSize]},{type:"int32",data:[B.outHeight]},{type:"int32",data:[B.outWidth]},{type:"int32",data:[B.inHeight]},{type:"int32",data:[B.inWidth]}];return t.runWebGPUProgram(X,[a,u],a.dtype,oe)}const yc={kernelName:y.wUP,backendName:"webgpu",kernelFunc:gc};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xc(n=4){const e=u=>{switch(u){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${u} is not supported.`)}},s=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${Jt(n)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${Jt(n)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${n}];`}
      }
      return ${Jt(n)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${Jt(n)} {
    ${s}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${Jt(n)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(n)}
    }
    return ${Jt(n)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${Jt(n)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${n}] = value;
    }
  }`}class bc{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,y.D5U.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=To(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=ma(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?oa(this.elementsPerThread,this.workgroupSize):_a(this.elementsPerThread,this.workgroupSize);return`
    ${xc(this.isVec4?4:1)}
    ${e}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wc(n){const{inputs:e,backend:t,attrs:s}=n,{dy:a,filter:u}=e,{inputShape:d,strides:m,pad:b,dataFormat:T,dimRoundingMode:k}=s,R=y.Wap.convertConv2DDataFormat(T),B=y.Wap.computeConv2DInfo(d,u.shape,m,1,b,k,!1,R),X=[{type:"int32",data:[B.filterHeight,B.filterWidth]},{type:"int32",data:[B.filterHeight-1-B.padInfo.top,B.filterWidth-1-B.padInfo.left]},{type:"int32",data:[B.strideHeight,B.strideWidth]},{type:"int32",data:[B.batchSize,B.outHeight,B.outWidth,B.outChannels]}];let oe;if((0,y.OBj)().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||B.dataFormat!=="channelsLast")oe=new gu(B);else{oe=new bc(B);const ue=B.inHeight*B.inWidth,he=B.inChannels,Ue=B.filterHeight*B.filterWidth*B.outChannels;X.push({type:"uint32",data:[ue]},{type:"uint32",data:[he]},{type:"uint32",data:[Ue]})}return t.runWebGPUProgram(oe,[a,u],"float32",X)}const vc={kernelName:y.wm,backendName:"webgpu",kernelFunc:wc};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yu{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ai(n){const{inputs:e,backend:t,attrs:s}=n,{x:a,filter:u}=e,{strides:d,pad:m,dilations:b}=s,T=y.Wap.computeConv3DInfo(a.shape,u.shape,d,b,m),k=[T.padInfo.front,T.padInfo.top,T.padInfo.left],R=[{type:"int32",data:[T.filterDepth,T.filterHeight,T.filterWidth]},{type:"int32",data:[...k]},{type:"int32",data:[T.strideDepth,T.strideHeight,T.strideWidth]},{type:"int32",data:[T.dilationDepth,T.dilationHeight,T.dilationWidth]}],B=new yu(T),X=(0,y.x8V)(a.dtype,u.dtype);return t.runWebGPUProgram(B,[a,u],X,R)}const Cc={kernelName:y.x12,backendName:"webgpu",kernelFunc:Ai};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xr(n){const{inputs:e,backend:t,attrs:s}=n,{x:a,dy:u}=e,{strides:d,pad:m,filterShape:b}=s,T=y.Wap.computeConv3DInfo(a.shape,b,d,1,m),k=new fc(T),R=[{type:"int32",data:[T.padInfo.front,T.padInfo.top,T.padInfo.left]},{type:"int32",data:[T.strideDepth,T.strideHeight,T.strideWidth]},{type:"int32",data:[T.batchSize]},{type:"int32",data:[T.outDepth]},{type:"int32",data:[T.outHeight]},{type:"int32",data:[T.outWidth]},{type:"int32",data:[T.inDepth]},{type:"int32",data:[T.inHeight]},{type:"int32",data:[T.inWidth]}];return t.runWebGPUProgram(k,[a,u],u.dtype,R)}const Sc={kernelName:y.o2y,backendName:"webgpu",kernelFunc:xr};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uo(n){const{inputs:e,backend:t,attrs:s}=n,{dy:a,filter:u}=e,{strides:d,pad:m,inputShape:b}=s,T=y.Wap.computeConv3DInfo(b,u.shape,d,1,m),k=new mc(T),R=[{type:"int32",data:[T.filterDepth,T.filterHeight,T.filterWidth]},{type:"int32",data:[T.filterDepth-1-T.padInfo.front,T.filterHeight-1-T.padInfo.top,T.filterWidth-1-T.padInfo.left]},{type:"int32",data:[T.strideDepth,T.strideHeight,T.strideWidth]},{type:"int32",data:[T.outDepth]},{type:"int32",data:[T.outHeight]},{type:"int32",data:[T.outWidth]},{type:"int32",data:[T.outChannels]}];return t.runWebGPUProgram(k,[a,u],a.dtype,R)}const Ic={kernelName:y.ik2,backendName:"webgpu",kernelFunc:Uo};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ec=Vn({opType:Ft.COS}),Tc={kernelName:y.mc4,backendName:"webgpu",kernelFunc:Ec};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $c=Vn({opType:Ft.COSH}),Nc={kernelName:y.TR1,backendName:"webgpu",kernelFunc:$c};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kc{constructor(e,t,s,a){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[u]=t;this.outputShape=[u,s[0],s[1],e],this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=a==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[s,a,u]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[d,m,b]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`
    ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${s});
        let width_ratio = f32(${d});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${a};
        let width_scale = ${m};
        let in_y = ${u};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${b};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rc=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:a,boxes:u,boxInd:d}=e,{cropSize:m,method:b,extrapolationValue:T}=s,k=new kc(a.shape[3],u.shape,m,b),R=[{type:"float32",data:[T]}];return t.runWebGPUProgram(k,[a,u,d],"float32",R)},Dc={kernelName:y.VcC,backendName:"webgpu",kernelFunc:Rc};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ma;(function(n){n.Prod="*",n.Sum="+"})(Ma||(Ma={}));class xu{constructor(e,t,s,a){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=s,this.reverse=a,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===Ma.Prod?"1.0":"0.0",s=this.exclusive?t:`getX(${bu(e,"coords",this.op)})`,a=this.outputShape[this.outputShape.length-1];let u="",d="";return this.exclusive?(u=this.reverse?`end != ${a-1}`:"end != 0",d=this.reverse?"end + 1":"end - 1"):(u=this.reverse?`end + pow2 < ${a}`:"end >= pow2",d=this.reverse?"end + pow2":"end - pow2"),`
      ${kt("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${wu(e,"coords",this.op)};
         var val = ${s};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${u}) {
           let idx = ${d};
           ${wu(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${bu(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}}function bu(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function wu(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _c(n,e,t,s,a,u){const d=e.shape.length,m=y.Wap.getAxesPermutation([s],d);let b=e;m!=null&&(b=Ds({inputs:{x:e},backend:t,attrs:{perm:m}}));const T=y.Wap.getInnerMostAxes(1,d)[0];if(T!==d-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const k=b.shape[T];let R=rr({inputs:{x:b},backend:t});for(let B=0;B<=Math.ceil(Math.log2(k))-1;B++){const X=new xu(n,b.shape,!1,u),oe=R,ue=[{type:"float32",data:[B]}];R=t.runWebGPUProgram(X,[R],R.dtype,ue),t.disposeData(oe.dataId)}if(a){const B=new xu(n,b.shape,a,u),X=R,oe=[{type:"float32",data:[0]}];R=t.runWebGPUProgram(B,[R],R.dtype,oe),t.disposeData(X.dataId)}if(m!=null){const B=y.Wap.getUndoAxesPermutation(m),X=Ds({inputs:{x:R},backend:t,attrs:{perm:B}});return t.disposeData(R.dataId),t.disposeData(b.dataId),X}return R}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function id(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{axis:u,exclusive:d,reverse:m}=s;return _c(Ma.Prod,a,t,u,d,m)}const Ac={kernelName:y.Byc,backendName:"webgpu",kernelFunc:id};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pc(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{axis:u,exclusive:d,reverse:m}=s;return _c(Ma.Sum,a,t,u,d,m)}const Oc={kernelName:y.iHb,backendName:"webgpu",kernelFunc:Pc};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fc(n){const{inputs:e,backend:t,attrs:s}=n,{x:a,weights:u}=e,{size:d,binaryOutput:m}=s,b=a.shape.length===1,k=y.D5U.sizeFromShape(u.shape)>0,R=u.dtype,B=b?[a.shape[0]]:[a.shape[0],a.shape[1]],X=b?[d]:[a.shape[0],d],oe=zs({backend:t,attrs:{shape:X,value:0,dtype:R}}),ue=new Ri(B,k,m),he=[{type:"int32",data:[d]}],Ue=k?[a,u]:[a];return t.runWebGPUProgram(ue,Ue,R,he,oe)}const Bc={kernelName:y.QRR,backendName:"webgpu",kernelFunc:Fc};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lc{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ud(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{blockSize:u,dataFormat:d}=s,m=a.shape[0],b=d==="NHWC"?a.shape[1]:a.shape[2],T=d==="NHWC"?a.shape[2]:a.shape[3],k=d==="NHWC"?a.shape[3]:a.shape[1],R=b*u,B=T*u,X=k/(u*u),oe=d==="NHWC"?[m,R,B,X]:[m,X,R,B],ue=[{type:"int32",data:[u]}],he=new Lc(oe,d);return t.runWebGPUProgram(he,[a],a.dtype,ue)}const ld={kernelName:y.T0n,backendName:"webgpu",kernelFunc:ud};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uc{constructor(e,t,s,a=!1,u=null,d=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),a&&this.variableNames.push("bias"),d&&this.variableNames.push("preluActivationWeights"),this.addBias=a,this.activation=u,this.hasPreluActivation=d,this.filterHeight=t,this.filterWidth=s,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],s=this.workgroupSize[1]+this.filterHeight-1,a=this.workgroupSize[0]+this.filterWidth-1;return`
      ${mo(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${a}>, ${s}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${kt()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${a}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Lo(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vu{constructor(e,t=!1,s=null,a=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const u=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=Gt(u),this.dispatch=Ut(this.dispatchLayout,u,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),y.D5U.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=s,this.hasPreluActivation=a,this.shaderKey=`depthwiseVec4_${s}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,s=this.convInfo.strideWidth;return`
      ${mo(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${kt("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${s}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${s} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Lo(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cu{constructor(e,t=!1,s=null,a=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=s,this.hasPreluActivation=a,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${mo(this.activation,this.hasPreluActivation,!1,4)}

      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${Lo(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mc(n){const{inputs:e,backend:t,attrs:s}=n,{x:a,filter:u}=e,{strides:d,pad:m,dataFormat:b,dilations:T,dimRoundingMode:k}=s,R=y.Wap.convertConv2DDataFormat(b);let B=T;B==null&&(B=[1,1]);const X=y.Wap.computeConv2DInfo(a.shape,u.shape,d,B,m,k,!0,R),oe=[{type:"int32",data:[X.padInfo.top,X.padInfo.left]},{type:"int32",data:[X.inHeight,X.inWidth]}],ue=X.dataFormat==="channelsLast";let he;return!ue&&X.inHeight>16&&X.inWidth>16&&X.strideHeight===1&&X.strideWidth===1&&X.dilationWidth===1&&X.dilationHeight===1&&X.inChannels===X.outChannels?he=new Uc(X.outShape,X.filterHeight,X.filterWidth):ue&&X.outHeight>4&&X.outWidth>4&&X.strideWidth<=2&&X.inChannels===X.outChannels&&X.dilationHeight===1&&X.dilationWidth===1&&X.inChannels%4===0?(he=new vu(X),oe.push({type:"int32",data:[he.virtualWidth]})):(he=new Cu(X),oe.push({type:"int32",data:[X.filterHeight]},{type:"int32",data:[X.filterWidth]},{type:"int32",data:[X.strideHeight,X.strideWidth]},{type:"int32",data:[X.dilationHeight,X.dilationWidth]})),t.runWebGPUProgram(he,[a,u],a.dtype,oe)}const Wc={kernelName:y.cie,backendName:"webgpu",kernelFunc:Mc};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vc{constructor(e){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class cd{constructor(e){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Su(n){const{inputs:e,backend:t,attrs:s}=n,{x:a,dy:u}=e,{strides:d,dilations:m,pad:b,dimRoundingMode:T,filterShape:k}=s,R=y.Wap.computeConv2DInfo(a.shape,k,d,m,b,T,!0),B=new Vc(R),X=[{type:"int32",data:[R.strideHeight,R.strideWidth]},{type:"int32",data:[R.padInfo.top,R.padInfo.left]},{type:"int32",data:[R.filterHeight,R.filterWidth]},{type:"int32",data:[R.outHeight]},{type:"int32",data:[R.outWidth]},{type:"int32",data:[R.inHeight]},{type:"int32",data:[R.inWidth]},{type:"int32",data:[R.batchSize]},{type:"int32",data:[R.outChannels/R.inChannels]}];return t.runWebGPUProgram(B,[a,u],"float32",X)}const zc={kernelName:y.sL$,backendName:"webgpu",kernelFunc:Su};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pi(n){const{inputs:e,backend:t,attrs:s}=n,{dy:a,filter:u}=e,{strides:d,dilations:m,pad:b,dimRoundingMode:T,inputShape:k}=s,R=y.Wap.computeConv2DInfo(k,u.shape,d,m,b,T,!0),B=new cd(R),X=[{type:"int32",data:[R.strideHeight,R.strideWidth]},{type:"int32",data:[R.filterHeight-1-R.padInfo.top,R.filterWidth-1-R.padInfo.left]},{type:"int32",data:[R.filterHeight,R.filterWidth]},{type:"int32",data:[R.outHeight]},{type:"int32",data:[R.outWidth]},{type:"int32",data:[R.outChannels/R.inChannels]}];return t.runWebGPUProgram(B,[a,u],a.dtype,X)}const Gc={kernelName:y.y7R,backendName:"webgpu",kernelFunc:Pi};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Iu{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hc(n){const{inputs:e,backend:t}=n,{x:s}=e,a=[...s.shape,...s.shape],u=y.D5U.sizeFromShape(s.shape),d=Zt({inputs:{x:s},backend:t,attrs:{shape:[u]}}),m=new Iu(u),b=t.runWebGPUProgram(m,[d],d.dtype),T=Zt({inputs:{x:b},backend:t,attrs:{shape:a}});return t.disposeData(d.dataId),t.disposeData(b.dataId),T}const jc={kernelName:y.$w,backendName:"webgpu",kernelFunc:Hc};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Eu{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${kt("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tu(n){const{inputs:e,backend:t,attrs:s}=n,{x:a,filter:u}=e,{strides:d,pad:m,dilations:b}=s,T=y.Wap.computeDilation2DInfo(a.shape,u.shape,d,m,"NHWC",b),k=[T.padInfo.top,T.padInfo.left],R=[{type:"int32",data:[T.filterHeight,T.filterWidth]},{type:"int32",data:[...k]},{type:"int32",data:[T.strideHeight,T.strideWidth]},{type:"int32",data:[T.dilationHeight,T.dilationWidth]}],B=new Eu(T);return t.runWebGPUProgram(B,[a,u],a.dtype,R)}const Kc={kernelName:y.p4S,backendName:"webgpu",kernelFunc:Tu};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xc{constructor(e,t){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=Gt(e.outShape),this.dispatch=Ut(this.dispatchLayout,e.outShape,this.workgroupSize),t!=="float32"&&t!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${t} type.`);this.type=t,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${kt("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${fn("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class Yc{constructor(e,t,s){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=Gt(e.outShape),this.dispatch=Ut(this.dispatchLayout,e.outShape,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${s} type.`);this.type=s,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${kt("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${fn("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I(n){const{inputs:e,backend:t,attrs:s}=n,{x:a,filter:u,dy:d}=e,{strides:m,pad:b,dilations:T}=s,k=y.Wap.computeDilation2DInfo(a.shape,u.shape,m,b,"NHWC",T),R=u.dtype,B=new Yc(k,u.shape,R),X=[{type:"int32",data:[k.filterHeight,k.filterWidth]},{type:"int32",data:[k.padInfo.top,k.padInfo.left]},{type:"int32",data:[k.strideHeight,k.strideWidth]},{type:"int32",data:[k.dilationHeight,k.dilationWidth]},{type:"int32",data:[y.D5U.sizeFromShape(k.outShape)]}],oe=zs({backend:t,attrs:{shape:u.shape,value:0,dtype:R}});return t.runWebGPUProgram(B,[a,u,d],R,X,oe)}const w={kernelName:y.Vn9,backendName:"webgpu",kernelFunc:I};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x(n){const{inputs:e,backend:t,attrs:s}=n,{x:a,filter:u,dy:d}=e,{strides:m,pad:b,dilations:T}=s,k=y.Wap.computeDilation2DInfo(a.shape,u.shape,m,b,"NHWC",T),R=a.dtype,B=new Xc(k,R),X=[{type:"int32",data:[k.filterHeight,k.filterWidth]},{type:"int32",data:[k.padInfo.top,k.padInfo.left]},{type:"int32",data:[k.strideHeight,k.strideWidth]},{type:"int32",data:[k.dilationHeight,k.dilationWidth]},{type:"int32",data:[y.D5U.sizeFromShape(k.outShape)]}],oe=zs({backend:t,attrs:{shape:k.inShape,value:0,dtype:R}});return t.runWebGPUProgram(B,[a,u,d],R,X,oe)}const $={kernelName:y.ekb,backendName:"webgpu",kernelFunc:x};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class O{constructor(e,t,s){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=pn.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=t,this.textureFormat=s,this.shaderKey=`draw_${t}_${s}`}getUserCode(){let e;const t=this.type==="float32"?"value":"value / 255.0";return e=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${t};
        rgba[1] = ${t};
        rgba[2] = ${t};
      } else {
        rgba[d] = ${t};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${kt("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M(n){const{inputs:e,backend:t,attrs:s}=n,{image:a}=e,{canvas:u,options:d}=s,[m,b]=a.shape.slice(0,2),{imageOptions:T}=d||{},k=T?.alpha||1,R=t.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",B=[m,b],X=new O(B,a.dtype,R);u.width=b,u.height=m;const oe="webgpu";let ue=u.getContext(oe),he;ue||(he=new OffscreenCanvas(b,m),ue=he.getContext(oe));const Ue=a.shape.length===3?a.shape[2]:1;ue.configure({device:t.device,format:R,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const Xe="int32",ot=t.makeTensorInfo(B,Xe),it=t.tensorMap.get(ot.dataId);it.resource=ue.getCurrentTexture(),it.external=!0;const mt=[{type:"uint32",data:[Ue]},{type:"float32",data:[k]}];if(t.runWebGPUProgram(X,[a],Xe,mt,ot),he){const wt=u.getContext("2d");if(!wt)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");wt.drawImage(he,0,0)}return t.disposeData(ot.dataId),a}const j={kernelName:y.hGc,backendName:"webgpu",kernelFunc:M};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J=Gs({opType:A.MUL,cpuKernelImpl:Zi,supportsComplex:!0}),ye={kernelName:y.wYn,backendName:"webgpu",kernelFunc:J};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $e(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{axis:u,keepDims:d}=s;return ca(a,u,d,"sum",t)}const qe={kernelName:y.GBy,backendName:"webgpu",kernelFunc:$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ze(n){const{inputs:e,backend:t,attrs:s}=n,{equation:a}=s,u=e,{allDims:d,summedDims:m,idDims:b}=y.Wap.decodeEinsumEquation(a,u.length);y.Wap.checkEinsumDimSizes(d.length,b,u);const{path:T,steps:k}=y.Wap.getEinsumComputePath(m,b),R=k.length;let B=null,X=d.length;const oe=[];for(let ue=0;ue<R;++ue){for(const he of k[ue]){const{permutationIndices:Ue,expandDims:Xe}=y.Wap.getEinsumPermutation(X,b[he]);let ot;y.Wap.isIdentityPermutation(Ue)?ot=u[he]:(ot=Ds({inputs:{x:u[he]},backend:t,attrs:{perm:Ue}}),oe.push(ot));const it=ot.shape.slice();for(let mt=0;mt<Xe.length;++mt)it.splice(Xe[mt],0,1);y.D5U.arraysEqual(ot.shape,it)||(ot=Zt({inputs:{x:ot},backend:t,attrs:{shape:it}}),oe.push(ot)),B===null?B=ot:(B=J({inputs:{a:ot,b:B},backend:t}),oe.push(B))}ue<R-1&&(T[ue]>=0&&(B=$e({inputs:{x:B},backend:t,attrs:{axis:T[ue]-(d.length-X),keepDims:!1}}),oe.push(B)),X--)}for(const ue of oe)ue!==B&&t.disposeData(ue.dataId);return B}const Dt={kernelName:y.$g6,backendName:"webgpu",kernelFunc:Ze};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yt=Vn({opType:Ft.ELU}),qt={kernelName:y.SX0,backendName:"webgpu",kernelFunc:Yt};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const In=n=>{const{inputs:e,backend:t}=n,{dy:s,y:a}=e,u=new go(A.ELU_DER,s.shape,a.shape);return t.runWebGPUProgram(u,[s,a],s.dtype)},dn={kernelName:y.HEU,backendName:"webgpu",kernelFunc:In};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mn=Gs({opType:A.EQUAL,dtype:"bool",cpuKernelImpl:Yi}),Ks={kernelName:y.hdR,backendName:"webgpu",kernelFunc:Mn};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hs=Vn({opType:Ft.ERF}),$s={kernelName:y.Omj,backendName:"webgpu",kernelFunc:Hs};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bs=Vn({opType:Ft.EXP,cpuKernelImpl:Gu,dtype:"float32"}),Ln={kernelName:y.NEP,backendName:"webgpu",kernelFunc:Bs};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ys(n){const{inputs:e,attrs:t,backend:s}=n,{dim:a}=t,{input:u}=e,d=u.shape.length,m=u.shape.slice();let b=a;return a<0&&(y.D5U.assert(-(d+1)<=a,()=>`Axis must be in the interval [${-(d+1)}, ${d}]`),b=d+a+1),m.splice(b,0,1),Zt({inputs:{x:u},backend:s,attrs:{shape:m}})}const xs={kernelName:y.YFo,backendName:"webgpu",kernelFunc:ys};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ds=Vn({opType:Ft.EXPM1,cpuKernelImpl:Hu}),hs={kernelName:y.Y0y,backendName:"webgpu",kernelFunc:ds};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bs{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qr(n,e,t){const s=t.tensorMap.get(n.dataId),a=y.D5U.sizeFromShape(n.shape),u=n.shape[n.shape.length-1],d=a/u,m=[],b=Zt({inputs:{x:n},backend:t,attrs:{shape:[d,u]}});m.push(b);const T=b.shape,k=new bs("real",T),R=new bs("imag",T),B=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:T},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:T}],X=e?2*Math.PI:-2*Math.PI,oe=e?T[1]:1,ue=[{type:"float32",data:[X]},{type:"float32",data:[oe]}],he=t.runWebGPUProgram(k,B,"float32",ue);m.push(he);const Ue=t.runWebGPUProgram(R,B,"float32",ue);m.push(Ue);const Xe=ua({inputs:{real:he,imag:Ue},backend:t});m.push(Xe);const ot=Zt({inputs:{x:Xe},backend:t,attrs:{shape:n.shape}});return m.forEach(it=>t.disposeData(it.dataId)),ot}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qr(n){const{inputs:e,backend:t}=n,{input:s}=e;return qr(s,!1,t)}const Zr={kernelName:y.vwp,backendName:"webgpu",kernelFunc:Qr};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ko{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wa={kernelName:y.Uyb,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,a=new ko(t.shape);return s.runWebGPUProgram(a,[t],t.dtype)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qo=Vn({opType:Ft.FLOOR,cpuKernelImpl:ju}),Ia={kernelName:y.OR,backendName:"webgpu",kernelFunc:qo};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ea=Gs({opType:A.FLOOR_DIV,cpuKernelImpl:Ku,dtype:"int32"}),qc={kernelName:y.jeX,backendName:"webgpu",kernelFunc:Ea};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wd{constructor(e,t,s=!1){this.pixelsOpType=pn.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=s,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${kt("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ym={kernelName:y.eBW,backendName:"webgpu",kernelFunc:xm};let ri,Qc=(0,y.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function xm(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:a}=e;const{numChannels:u}=s;if(a==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const d=typeof HTMLVideoElement<"u"&&a instanceof HTMLVideoElement,m=typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement,b=typeof HTMLCanvasElement<"u"&&a instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&a instanceof OffscreenCanvas,T=typeof ImageBitmap<"u"&&a instanceof ImageBitmap,[k,R]=d?[a.videoWidth,a.videoHeight]:[a.width,a.height],B=[R,k,u],X=(0,y.OBj)().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&d,oe=d||m;if(T||b||oe){let Xe;if(X)Xe=t.device.importExternalTexture({source:a});else{if(oe){const vn=(0,y.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(ri==null||vn!==Qc)&&(Qc=vn,ri=document.createElement("canvas").getContext("2d",{willReadFrequently:Qc})),ri.canvas.width=k,ri.canvas.height=R,ri.drawImage(a,0,0,k,R),a=ri.canvas}const en=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,Nn=t.textureManager.acquireTexture(B[1],B[0],"rgba8unorm",en);t.queue.copyExternalImageToTexture({source:a},{texture:Nn},[B[1],B[0]]),Xe=Nn}const ot=y.D5U.sizeFromShape(B),it=y.D5U.computeStrides(B),mt=new Wd(B,u,X),wt=[{type:"uint32",data:[ot]},{type:"uint32",data:[u]},{type:"uint32",data:[...it]}],St=t.makeTensorInfo([R,k],"int32"),Mt=t.tensorMap.get(St.dataId);Mt.resource=Xe;const Bt=t.runWebGPUProgram(mt,[St],"int32",wt);return t.disposeData(St.dataId),Bt}const ue=a.data;let he=ue;if(u!=null&&u!==4){he=new Uint8Array(a.width*a.height*u);const Xe=ue.length;let ot=0;for(let it=0;it<Xe;it++)it%4<u&&(he[ot++]=ue[it])}const Ue=t.makeTensorInfo(B,"int32",new Int32Array(he));return t.uploadToGPU(Ue.dataId),Ue}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vd{constructor(e,t,s,a,u){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],y.Wap.assertAndGetBroadcastShape(e,t),y.Wap.assertAndGetBroadcastShape(e,s),this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),a!=null&&(y.Wap.assertAndGetBroadcastShape(e,a),this.variableNames.push("offset")),u!=null&&(y.Wap.assertAndGetBroadcastShape(e,u),this.variableNames.push("scale")),this.offsetShape=a,this.scaleShape=u,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let t="1.0";return this.scaleShape!=null&&(t="getScaleByOutputIndex(index)"),`
      ${kt("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zd={kernelName:y.sHE,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s,scale:a,offset:u,mean:d,variance:m}=n,{varianceEpsilon:b}=e,T=t,k=[s,d,m];let R=null;u!=null&&(R=u.shape,k.push(u));let B=null;a!=null&&(B=a.shape,k.push(a));const X=new Vd(s.shape,d.shape,m.shape,R,B),oe=[{type:"float32",data:[b]}];return T.runWebGPUProgram(X,k,s.dtype,oe)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bm(n){const{inputs:e,backend:t,attrs:s}=n,{x:a,filter:u,bias:d,preluActivationWeights:m}=e,{strides:b,pad:T,dataFormat:k,dilations:R,dimRoundingMode:B,activation:X,leakyreluAlpha:oe}=s,ue=y.Wap.convertConv2DDataFormat(k),he=y.Wap.computeConv2DInfo(a.shape,u.shape,b,R,T,B,!1,ue);return _i({x:a,filter:u,convInfo:he,backend:t,bias:d,preluActivationWeights:m,leakyreluAlpha:oe,activation:X})}const Gd={kernelName:y._V0,backendName:"webgpu",kernelFunc:bm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hd(n){const{inputs:e,backend:t,attrs:s}=n,{x:a,filter:u,bias:d,preluActivationWeights:m}=e,{strides:b,pad:T,dilations:k,dimRoundingMode:R,activation:B,leakyreluAlpha:X}=s;let oe=k;oe==null&&(oe=[1,1]),y.D5U.assert(y.Wap.eitherStridesOrDilationsAreOne(b,oe),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${b} and dilations '${oe}'`);const ue=y.Wap.computeConv2DInfo(a.shape,u.shape,b,oe,T,R,!0),he=[a,u],Ue=d!=null,Xe=m!=null;Ue&&he.push(d),Xe&&he.push(m);const ot=[{type:"int32",data:[ue.padInfo.top,ue.padInfo.left]},{type:"int32",data:[ue.inHeight,ue.inWidth]}];let it;return ue.outHeight>4&&ue.outWidth>4&&ue.strideWidth<=2&&ue.inChannels===ue.outChannels&&ue.dilationHeight===1&&ue.dilationWidth===1&&ue.inChannels%4===0?(it=new vu(ue,Ue,B,Xe),ot.push({type:"int32",data:[it.virtualWidth]})):(it=new Cu(ue,Ue,B,Xe),ot.push({type:"int32",data:[ue.filterHeight]},{type:"int32",data:[ue.filterWidth]},{type:"int32",data:[ue.strideHeight,ue.strideWidth]},{type:"int32",data:[ue.dilationHeight,ue.dilationWidth]})),B==="leakyrelu"&&(ot.push({type:"float32",data:[X]}),it.uniforms+=" alpha : f32,"),t.runWebGPUProgram(it,he,"float32",ot)}const wm={kernelName:y.luS,backendName:"webgpu",kernelFunc:Hd};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vm{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${Cn(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jd(n){const{inputs:e,backend:t}=n,{params:s,indices:a}=e,u=a.shape,d=u[u.length-1],m=y.D5U.sizeFromShape(s.shape),[b,T,k,R]=y.Wap.prepareAndValidate(s,a),B=Zt({inputs:{x:a},backend:t,attrs:{shape:[T,d]}}),X=Zt({inputs:{x:s},backend:t,attrs:{shape:[y.D5U.sizeFromShape(s.shape)/k,k]}});if(t.shouldExecuteOnCPU([s,a])||s.dtype==="string"){const Xe=t.readSync(a.dataId),ot=t.bufferSync(s),it=Za(Xe,ot,s.dtype,T,d,k,R,s.shape,m);return t.makeTensorInfo(b,s.dtype,it.values)}const oe=new vm(d,[T,k]),ue=[{type:"int32",data:[d]},{type:"int32",data:R}],he=t.runWebGPUProgram(oe,[X,B],X.dtype,ue),Ue=Zt({inputs:{x:he},backend:t,attrs:{shape:b}});return t.disposeData(B.dataId),t.disposeData(X.dataId),t.disposeData(he.dataId),Ue}const Kd={kernelName:y.q1x,backendName:"webgpu",kernelFunc:jd};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cm{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=Sm(this.aShape);return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}}function Sm(n){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],t=[];for(let s=0;s<n.length;s++)s===2?t.push("indexZ"):t.push(`${e[s]}`);return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dd(n){const{inputs:e,backend:t,attrs:s}=n,{x:a,indices:u}=e,{axis:d,batchDims:m}=s,b=y.D5U.parseAxisParam(d,a.shape)[0],T=y.Wap.segment_util.collectGatherOpShapeInfo(a,u,b,m),k=y.D5U.sizeFromShape(u.shape),R=[],B=Zt({inputs:{x:a},backend:t,attrs:{shape:[T.batchSize,T.outerSize,T.dimSize,T.sliceSize]}}),X=Zt({inputs:{x:u},backend:t,attrs:{shape:[T.batchSize,k/T.batchSize]}});R.push(B),R.push(X);const oe=[T.batchSize,T.outerSize,k/T.batchSize,T.sliceSize];if(t.shouldExecuteOnCPU([a,u])){const ot=t.tensorMap.get(X.dataId).values,it=(0,y.f3b)(X.shape,X.dtype,ot),wt=t.tensorMap.get(B.dataId).values,St=(0,y.f3b)(B.shape,B.dtype,wt),Mt=Xu(St,it,oe);return R.forEach(Bt=>t.disposeData(Bt.dataId)),t.makeTensorInfo(T.outputShape,Mt.dtype,Mt.values)}const ue=new Cm(B.shape,oe),he=t.runWebGPUProgram(ue,[B,X],B.dtype);R.push(he);const Ue=Zt({inputs:{x:he},backend:t,attrs:{shape:T.outputShape}});return R.forEach(Xe=>t.disposeData(Xe.dataId)),Ue}const Xd={kernelName:y.qi_,backendName:"webgpu",kernelFunc:dd};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yd=Gs({opType:A.GREATER,cpuKernelImpl:qu,dtype:"bool"}),qd={kernelName:y.iZT,backendName:"webgpu",kernelFunc:Yd};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qd=Gs({opType:A.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:Yu}),Im={kernelName:y.Acj,backendName:"webgpu",kernelFunc:Qd};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zd(n){const{inputs:e,backend:t}=n,{input:s}=e;return qr(s,!0,t)}const Jd={kernelName:y.Qg5,backendName:"webgpu",kernelFunc:Zd};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eh=Vn({opType:Ft.IS_FINITE,dtype:"bool"}),th={kernelName:y.avt,backendName:"webgpu",kernelFunc:eh};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nh=Vn({opType:Ft.IS_INF,dtype:"bool"}),Em={kernelName:y.iWB,backendName:"webgpu",kernelFunc:nh};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tm=Vn({opType:Ft.IS_NAN,dtype:"bool"}),sh={kernelName:y.r7n,backendName:"webgpu",kernelFunc:Tm};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rh(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{alpha:u}=s,d=[{type:"float32",data:[u]}],m=new ba(a.shape,Ft.LEAKYRELU,"alpha : f32,");return t.runWebGPUProgram(m,[a],"float32",d)}const $m={kernelName:y.J$2,backendName:"webgpu",kernelFunc:rh};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oh=Gs({opType:A.LESS,dtype:"bool",cpuKernelImpl:Zu}),ah={kernelName:y.vtC,backendName:"webgpu",kernelFunc:oh};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nm=Gs({opType:A.LESS_EQUAL,dtype:"bool",cpuKernelImpl:Qu}),km={kernelName:y.CAk,backendName:"webgpu",kernelFunc:Nm};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ih{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${kt("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uh(n){const{backend:e,attrs:t}=n,{start:s,stop:a,num:u}=t,d=(a-s)/(u-1),m=new ih(u),b=[{type:"float32",data:[s]},{type:"float32",data:[d]}];return e.runWebGPUProgram(m,[],"float32",b)}const lh={kernelName:y.e7N,backendName:"webgpu",kernelFunc:uh};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ch=Vn({opType:Ft.LOG,cpuKernelImpl:Ju}),dh={kernelName:y.ZbH,backendName:"webgpu",kernelFunc:ch};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hh=Vn({opType:Ft.LOG1P}),ph={kernelName:y.kU,backendName:"webgpu",kernelFunc:hh};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fh=Gs({opType:A.LOGICAL_AND,dtype:"bool"}),mh={kernelName:y.PYm,backendName:"webgpu",kernelFunc:fh};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gh=Vn({opType:Ft.LOGICAL_NOT}),hd={kernelName:y.VfG,backendName:"webgpu",kernelFunc:gh};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yh=Gs({opType:A.LOGICAL_OR}),xh={kernelName:y.MZg,backendName:"webgpu",kernelFunc:yh};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pd=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;class bh{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${pd}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}}class wh{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,y.D5U.assert(t<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Ut(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${kt()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${pd}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vh(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{depthRadius:u,bias:d,alpha:m,beta:b}=s;let T;u>16?T=new bh(a.shape):T=new wh(a.shape,u);const k=[{type:"int32",data:[u]},{type:"float32",data:[d]},{type:"float32",data:[m]},{type:"float32",data:[b]}];return t.runWebGPUProgram(T,[a],a.dtype,k)}const Ch={kernelName:y.eZ0,backendName:"webgpu",kernelFunc:vh};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sh{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ih(n){const{inputs:e,backend:t,attrs:s}=n,{x:a,y:u,dy:d}=e,{depthRadius:m,bias:b,alpha:T,beta:k}=s,R=new Sh(a.shape),B=[{type:"int32",data:[m]},{type:"float32",data:[b]},{type:"float32",data:[T]},{type:"float32",data:[k]}];return t.runWebGPUProgram(R,[a,u,d],a.dtype,B)}const Eh={kernelName:y.Hhh,backendName:"webgpu",kernelFunc:Ih};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Th=Gs({opType:A.MAX,cpuKernelImpl:qi}),$h={kernelName:y.BMI,backendName:"webgpu",kernelFunc:Th};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nh(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{filterSize:u,strides:d,pad:m,dimRoundingMode:b}=s,k=y.Wap.computePool2DInfo(a.shape,u,d,1,m,b);return ru(a,k,"max",t)}const kh={kernelName:y.mTV,backendName:"webgpu",kernelFunc:Nh};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rh(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{filterSize:u,strides:d,pad:m,dataFormat:b,dimRoundingMode:T}=s,k=[1,1,1],R=y.Wap.computePool3DInfo(a.shape,u,d,k,m,T,b),B=new Ii(R,"max"),X=[{type:"int32",data:[R.strideDepth,R.strideHeight,R.strideWidth]},{type:"int32",data:[R.padInfo.front,R.padInfo.top,R.padInfo.left]},{type:"int32",data:[R.inDepth,R.inHeight,R.inWidth]},{type:"int32",data:[R.effectiveFilterDepth,R.effectiveFilterHeight,R.effectiveFilterWidth]}];return t.runWebGPUProgram(B,[a],a.dtype,X)}const Dh={kernelName:y.OAf,backendName:"webgpu",kernelFunc:Rh};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _h{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class Ah{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ph(n){const{inputs:e,backend:t,attrs:s}=n,{dy:a,input:u}=e,d=u,{filterSize:m,strides:b,pad:T,dimRoundingMode:k}=s,R=[1,1,1],B=y.Wap.computePool3DInfo(d.shape,m,b,R,T,k),X=new Ii(B,"max",!0);let oe=[{type:"int32",data:[B.strideDepth,B.strideHeight,B.strideWidth]},{type:"int32",data:[B.padInfo.front,B.padInfo.top,B.padInfo.left]},{type:"int32",data:[B.inDepth,B.inHeight,B.inWidth]},{type:"int32",data:[B.effectiveFilterDepth,B.effectiveFilterHeight,B.effectiveFilterWidth]}];const ue=t.runWebGPUProgram(X,[d],"int32",oe),he=new Ah(B);oe=[{type:"int32",data:[B.strideDepth,B.strideHeight,B.strideWidth]},{type:"int32",data:[B.effectiveFilterDepth-1-B.padInfo.front,B.effectiveFilterHeight-1-B.padInfo.top,B.effectiveFilterWidth-1-B.padInfo.left]},{type:"int32",data:[B.effectiveFilterDepth,B.effectiveFilterHeight,B.effectiveFilterWidth]},{type:"int32",data:[B.outDepth]},{type:"int32",data:[B.outHeight]},{type:"int32",data:[B.outWidth]}];const Ue=t.runWebGPUProgram(he,[a,ue],d.dtype,oe);return t.disposeData(ue.dataId),Ue}const Oh={kernelName:y.OU7,backendName:"webgpu",kernelFunc:Ph};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fh(n){const{inputs:e,backend:t,attrs:s}=n,{dy:a,input:u,output:d}=e,m=u;mr([u,d],"maxPoolGrad");const{filterSize:b,strides:T,pad:k,dimRoundingMode:R}=s,B=y.Wap.computePool2DInfo(m.shape,b,T,1,k,R),X=new Fa(B,"max",!0);let oe=[{type:"int32",data:[B.strideHeight,B.strideWidth]},{type:"int32",data:[B.padInfo.top,B.padInfo.left]},{type:"int32",data:[B.dilationHeight,B.dilationWidth]},{type:"int32",data:[B.inHeight,B.inWidth]},{type:"int32",data:[B.effectiveFilterHeight,B.effectiveFilterWidth]}];const ue=t.runWebGPUProgram(X,[m],"int32",oe),he=new _h(B);oe=[{type:"int32",data:[B.strideHeight,B.strideWidth]},{type:"int32",data:[B.effectiveFilterHeight-1-B.padInfo.top,B.effectiveFilterWidth-1-B.padInfo.left]},{type:"int32",data:[B.dilationHeight,B.dilationWidth]},{type:"int32",data:[B.effectiveFilterHeight,B.effectiveFilterWidth]},{type:"int32",data:[B.outHeight]},{type:"int32",data:[B.outWidth]}];const Ue=t.runWebGPUProgram(he,[a,ue],m.dtype,oe);return t.disposeData(ue.dataId),Ue}const Bh={kernelName:y.OV7,backendName:"webgpu",kernelFunc:Fh};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lh(n){const{inputs:e,backend:t,attrs:s}=n,{filterSize:a,strides:u,pad:d,includeBatchInIndex:m}=s,{x:b}=e;y.D5U.assert(b.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${b.shape.length}.`);const T=[1,1];y.D5U.assert(y.Wap.eitherStridesOrDilationsAreOne(u,T),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${u} and dilations '${T}'`);const k=y.Wap.computePool2DInfo(b.shape,a,u,T,d),R=[{type:"int32",data:[k.strideHeight,k.strideWidth]},{type:"int32",data:[k.padInfo.top,k.padInfo.left]},{type:"int32",data:[k.dilationHeight,k.dilationWidth]},{type:"int32",data:[k.inHeight,k.inWidth]},{type:"int32",data:[k.effectiveFilterHeight,k.effectiveFilterWidth]}];let B=new Fa(k,"max",!1);const X=t.runWebGPUProgram(B,[b],b.dtype,R);B=new Fa(k,"max",!0,!0,m);const oe=t.runWebGPUProgram(B,[b],"int32",R);return[X,oe]}const Uh={kernelName:y.vFR,backendName:"webgpu",kernelFunc:Lh};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mh(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{axis:u,keepDims:d}=s;return ca(a,u,d,"min",t)}const Wh={kernelName:y.c17,backendName:"webgpu",kernelFunc:Mh};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vh=Gs({opType:A.MIN,cpuKernelImpl:Qi}),zh={kernelName:y.q8u,backendName:"webgpu",kernelFunc:Vh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gh{constructor(e,t,s){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((a,u)=>a[0]+e[u]+a[1]),this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map((a,u)=>{this.uniforms+=` pad${u} : vec2<i32>,`}),this.offset=s==="reflect"?0:1,this.shaderKey=`mirrorPad_${s}`}getUserCode(){const e=this.xShape.length,t=this.xShape.map((T,k)=>`uniforms.pad${k}[0]`).join(","),s=this.xShape.map((T,k)=>`uniforms.pad${k}[0] + uniforms.xShape${e>1?`[${k}]`:""}`).join(","),a=e===1?"start":"start[i]",u=e===1?"end":"end[i]",d=e===1?"outC":"outC[i]",m=Cn(e),b=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let start = ${m}(${t});
          let end = ${m}(${s});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${d} < ${a}) {
              ${d} = ${a} * 2 - ${d} - ${this.offset};
            } else if(${d} >= ${u}) {
              ${d} = (${u} - 1) * 2 - ${d} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${b}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hh={kernelName:y.jQs,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{paddings:a,mode:u}=e,d=t,m=a.map(k=>({type:"int32",data:[k[0],k[1]]})),b=new Gh(s.shape,a,u);return d.runWebGPUProgram(b,[s],s.dtype,m)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jh=Gs({opType:A.MOD}),Kh={kernelName:y.Vbg,backendName:"webgpu",kernelFunc:jh};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xh{constructor(e,t){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yh{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${kt("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qh(n){const{inputs:e,backend:t,attrs:s}=n,{logits:a}=e,{dim:u}=s,d=Zt({inputs:{x:a},backend:t,attrs:{shape:[y.D5U.sizeFromShape(a.shape)/a.shape[u],a.shape[u]]}}),m=new Yh(d.shape),b=t.runWebGPUProgram(m,[d],a.dtype),T=Zt({inputs:{x:b},backend:t,attrs:{shape:a.shape}});return t.disposeData(d.dataId),t.disposeData(b.dataId),T}const Rm={kernelName:y.Gcp,backendName:"webgpu",kernelFunc:qh};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fd(n){const{inputs:e,backend:t,attrs:s}=n,{logits:a}=e,{numSamples:u,seed:d,normalized:m}=s,b=m?a:qh({inputs:{logits:a},backend:t,attrs:{dim:a.shape.length-1}}),T=b.shape[0],k=b.shape[1],R=new Xh(T,u),B=[{type:"float32",data:[d]},{type:"int32",data:[k]}],X=t.runWebGPUProgram(R,[b],"int32",B);return m||t.disposeData(b.dataId),X}const Qh={kernelName:y.NZg,backendName:"webgpu",kernelFunc:fd};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function md(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const u=t.tensorMap.get(s.dataId),[d,m]=tl(u.values,s.shape,s.dtype);return t.makeTensorInfo(m,s.dtype,d)}const a=new ba(s.shape,Ft.NEG);return t.runWebGPUProgram(a,[s],s.dtype)}const gd={kernelName:y.kuV,backendName:"webgpu",kernelFunc:md};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zh(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:a,scores:u}=e,{maxOutputSize:d,iouThreshold:m,scoreThreshold:b}=s,T=t.readSync(a.dataId),k=t.readSync(u.dataId),{selectedIndices:R}=y.GDt.nonMaxSuppressionV3Impl(T,k,d,m,b);return t.makeTensorInfo([R.length],"int32",new Int32Array(R))}const yd={kernelName:y.uv1,backendName:"webgpu",kernelFunc:Zh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jh(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:a,scores:u}=e,{maxOutputSize:d,iouThreshold:m,scoreThreshold:b,softNmsSigma:T}=s,k=t.readSync(a.dataId),R=t.readSync(u.dataId),B=d,X=m,oe=b,ue=T,{selectedIndices:he,selectedScores:Ue}=y.GDt.nonMaxSuppressionV5Impl(k,R,B,X,oe,ue);return[t.makeTensorInfo([he.length],"int32",new Int32Array(he)),t.makeTensorInfo([Ue.length],"float32",new Float32Array(Ue))]}const ep={kernelName:y.W0H,backendName:"webgpu",kernelFunc:Jh};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tp{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${kt("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function np(n){const{inputs:e,backend:t,attrs:s}=n,{indices:a}=e,{dtype:u,depth:d,onValue:m,offValue:b}=s,T=y.D5U.sizeFromShape(a.shape),k=new tp(T,d),R=Zt({inputs:{x:a},backend:t,attrs:{shape:[T]}}),B=[{type:"float32",data:[m]},{type:"float32",data:[b]}],X=t.runWebGPUProgram(k,[R],u,B);t.disposeData(R.dataId);const oe=[...a.shape,d],ue=Zt({inputs:{x:X},backend:t,attrs:{shape:oe}});return t.disposeData(X.dataId),ue}const sp={kernelName:y.we_,backendName:"webgpu",kernelFunc:np};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $u(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const a=da({inputs:{input:s},backend:t}),u=$u({inputs:{x:a},backend:t}),d=ni({inputs:{input:s},backend:t}),m=$u({inputs:{x:d},backend:t}),b=ua({inputs:{real:u,imag:m},backend:t});return t.disposeData(a.dataId),t.disposeData(u.dataId),t.disposeData(d.dataId),t.disposeData(m.dataId),b}else return zs({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const rp={kernelName:y.RuY,backendName:"webgpu",kernelFunc:$u};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xd(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const a=da({inputs:{input:s},backend:t}),u=xd({inputs:{x:a},backend:t}),d=ni({inputs:{input:s},backend:t}),m=$u({inputs:{x:d},backend:t}),b=ua({inputs:{real:u,imag:m},backend:t});return t.disposeData(a.dataId),t.disposeData(u.dataId),t.disposeData(d.dataId),t.disposeData(m.dataId),b}else return zs({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const op={kernelName:y.qWM,backendName:"webgpu",kernelFunc:xd};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ap(n){const{inputs:e,backend:t,attrs:s}=n,{axis:a}=s;if(e.length===1)return ys({inputs:{input:e[0]},backend:t,attrs:{dim:a}});const u=e[0].shape,d=e[0].dtype;e.forEach(k=>{y.D5U.assertShapesMatch(u,k.shape,"All tensors passed to stack must have matching shapes"),y.D5U.assert(d===k.dtype,()=>"All tensors passed to stack must have matching dtypes")});const m=[],b=e.map(k=>{const R=ys({inputs:{input:k},backend:t,attrs:{dim:a}});return m.push(R),R}),T=pu({inputs:b,backend:t,attrs:{axis:a}});return m.forEach(k=>t.disposeData(k.dataId)),T}const ip={kernelName:y.QiL,backendName:"webgpu",kernelFunc:ap};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bd(n,e=!1){const t=n.length,s=Cn(t),a=n.map((R,B)=>`uniforms.pad${B}[0]`).join(","),u=n.map((R,B)=>`uniforms.pad${B}[0] + uniforms.xShape${t>1?`[${B}]`:""}`).join(","),d=t>1?`${s}(${a})`:`${a}`,m=t>1?`${s}(${u})`:`${u}`,b=t>1?"any(paddedCoords < start)":"paddedCoords < start",T=t>1?"any(paddedCoords >= end)":"paddedCoords >= end",k=t>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t):"coords";return`
        let start = ${d};
        let end = ${m};
        if (${b} || ${T}) {
          setOutputAtIndex(index, ${e?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${k}));
        }
  `}class up{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((s,a)=>s[0]+e[a]+s[1]),this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map((s,a)=>{this.uniforms+=` pad${a} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${bd(this.xShape)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lp=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{paddings:u,constantValue:d}=s;if(u.every(T=>y.D5U.arraysEqual(T,[0,0])))return rr({inputs:{x:a},backend:t});if(y.D5U.sizeFromShape(a.shape)===0){const T=u.map((k,R)=>k[0]+a.shape[R]+k[1]);return zs({backend:t,attrs:{shape:T,value:d,dtype:a.dtype}})}const m=[{type:"float32",data:[d]}];u.map(T=>m.push({type:"int32",data:[T[0],T[1]]}));const b=new up(a.shape,u);return t.runWebGPUProgram(b,[a],a.dtype,m)},cp={kernelName:y.lyA,backendName:"webgpu",kernelFunc:lp};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dp=Gs({opType:A.POW}),hp={kernelName:y.pe_,backendName:"webgpu",kernelFunc:dp};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pp(n){const{inputs:e,backend:t}=n,{x:s,alpha:a}=e,u=new go(A.PRELU,s.shape,a.shape);return t.runWebGPUProgram(u,[s,a],"float32")}const fp={kernelName:y.o0g,backendName:"webgpu",kernelFunc:pp};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nu(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{axis:u,keepDims:d}=s;return ca(a,u,d,"prod",t)}const mp={kernelName:y.DlI,backendName:"webgpu",kernelFunc:Nu};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wd=n=>{const{backend:e,attrs:t}=n,{start:s,stop:a,step:u,dtype:d}=t,m=rl(s,a,u,d);return e.makeTensorInfo([m.length],d,m)},gp={kernelName:y.e6w,backendName:"webgpu",kernelFunc:wd};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yp=Gs({opType:A.DIV}),xp={kernelName:y.oHH,backendName:"webgpu",kernelFunc:yp};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bp=Vn({opType:Ft.RECIPROCAL}),wp={kernelName:y.$HU,backendName:"webgpu",kernelFunc:bp};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vd=Vn({opType:Ft.RELU}),vp={kernelName:y.qkr,backendName:"webgpu",kernelFunc:vd};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cp=Vn({opType:Ft.RELU6}),Sp={kernelName:y.SbG,backendName:"webgpu",kernelFunc:Cp};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ip{constructor(e,t,s){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,s,e[3]],this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${kt("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ep(n){const{inputs:e,backend:t,attrs:s}=n,{images:a}=e,{alignCorners:u,size:d,halfPixelCenters:m}=s,[b,T]=d,k=u&&b>1?1:0,R=u&&T>1?1:0,X=[{type:"float32",data:[k,R]},{type:"float32",data:[m?.5:0]}],oe=new Ip(a.shape,b,T);return t.runWebGPUProgram(oe,[a],"float32",X)}const Tp={kernelName:y._Yw,backendName:"webgpu",kernelFunc:Ep};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $p{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeBilinearBackprop_${t}`}getUserCode(){return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Np(n){const{inputs:e,backend:t,attrs:s}=n,{images:a,dy:u}=e,{alignCorners:d}=s,[,m,b]=a.shape,[,T,k]=u.shape,R=[d&&T>1?m-1:m,d&&k>1?b-1:b],B=[d&&T>1?T-1:T,d&&k>1?k-1:k],X=R[0]/B[0],oe=R[1]/B[1],ue=1/X,he=1/oe,Ue=Math.ceil(ue)*2+2,Xe=Math.ceil(he)*2+2,ot=new $p(a.shape,d),it=[{type:"int32",data:R},{type:"int32",data:B},{type:"float32",data:[X]},{type:"float32",data:[oe]},{type:"float32",data:[ue]},{type:"float32",data:[he]},{type:"int32",data:[Ue]},{type:"int32",data:[Xe]}];return t.runWebGPUProgram(ot,[u],u.dtype,it)}const kp={kernelName:y.zbQ,backendName:"webgpu",kernelFunc:Np};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rp{constructor(e,t,s,a){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,s,e[3]],this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=a,this.shaderKey=`resizeNearest_${a}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dp(n){const{inputs:e,backend:t,attrs:s}=n,{images:a}=e,{alignCorners:u,halfPixelCenters:d,size:m}=s,[b,T]=m,k=u&&b>1?1:0,R=u&&T>1?1:0,X=[{type:"float32",data:[k,R]},{type:"float32",data:[u?.5:0]}],oe=new Rp(a.shape,b,T,d);return t.runWebGPUProgram(oe,[a],a.dtype,X)}const _p={kernelName:y.dpD,backendName:"webgpu",kernelFunc:Dp};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ap{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeNearestNeigborBackprop_${t}`}getUserCode(){return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cd(n){const{inputs:e,backend:t,attrs:s}=n,{images:a,dy:u}=e,{alignCorners:d}=s,[,m,b]=a.shape,[,T,k]=u.shape,R=[d&&T>1?m-1:m,d&&k>1?b-1:b],B=[d&&T>1?T-1:T,d&&k>1?k-1:k],X=R[0]/B[0],oe=R[1]/B[1],ue=1/X,he=1/oe,Ue=Math.ceil(ue)*2+2,Xe=Math.ceil(he)*2+2,ot=new Ap(a.shape,d),it=[{type:"int32",data:R},{type:"int32",data:B},{type:"float32",data:[ue]},{type:"float32",data:[he]},{type:"int32",data:[Ue]},{type:"int32",data:[Xe]}];return t.runWebGPUProgram(ot,[u],u.dtype,it)}const Pp={kernelName:y.Hmb,backendName:"webgpu",kernelFunc:Cd};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dm{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Op(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{dims:u}=s,d=a.shape.length;if(d===0)return rr({inputs:{x:a},backend:t});const m=a.shape,b=[1,1,1,1];m.forEach((he,Ue)=>{const Xe=Ue+4-d;b[Xe]=he});const T=y.D5U.parseAxisParam(u,a.shape),k=[0,0,0,0];T.forEach(he=>{const Ue=he+4-d;k[Ue]=1});const R=[{type:"int32",data:k}],B=Zt({inputs:{x:a},backend:t,attrs:{shape:b}}),X=new Dm(b),oe=t.runWebGPUProgram(X,[B],B.dtype,R);t.disposeData(B.dataId);const ue=Zt({inputs:{x:oe},backend:t,attrs:{shape:m}});return t.disposeData(oe.dataId),ue}const Fp={kernelName:y.mKl,backendName:"webgpu",kernelFunc:Op};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bp{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof t=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${kt("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _m={kernelName:y.b9H,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:a,fillValue:u,center:d}=e,m=t,b=new Bp(s.shape,u),[T,k]=y.Wap.getImageCenter(d,s.shape[1],s.shape[2]),R=[{type:"float32",data:[T]},{type:"float32",data:[k]},{type:"float32",data:[Math.sin(a)]},{type:"float32",data:[Math.cos(a)]}];return typeof u=="number"?R.push({type:"float32",data:[Number.parseFloat(u.toFixed(2))]}):R.push({type:"float32",data:u}),m.runWebGPUProgram(b,[s],s.dtype,R)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lp=Vn({opType:Ft.ROUND}),Up={kernelName:y.e07,backendName:"webgpu",kernelFunc:Lp};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mp=Vn({opType:Ft.RSQRT,cpuKernelImpl:ol}),Am={kernelName:y.bV0,backendName:"webgpu",kernelFunc:Mp};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oi{constructor(e,t,s,a,u,d,m,b=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=d,this.type=m,this.sumDupeIndices=b,this.dispatchLayout=Gt(e),this.dispatch=Ut(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${s}_${a}_${this.sliceDimGreaterThanOne}_${m}_${b}_${u.length}`;const T=Cn(u.length);this.uniforms=`sliceDim : i32, strides: ${T}, updatesSize: i32,`,this.updatesRank=a,this.indicesRank=s}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");const t=`getIndices(${e})`,s=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let a="",u="";this.dispatchLayout.x.length===1?(a="flattenedIndex",u=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(a="vec2<i32>(flattenedIndex, coords[1])",u=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const m=`getUpdates(${Array.from({length:this.updatesRank},(T,k)=>`coords[${k}]`).join(", ")})`;return`
    ${u}
      ${kt("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${s};
          }
          let updateValue =
              ${Rs(this.type)}(${m});
          let flatIndex = getOutputIndexFromCoords(${a});

          ${this.sumDupeIndices?fn("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wp(n){const{inputs:e,backend:t,attrs:s}=n,{indices:a,updates:u}=e,{shape:d}=s,{sliceRank:m,numUpdates:b,sliceSize:T,strides:k,outputSize:R}=y.Wap.calculateShapes(u,a,d),B=[R/T,T];if(R===0)return t.makeTensorInfo(d,a.dtype);const X=Zt({inputs:{x:a},backend:t,attrs:{shape:[b,m]}}),oe=Zt({inputs:{x:u},backend:t,attrs:{shape:[b,T]}}),ue=oe.dtype,he=zs({backend:t,attrs:{shape:B,value:0,dtype:ue}}),Ue=y.D5U.sizeFromShape(oe.shape),Xe=[{type:"int32",data:[m]},{type:"int32",data:k},{type:"int32",data:[Ue]}],ot=new Oi(oe.shape,m,X.shape.length,oe.shape.length,k,B,ue),it=t.runWebGPUProgram(ot,[oe,X],ue,Xe,he),mt=Zt({inputs:{x:it},backend:t,attrs:{shape:d}});return t.disposeData(X.dataId),t.disposeData(oe.dataId),t.disposeData(it.dataId),mt}const Vp={kernelName:y.xQA,backendName:"webgpu",kernelFunc:Wp};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zp{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey=`search_sorted_${t}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gp(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:a,values:u}=e,{side:d}=s,m=new zp([u.shape[0],u.shape[1]],d),b=[{type:"int32",data:[a.shape[1]]}];return t.runWebGPUProgram(m,[a,u],"int32",b)}const Hp={kernelName:y.nr8,backendName:"webgpu",kernelFunc:Gp};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jp{constructor(e,t,s){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=s,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)t="resRC",e="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],d=[];for(let m=0;m<this.outputShape.length;m++)d.push(`${a[m]}`),m<this.cRank&&u.push(`${a[m]}`);e=u.join(),t=d.join()}return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t}));
          } else {
            setOutputAtIndex(index, getB(${t}));
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kp(n){const{inputs:e,backend:t}=n,{condition:s,t:a,e:u}=e,d=new jp(s.shape.length,a.shape,a.shape.length);return t.runWebGPUProgram(d,[s,a,u],(0,y.x8V)(a.dtype,u.dtype))}const Xp={kernelName:y.PhF,backendName:"webgpu",kernelFunc:Kp};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yp=Vn({opType:Ft.SELU}),qp={kernelName:y.oFR,backendName:"webgpu",kernelFunc:Yp};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qp=Vn({opType:Ft.SIGMOID}),Zp={kernelName:y.a5O,backendName:"webgpu",kernelFunc:Qp};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jp=Vn({opType:Ft.SIGN}),ef={kernelName:y.i5y,backendName:"webgpu",kernelFunc:Jp};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tf=Vn({opType:Ft.SIN}),nf={kernelName:y.RQH,backendName:"webgpu",kernelFunc:tf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sf=Vn({opType:Ft.SINH}),rf={kernelName:y.wYB,backendName:"webgpu",kernelFunc:sf};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const of=Vn({opType:Ft.SOFTPLUS}),af={kernelName:y.MRv,backendName:"webgpu",kernelFunc:of};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uf{constructor(e,t,s,a,u,d){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const m=new Array(a.length);for(let b=0;b<m.length;b++)m[b]=a[u[b]];this.outputShape=m,this.newDim=u,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=t,this.uniforms+=`reshapedPaddedXShape : ${Cn(a.length)}, paddedXShapeStrides : ${Cn(d)}, `,s.map((b,T)=>{this.uniforms+=` pad${T} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${u}`}getUserCode(){const e=Cn(this.outputShape.length),t=wa(this.newDim);return`
      ${zr(this.paddedXShape,"PaddedX")}
      ${kt("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${t}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${bd(this.xShape,!0)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pm=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{blockShape:u,paddings:d}=s;y.D5U.assert(a.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const m=u.reduce((Xe,ot)=>Xe*ot),b=[[0,0]];b.push(...d);for(let Xe=1+u.length;Xe<a.shape.length;++Xe)b.push([0,0]);const T=b.map((Xe,ot)=>Xe[0]+a.shape[ot]+Xe[1]),k=y.Wap.getReshaped(T,u,m,!1),R=y.Wap.getPermuted(k.length,u.length,!1),B=y.Wap.getReshapedPermuted(T,u,m,!1),X=y.D5U.computeStrides(T),oe=new uf(a.shape,T,b,k,R,X.length),ue=[{type:"int32",data:k},{type:"int32",data:X}];b.map(Xe=>ue.push({type:"int32",data:[Xe[0],Xe[1]]}));const he=t.runWebGPUProgram(oe,[a],a.dtype,ue),Ue=Zt({inputs:{x:he},backend:t,attrs:{shape:B}});return t.disposeData(he.dataId),Ue},lf={kernelName:y.TQc,backendName:"webgpu",kernelFunc:Pm};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cf{constructor(e,t,s){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=s,this.dispatchLayout=Gt([t]),this.dispatch=Ut(this.dispatchLayout,[t],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${kt("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${fn("&result[outIndex]","value",this.type)}
      }
    }
  `}}class Om{constructor(e,t){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=Gt(t),this.dispatch=Ut(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${kt("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${fn("&result[segmentId]","1","int32")}
      }
    }
  `}}class df{constructor(e,t){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=t,this.dispatchLayout=Gt(e),this.dispatch=Ut(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${kt("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sd(n,e,t,s=!1,a){const d=y.D5U.sizeFromShape(n.shape)/n.shape[0],m=n.dtype,b=y.D5U.sizeFromShape(e.shape),T=a.readSync(t.dataId),R=b>0?T[b-1]+1:0;let B;const X=n.shape.slice();X[0]=R;const oe=b*d,ue=zs({backend:a,attrs:{shape:X,value:0,dtype:m}});B=new cf(X,oe,m);let he=[{type:"int32",data:[d]},{type:"int32",data:[oe]}];const Ue=a.runWebGPUProgram(B,[n,e,t],m,he,ue);if(s)return Ue;const Xe=zs({backend:a,attrs:{shape:[R],value:0,dtype:"int32"}});B=new Om(R,t.shape);const ot=a.runWebGPUProgram(B,[t],"int32",null,Xe),it=zs({backend:a,attrs:{shape:X,value:0,dtype:m}});B=new df(X,m),he=[{type:"int32",data:[d]}];const mt=a.runWebGPUProgram(B,[Ue,ot],m,he,it);return a.disposeData(Ue.dataId),a.disposeData(ot.dataId),mt}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zc(n){const{inputs:e,backend:t}=n,{data:s,indices:a,segmentIds:u}=e;return Sd(s,a,u,!1,t)}const hf={kernelName:y.w3H,backendName:"webgpu",kernelFunc:Zc};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pf(n){const{inputs:e,backend:t}=n,{data:s,indices:a,segmentIds:u}=e;return Sd(s,a,u,!0,t)}const ff={kernelName:y.ZjV,backendName:"webgpu",kernelFunc:pf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mf{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[a]*t[a];this.outputShape=s,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=gf(this.rank,"uniforms.");return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}}function gf(n,e=""){if(n>=5)throw Error(`Tile for rank ${n} is not yet supported`);if(n===1)return`(resRC % ${e}aShape)`;const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let a=0;a<n;a++)s.push(`(${t[a]} % ${e}aShape[${a}])`);return s.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jc(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{reps:u}=s;if(t.shouldExecuteOnCPU([a])||a.dtype==="string"||a.shape.length>=5){const b=t.readSync(a.dataId),T=a.dtype==="string"?b.map(B=>y.D5U.decodeString(B)):b,k=(0,y.f3b)(a.shape,a.dtype,T),R=Ji(k,u);return t.makeTensorInfo(R.shape,R.dtype,R.values)}const d=new mf(a.shape,u);return t.runWebGPUProgram(d,[a],a.dtype)}const yf={kernelName:y.n9L,backendName:"webgpu",kernelFunc:Jc};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xf(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:a,sparseValues:u,defaultValue:d}=e,{outputShape:m}=s,{sliceRank:b,numUpdates:T,sliceSize:k,strides:R,outputSize:B}=y.Wap.calculateShapes(u,a,m),X=!1;if(u.dtype==="string"){const Mt=t.bufferSync(a),Bt=t.bufferSync(u),en=y.D5U.decodeString(t.readSync(d.dataId)[0]),hn=al(Mt,Bt,m,B,k,T,b,R,en,X);return t.makeTensorInfo(m,hn.dtype,hn.values)}const oe=[B/k,k],ue=Zt({inputs:{x:a},backend:t,attrs:{shape:[T,b]}}),he=u.shape.length?Zt({inputs:{x:u},backend:t,attrs:{shape:[T,k]}}):rr({inputs:{x:u},backend:t}),Ue=he.dtype,Xe=t.makeTensorInfo([],Ue,y.D5U.makeZerosTypedArray(1,Ue)),ot=Zt({inputs:{x:d},backend:t,attrs:{shape:Array(oe.length).fill(1)}}),it=Jc({inputs:{x:ot},backend:t,attrs:{reps:oe}}),mt=y.D5U.sizeFromShape([T,k]),wt=[{type:"int32",data:[b]},{type:"int32",data:R},{type:"int32",data:[mt]}];switch(T){case 0:break;case 1:{const Mt=new Oi([T,k],b,ue.shape.length,he.shape.length,R,oe,Ue,X);t.runWebGPUProgram(Mt,[he,ue],Ue,wt,it)}break;default:{const Mt=new Oi([T,k],b,ue.shape.length,Xe.shape.length,R,oe,Ue,X);t.runWebGPUProgram(Mt,[Xe,ue],Ue,wt,it)}{const Mt=new Oi([T,k],b,ue.shape.length,he.shape.length,R,oe,Ue);t.runWebGPUProgram(Mt,[he,ue],Ue,wt,it)}}const St=Zt({inputs:{x:it},backend:t,attrs:{shape:m}});return t.disposeData(ue.dataId),t.disposeData(he.dataId),t.disposeData(ot.dataId),t.disposeData(Xe.dataId),t.disposeData(it.dataId),St}const bf={kernelName:y.D2d,backendName:"webgpu",kernelFunc:xf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wf(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{numOrSizeSplits:u,axis:d}=s,m=y.D5U.parseAxisParam(d,a.shape)[0],b=y.Wap.prepareSplitSize(a,u,m),T=a.shape.length,k=new Array(T).fill(0),R=a.shape.slice();return b.map(B=>{const X=[...R];X[m]=B;const oe=or({inputs:{x:a},backend:t,attrs:{begin:k,size:X}});return k[m]+=B,oe})}const vf={kernelName:y.L8s,backendName:"webgpu",kernelFunc:wf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cf=Vn({opType:Ft.SQRT}),Sf={kernelName:y.FKq,backendName:"webgpu",kernelFunc:Cf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fm={kernelName:y.bK0,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e,a=new ba(t.shape,Ft.SQUARE);return s.runWebGPUProgram(a,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const If=Gs({opType:A.SQUARED_DIFFERENCE}),Ef={kernelName:y._tC,backendName:"webgpu",kernelFunc:If};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bm({inputs:n,attrs:e,backend:t}){const{x:s}=n,a=new ba(s.shape,Ft.STEP,"stepAlpha : f32,"),u=[{type:"float32",data:[e.alpha]}];return t.runWebGPUProgram(a,[s],s.dtype,u)}const Tf={kernelName:y.h8e,backendName:"webgpu",kernelFunc:Bm};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $f{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=Cn(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){const e=this.outputShape.length;let t="";if(e===1)t="coords * uniforms.strides + uniforms.begin";else{let a=0;t=this.outputShape.map((u,d)=>(a++,this.outputShape.length===1?`coords * uniforms.strides[${d}] + uniforms.begin[${d}]`:`coords[${a-1}] * uniforms.strides[${d}] + uniforms.begin[${d}]`)).join(",")}return`
       ${kt("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${t}));
         }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nf(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{begin:u,end:d,strides:m,beginMask:b,endMask:T,ellipsisMask:k,newAxisMask:R,shrinkAxisMask:B}=s,{finalShapeSparse:X,finalShape:oe,isIdentity:ue,sliceDim0:he,isSimpleSlice:Ue,begin:Xe,end:ot,strides:it}=y.kuN.sliceInfo(a.shape,u,d,m,b,T,k,R,B);let mt;if(ue)mt=Zt({inputs:{x:a},backend:t,attrs:{shape:oe}});else if(he||Ue){y.D5U.assert(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);const wt=y.kuN.computeOutShape(Xe,ot,it),St=or({inputs:{x:a},backend:t,attrs:{begin:Xe,size:wt}});mt=Zt({inputs:{x:St},backend:t,attrs:{shape:oe}}),t.disposeData(St.dataId)}else if(t.shouldExecuteOnCPU([a])){const St=t.readSync(a.dataId),Mt=(0,y.f3b)(a.shape,a.dtype,St),Bt=ul(X,Mt,it,Xe);mt=t.makeTensorInfo(oe,a.dtype,Bt.values)}else{const St=new $f(X),Mt=[{type:"int32",data:Xe},{type:"int32",data:it}],Bt=t.runWebGPUProgram(St,[a],a.dtype,Mt);mt=Zt({inputs:{x:Bt},backend:t,attrs:{shape:oe}}),t.disposeData(Bt.dataId)}return mt}const kf={kernelName:y.jQk,backendName:"webgpu",kernelFunc:Nf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rf(n){const{inputs:e,backend:t,attrs:s}=n,{separator:a,nGramWidths:u,leftPad:d,rightPad:m,padWidth:b,preserveShortSequences:T}=s,{data:k,dataSplits:R}=e,B=t.readSync(k.dataId),X=t.readSync(R.dataId),[oe,ue]=Ja(B,X,a,u,d,m,b,T);return[t.makeTensorInfo([oe.length],"string",oe),t.makeTensorInfo(R.shape,"int32",ue)]}const Df={kernelName:y._JP,backendName:"webgpu",kernelFunc:Rf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lm=Gs({opType:A.SUB,cpuKernelImpl:ll,supportsComplex:!0}),_f={kernelName:y.Tr8,backendName:"webgpu",kernelFunc:Lm};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Af=Vn({opType:Ft.TAN}),Um={kernelName:y.sEM,backendName:"webgpu",kernelFunc:Af};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pf=Vn({opType:Ft.TANH}),Of={kernelName:y.MIZ,backendName:"webgpu",kernelFunc:Pf};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ff(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:a,indices:u,updates:d}=e,{}=s,{sliceRank:m,numUpdates:b,sliceSize:T,strides:k,outputSize:R}=y.Wap.calculateShapes(d,u,a.shape),B=[R/T,T];if(R===0)return t.makeTensorInfo(a.shape,u.dtype);const X=[],oe=Zt({inputs:{x:u},backend:t,attrs:{shape:[b,m]}});X.push(oe);const ue=Zt({inputs:{x:d},backend:t,attrs:{shape:[b,T]}});X.push(ue);const he=Zt({inputs:{x:a},backend:t,attrs:{shape:B}});X.push(he);const Ue=Jc({inputs:{x:he},backend:t,attrs:{reps:Array(B.length).fill(1)}}),Xe=new Oi([b,T],m,oe.shape.length,ue.shape.length,k,B,a.dtype,!1),ot=y.D5U.sizeFromShape([b,T]),it=[{type:"int32",data:[m]},{type:"int32",data:k},{type:"int32",data:[ot]}],mt=t.runWebGPUProgram(Xe,[ue,oe],he.dtype,it,Ue);X.push(mt);const wt=Zt({inputs:{x:mt},backend:t,attrs:{shape:a.shape}});return X.forEach(St=>t.disposeData(St.dataId)),wt}const Bf={kernelName:y.SIB,backendName:"webgpu",kernelFunc:Ff};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lf{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${kt("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}class Uf{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${kt("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oi(n,e){e!==null&&n.disposeData(e.dataId)}function Id(n){let e=1;for(;e<n;)e*=2;return e}function Mf(n){const{inputs:e,backend:t,attrs:s}=n,{x:a}=e,{k:u,sorted:d}=s,m=a.shape,b=m[m.length-1];if(t.shouldExecuteOnCPU([a])){const mt=t.readSync(a.dataId),[wt,St]=cl(mt,m,a.dtype,u,d);return[t.makeTensorInfo(wt.shape,wt.dtype,wt.values),t.makeTensorInfo(St.shape,St.dtype,St.values)]}if(u===0)return m[m.length-1]=0,[t.makeTensorInfo(m,a.dtype,[]),t.makeTensorInfo(m,"int32",[])];if(b===1)return[a,zs({attrs:{shape:m,dtype:"int32",value:0},backend:t})];const k=y.D5U.sizeFromShape(m)/b,R=Zt({inputs:{x:a},attrs:{shape:[k,b]},backend:t}),B=Id(u),X=Id(b);let oe=null;const ue=()=>oe===null?[R,R]:[R,oe],he=(mt,wt,St)=>{const Mt=ue(),Bt=new Lf(St),hn=[{type:"int32",data:[b]},{type:"int32",data:[oe===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[mt]},{type:"int32",data:[wt]}],Nn=oe;oe=t.runWebGPUProgram(Bt,Mt,"int32",hn),oi(t,Nn)};for(let mt=1;mt<B;mt*=2){const wt=mt*2;for(let St=mt;St>=1;St/=2)he(wt,St,[k,X])}for(let mt=X;mt>B;mt/=2){const wt=ue(),St=new Uf([k,mt/2]),Bt=[{type:"int32",data:[b]},{type:"int32",data:[oe===null?1:0]},{type:"int32",data:[B]}],en=oe;oe=t.runWebGPUProgram(St,wt,"int32",Bt),oi(t,en);const hn=B/2,Nn=hn*2;for(let vn=hn;vn>=1;vn/=2)he(Nn,vn,oe.shape)}let Ue=oe;oe=or({inputs:{x:oe},backend:t,attrs:{begin:0,size:[k,u]}}),oi(t,Ue);let Xe=dd({inputs:{x:R,indices:oe},backend:t,attrs:{axis:1,batchDims:1}});oi(t,R);const ot=m.slice(0,-1);ot.push(u),Ue=oe,oe=Zt({inputs:{x:oe},attrs:{shape:ot},backend:t}),oi(t,Ue);const it=Xe;return Xe=Zt({inputs:{x:Xe},attrs:{shape:ot},backend:t}),oi(t,it),[Xe,oe]}const Wf={kernelName:y.cWu,backendName:"webgpu",kernelFunc:Mf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vf{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${kt("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zf(n){const{inputs:e,backend:t,attrs:s}=n,{image:a,transforms:u}=e,{interpolation:d,fillMode:m,fillValue:b,outputShape:T}=s,[k,R,B,X]=a.shape,[oe,ue]=T??[R,B],he=[k,oe,ue,X],Ue=new Vf(he),Xe=d==="nearest"?1:2;let ot;switch(m){case"constant":ot=1;break;case"reflect":ot=2;break;case"wrap":ot=3;break;case"nearest":ot=4;break;default:ot=1;break}const it=[{type:"int32",data:[Xe]},{type:"int32",data:[ot]},{type:"float32",data:[b]}];return t.runWebGPUProgram(Ue,[a,u],"float32",it)}const Gf={kernelName:y.wx7,backendName:"webgpu",kernelFunc:zf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hf(n){const{inputs:e,backend:t,attrs:s}=n,{value:a}=e;let{axis:u}=s;u<0&&(u+=a.shape.length);const d=a,m=d.shape.length,b=a.shape[u],T=new Array(m-1);let k=0;for(let ue=0;ue<m;ue++)ue!==u&&(T[k++]=d.shape[ue]);const R=[],B=new Array(m).fill(0),X=d.shape.slice();X[u]=1;const oe=new Array(b);for(let ue=0;ue<oe.length;ue++){B[u]=ue;const he=or({inputs:{x:d},backend:t,attrs:{begin:B,size:X}}),Ue=Zt({inputs:{x:he},backend:t,attrs:{shape:T}});oe[ue]=Ue,R.push(he)}return R.forEach(ue=>t.disposeData(ue.dataId)),oe}const jf={kernelName:y.ToN,backendName:"webgpu",kernelFunc:Hf};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kf{constructor(e,t,s){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.dispatchLayout=Gt(e),this.dispatch=Ut(this.dispatchLayout,e,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${s} type.`);this.type=s,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${kt("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${fn("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ed(n){const{inputs:e,backend:t,attrs:s}=n,{x:a,segmentIds:u}=e,{numSegments:d}=s,m=a.shape.length,b=[];let T=0;const k=y.Wap.getAxesPermutation([T],m);let R=a;k!=null&&(R=Ds({inputs:{x:a},backend:t,attrs:{perm:k}}),b.push(R),T=y.Wap.getInnerMostAxes(1,m)[0]);const B=y.Wap.segment_util.computeOutShape(R.shape,T,d),X=y.D5U.sizeFromShape([R.shape[T]]),oe=Zt({inputs:{x:R},backend:t,attrs:{shape:[-1,X]}});b.push(oe);const ue=a.dtype,he=[oe.shape[0],d],Ue=zs({backend:t,attrs:{shape:he,value:0,dtype:ue}}),Xe=new Kf(oe.shape,he,ue),ot=[{type:"int32",data:[d]},{type:"int32",data:[y.D5U.sizeFromShape(oe.shape)]}],it=t.runWebGPUProgram(Xe,[oe,u],ue,ot,Ue),mt=Zt({inputs:{x:it},backend:t,attrs:{shape:B}});b.push(it);let wt=mt;if(k!=null){b.push(mt);const St=y.Wap.getUndoAxesPermutation(k);wt=Ds({inputs:{x:wt},backend:t,attrs:{perm:St}})}return b.forEach(St=>t.disposeData(St.dataId)),wt}const Xf={kernelName:y.Qvg,backendName:"webgpu",kernelFunc:Ed};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yf=[dr,dl,hl,Pa,pl,gl,tu,Cl,Sl,El,Tl,Nl,kl,Dl,su,$i,ou,Ml,au,iu,Gl,uu,Xl,ql,Zl,nc,Ki,oc,uc,mu,yc,vc,Cc,Sc,Ic,Tc,Nc,Dc,Ac,Oc,Bc,ld,zc,Gc,Wc,jc,Kc,w,$,j,Dt,qt,dn,Ks,$s,Ln,xs,hs,Zr,Bu,Wa,ym,Ia,qc,zd,Gd,wm,Kd,Xd,qd,Im,Uu,Jd,ac,th,Em,sh,$m,ah,km,lh,ph,dh,mh,hd,xh,Ch,Eh,Ti,$h,kh,Bh,Dh,Oh,Uh,Pl,Wh,zh,Hh,Kh,Qh,ye,gd,yd,ep,cu,sp,op,ip,cp,hp,fp,mp,gp,Yl,xp,wp,vp,Sp,Lu,Tp,kp,_p,Pp,Fp,_m,Up,Am,Vp,Hp,Xp,qp,Zp,ef,nf,rf,ei,Tf,kf,Df,Rm,af,lf,hf,ff,bf,vf,Sf,Fm,Ef,_f,qe,Um,Of,Bf,yf,Wf,Gf,Oa,jf,Xf,rp];for(const n of Yf)(0,y.wCN)(n);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var qf=function(n,e){return(qf=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,s){t.__proto__=s}||function(t,s){for(var a in s)Object.prototype.hasOwnProperty.call(s,a)&&(t[a]=s[a])})(n,e)};function Td(n,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function t(){this.constructor=n}qf(n,e),n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var is=function(){return(is=Object.assign||function(n){for(var e,t=1,s=arguments.length;t<s;t++)for(var a in e=arguments[t])Object.prototype.hasOwnProperty.call(e,a)&&(n[a]=e[a]);return n}).apply(this,arguments)};function zn(n,e,t,s){return new(t||(t=Promise))(function(a,u){function d(T){try{b(s.next(T))}catch(k){u(k)}}function m(T){try{b(s.throw(T))}catch(k){u(k)}}function b(T){var k;T.done?a(T.value):(k=T.value,k instanceof t?k:new t(function(R){R(k)})).then(d,m)}b((s=s.apply(n,e||[])).next())})}function jn(n,e){var t,s,a,u,d={label:0,sent:function(){if(1&a[0])throw a[1];return a[1]},trys:[],ops:[]};return u={next:m(0),throw:m(1),return:m(2)},typeof Symbol=="function"&&(u[Symbol.iterator]=function(){return this}),u;function m(b){return function(T){return function(k){if(t)throw new TypeError("Generator is already executing.");for(;d;)try{if(t=1,s&&(a=2&k[0]?s.return:k[0]?s.throw||((a=s.return)&&a.call(s),0):s.next)&&!(a=a.call(s,k[1])).done)return a;switch(s=0,a&&(k=[2&k[0],a.value]),k[0]){case 0:case 1:a=k;break;case 4:return d.label++,{value:k[1],done:!1};case 5:d.label++,s=k[1],k=[0];continue;case 7:k=d.ops.pop(),d.trys.pop();continue;default:if(a=d.trys,!((a=a.length>0&&a[a.length-1])||k[0]!==6&&k[0]!==2)){d=0;continue}if(k[0]===3&&(!a||k[1]>a[0]&&k[1]<a[3])){d.label=k[1];break}if(k[0]===6&&d.label<a[1]){d.label=a[1],a=k;break}if(a&&d.label<a[2]){d.label=a[2],d.ops.push(k);break}a[2]&&d.ops.pop(),d.trys.pop();continue}k=e.call(n,d)}catch(R){k=[6,R],s=0}finally{t=a=0}if(5&k[0])throw k[1];return{value:k[0]?k[1]:void 0,done:!0}}([b,T])}}}function Va(n,e,t){if(t||arguments.length===2)for(var s,a=0,u=e.length;a<u;a++)!s&&a in e||(s||(s=Array.prototype.slice.call(e,0,a)),s[a]=e[a]);return n.concat(s||Array.prototype.slice.call(e))}var Qo=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],Fi=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],Qf={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},Zf={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},Jf=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],em=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function ku(n){return n instanceof SVGAnimatedLength?n.baseVal.value:n}function $d(n){return zn(this,void 0,void 0,function(){var e,t;return jn(this,function(s){switch(s.label){case 0:return e=document.createElement("canvas"),n instanceof y.esB?[4,y.Xhn.toPixels(n,e)]:[3,2];case 1:return s.sent(),[3,3];case 2:e.width=ku(n.width),e.height=ku(n.height),t=e.getContext("2d"),n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0),s.label=3;case 3:return[2,e]}})})}function Nd(n){return zn(this,void 0,void 0,function(){var e,t,s,a,u,d;return jn(this,function(m){switch(m.label){case 0:return n instanceof y.esB?(e=n.shape.slice(0,2),t=e[0],s=e[1],a=ImageData.bind,[4,y.Xhn.toPixels(n)]):[3,2];case 1:return[2,new(a.apply(ImageData,[void 0,m.sent(),s,t]))];case 2:return u=document.createElement("canvas"),d=u.getContext("2d"),u.width=ku(n.width),u.height=ku(n.height),d.drawImage(n,0,0),[2,d.getImageData(0,0,u.width,u.height)]}})})}function tm(n){return zn(this,void 0,void 0,function(){var e,t;return jn(this,function(s){switch(s.label){case 0:return n instanceof SVGImageElement||n instanceof OffscreenCanvas?[4,$d(n)]:[3,2];case 1:return t=s.sent(),[3,3];case 2:t=n,s.label=3;case 3:return e=t,[2,y.Xhn.fromPixels(e,4)]}})})}function kd(n){if(n<0||n>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(n));if(!Number.isInteger(n))throw new Error("Mask value must be an integer but got ".concat(n))}var Bi={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},nm=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return zn(this,void 0,void 0,function(){return jn(this,function(e){return[2,this.mask]})})},n.prototype.toImageData=function(){return zn(this,void 0,void 0,function(){return jn(this,function(e){return[2,Nd(this.mask)]})})},n.prototype.toTensor=function(){return zn(this,void 0,void 0,function(){return jn(this,function(e){return[2,tm(this.mask)]})})},n.prototype.getUnderlyingType=function(){return"canvasimagesource"},n}();function Mm(n){return kd(n),"person"}var sm=function(){function n(e){var t,s=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new ve.Pose({locateFile:function(a,u){if(e.solutionPath){var d=e.solutionPath.replace(/\/+$/,"");return"".concat(d,"/").concat(a)}return"".concat(u,"/").concat(a)}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;case"full":default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(a){if(s.height=a.image.height,s.width=a.image.width,a.poseLandmarks==null)s.poses=[];else{var u=s.translateOutput(a.poseLandmarks,a.poseWorldLandmarks);a.segmentationMask&&(u.segmentation={maskValueToLabel:Mm,mask:new nm(a.segmentationMask)}),s.poses=[u]}})}return n.prototype.translateOutput=function(e,t){var s=this,a={keypoints:e.map(function(u,d){return{x:u.x*s.width,y:u.y*s.height,z:u.z,score:u.visibility,name:Fi[d]}})};return t!=null&&(a.keypoints3D=t.map(function(u,d){return{x:u.x,y:u.y,z:u.z,score:u.visibility,name:Fi[d]}})),a},n.prototype.estimatePoses=function(e,t,s){return zn(this,void 0,void 0,function(){var a,u;return jn(this,function(d){switch(d.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof y.esB?(u=ImageData.bind,[4,y.Xhn.toPixels(e)]):[3,2];case 1:return a=new(u.apply(ImageData,[void 0,d.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:a=e,d.label=3;case 3:return e=a,[4,this.poseSolution.send({image:e},s)];case 4:return d.sent(),[2,this.poses]}})})},n.prototype.dispose=function(){this.poseSolution.close()},n.prototype.reset=function(){this.poseSolution.reset()},n.prototype.initialize=function(){return this.poseSolution.initialize()},n}();function rm(n){return zn(this,void 0,void 0,function(){var e,t;return jn(this,function(s){switch(s.label){case 0:return e=function(a){if(a==null)return is({},Bi);var u=is({},a);return u.runtime="mediapipe",u.enableSegmentation==null&&(u.enableSegmentation=Bi.enableSegmentation),u.enableSmoothing==null&&(u.enableSmoothing=Bi.enableSmoothing),u.smoothSegmentation==null&&(u.smoothSegmentation=Bi.smoothSegmentation),u.modelType==null&&(u.modelType=Bi.modelType),u}(n),[4,(t=new sm(e)).initialize()];case 1:return s.sent(),[2,t]}})})}function Li(n){return n instanceof y.esB?{height:n.shape[0],width:n.shape[1]}:{height:n.height,width:n.width}}function Rd(n){return n-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}function ed(n){return n instanceof y.esB?n:y.Xhn.fromPixels(n)}function Dd(n,e,t){return td(t,"inputResolution"),[1/t.width*n[0][0]*e.width,1/t.height*n[0][1]*e.width,n[0][3]*e.width,1/t.width*n[1][0]*e.height,1/t.height*n[1][1]*e.height,n[1][3]*e.height,0,0]}function td(n,e){y.D5U.assert(n.width!==0,function(){return"".concat(e," width cannot be 0.")}),y.D5U.assert(n.height!==0,function(){return"".concat(e," height cannot be 0.")})}function nd(n,e,t){var s=t.rotationVectorStartKeypointIndex,a=t.rotationVectorEndKeypointIndex,u=n.locationData,d=u.relativeKeypoints[s].x*e.width,m=u.relativeKeypoints[s].y*e.height,b=u.relativeKeypoints[a].x*e.width,T=u.relativeKeypoints[a].y*e.height,k=2*Math.sqrt((b-d)*(b-d)+(T-m)*(T-m)),R=function(B,X,oe){var ue,he=B.locationData,Ue=oe.rotationVectorStartKeypointIndex,Xe=oe.rotationVectorEndKeypointIndex;ue=oe.rotationVectorTargetAngle?oe.rotationVectorTargetAngle:Math.PI*oe.rotationVectorTargetAngleDegree/180;var ot=he.relativeKeypoints[Ue].x*X.width,it=he.relativeKeypoints[Ue].y*X.height,mt=he.relativeKeypoints[Xe].x*X.width,wt=he.relativeKeypoints[Xe].y*X.height;return Rd(ue-Math.atan2(-(wt-it),mt-ot))}(n,e,t);return{xCenter:d/e.width,yCenter:m/e.height,width:k/e.width,height:k/e.height,rotation:R}}function _d(n){if(n.length!==16)throw new Error("Array length must be 16 but got ".concat(n.length));return[[n[0],n[1],n[2],n[3]],[n[4],n[5],n[6],n[7]],[n[8],n[9],n[10],n[11]],[n[12],n[13],n[14],n[15]]]}function Ru(n,e,t,s,a,u,d){return n[e][a]*(n[t][u]*n[s][d]-n[t][d]*n[s][u])}function Rr(n,e,t){var s=(e+1)%4,a=(e+2)%4,u=(e+3)%4,d=(t+1)%4,m=(t+2)%4,b=(t+3)%4;return Ru(n,s,a,u,d,m,b)+Ru(n,a,u,s,d,m,b)+Ru(n,u,s,a,d,m,b)}function Ad(n,e,t){t===void 0&&(t={ignoreRotation:!1});for(var s=[],a=0,u=n;a<u.length;a++){var d=u[a],m=d.x-.5,b=d.y-.5,T=t.ignoreRotation?0:e.rotation,k=Math.cos(T)*m-Math.sin(T)*b,R=Math.sin(T)*m+Math.cos(T)*b;k=k*e.width+e.xCenter,R=R*e.height+e.yCenter;var B=d.z*e.width,X=is({},d);X.x=k,X.y=R,X.z=B,s.push(X)}return s}function Pd(n,e){var t=function(s,a,u,d){var m=a-s,b=d-u;if(m===0)throw new Error("Original min and max are both ".concat(s,", range cannot be 0."));var T=b/m;return{scale:T,offset:u-s*T}}(0,255,e[0],e[1]);return(0,y.lub)(function(){return(0,y.IHx)((0,y.dC7)(n,t.scale),t.offset)})}function pa(n,e,t){var s,a,u,d,m,b,T,k,R,B,X,oe,ue,he,Ue=e.outputTensorSize,Xe=e.keepAspectRatio,ot=e.borderMode,it=e.outputTensorFloatRange,mt=Li(n),wt=function(Bt,en){return en?{xCenter:en.xCenter*Bt.width,yCenter:en.yCenter*Bt.height,width:en.width*Bt.width,height:en.height*Bt.height,rotation:en.rotation}:{xCenter:.5*Bt.width,yCenter:.5*Bt.height,width:Bt.width,height:Bt.height,rotation:0}}(mt,t),St=function(Bt,en,hn){if(hn===void 0&&(hn=!1),!hn)return{top:0,left:0,right:0,bottom:0};var Nn=en.height,vn=en.width;td(en,"targetSize"),td(Bt,"roi");var On,Qn,ts=Nn/vn,xo=Bt.height/Bt.width,Wo=0,Vo=0;return ts>xo?(On=Bt.width,Qn=Bt.width*ts,Vo=(1-xo/ts)/2):(On=Bt.height/ts,Qn=Bt.height,Wo=(1-ts/xo)/2),Bt.width=On,Bt.height=Qn,{top:Vo,left:Wo,right:Wo,bottom:Vo}}(wt,Ue,Xe),Mt=(s=wt,a=mt.width,u=mt.height,d=!1,m=s.width,b=s.height,T=d?-1:1,k=Math.cos(s.rotation),R=Math.sin(s.rotation),B=s.xCenter,X=s.yCenter,oe=1/a,ue=1/u,(he=new Array(16))[0]=m*k*T*oe,he[1]=-b*R*oe,he[2]=0,he[3]=(-.5*m*k*T+.5*b*R+B)*oe,he[4]=m*R*T*ue,he[5]=b*k*ue,he[6]=0,he[7]=(-.5*b*k-.5*m*R*T+X)*ue,he[8]=0,he[9]=0,he[10]=m*oe,he[11]=0,he[12]=0,he[13]=0,he[14]=0,he[15]=1,_d(he));return{imageTensor:(0,y.lub)(function(){var Bt=ed(n),en=(0,y.odF)(Dd(Mt,mt,Ue),[1,8]),hn=ot==="zero"?"constant":"nearest",Nn=y.BHj.transform((0,y.dt4)((0,y.pju)(Bt,"float32")),en,"bilinear",hn,0,[Ue.height,Ue.width]);return it!=null?Pd(Nn,it):Nn}),padding:St,transformationMatrix:Mt}}function sd(n,e,t,s){return s===1?.5*(n+e):n+(e-n)*t/(s-1)}function om(n){return(0,y.lub)(function(){var e=function(a){return(0,y.lub)(function(){return[(0,y.tPi)(a,[0,0,0],[1,-1,1]),(0,y.tPi)(a,[0,0,1],[1,-1,-1])]})}(n),t=e[0],s=e[1];return{boxes:(0,y.L9e)(s),logits:(0,y.L9e)(t)}})}function Od(n){return n!=null&&n.currentTime!=null}function Fd(n){for(var e={locationData:{relativeKeypoints:[]}},t=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER,a=Number.MAX_SAFE_INTEGER,u=Number.MIN_SAFE_INTEGER,d=0;d<n.length;++d){var m=n[d];t=Math.min(t,m.x),s=Math.max(s,m.x),a=Math.min(a,m.y),u=Math.max(u,m.y),e.locationData.relativeKeypoints.push({x:m.x,y:m.y})}return e.locationData.relativeBoundingBox={xMin:t,yMin:a,xMax:s,yMax:u,width:s-t,height:u-a},e}function am(n,e,t,s){return zn(this,void 0,void 0,function(){var a,u,d,m,b;return jn(this,function(T){switch(T.label){case 0:return n.sort(function(k,R){return Math.max.apply(Math,R.score)-Math.max.apply(Math,k.score)}),a=(0,y.odF)(n.map(function(k){return[k.locationData.relativeBoundingBox.yMin,k.locationData.relativeBoundingBox.xMin,k.locationData.relativeBoundingBox.yMax,k.locationData.relativeBoundingBox.xMax]})),u=(0,y.RRF)(n.map(function(k){return k.score[0]})),[4,y.BHj.nonMaxSuppressionAsync(a,u,e,t)];case 1:return[4,(d=T.sent()).array()];case 2:return m=T.sent(),b=n.filter(function(k,R){return m.indexOf(R)>-1}),(0,y.B90)([a,u,d]),[2,b]}})})}function Bd(n,e){return n.map(function(t){var s=is(is({},t),{x:t.x*e.width,y:t.y*e.height});return t.z!=null&&(s.z=t.z*e.width),s})}function im(n,e,t){return zn(this,void 0,void 0,function(){var s,a,u,d,m,b,T,k,R,B,X,oe,ue,he,Ue,Xe,ot,it,mt,wt,St,Mt,Bt,en;return jn(this,function(hn){switch(hn.label){case 0:if(s=(0,y.L9e)(e,[0]),a=s.shape,u=a[0],d=a[1],m=a[2],n.length!==m)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(n.length,", heatmap length: ").concat(m));return b=[],[4,s.buffer()];case 1:for(T=hn.sent(),k=0;k<n.length;k++)if(R=n[k],B=is({},R),b.push(B),X=Math.trunc(B.x*d),oe=Math.trunc(B.y*u),!(X<0||X>=d||oe<0||X>=u)){for(ue=Math.trunc((t.kernelSize-1)/2),he=Math.max(0,X-ue),Ue=Math.min(d,X+ue+1),Xe=Math.max(0,oe-ue),ot=Math.min(u,oe+ue+1),it=0,mt=0,wt=0,St=0,Mt=Xe;Mt<ot;++Mt)for(Bt=he;Bt<Ue;++Bt)en=T.get(Mt,Bt,k),it+=en,St=Math.max(St,en),mt+=Bt*en,wt+=Mt*en;St>=t.minConfidenceToRefine&&it>0&&(B.x=mt/d/it,B.y=wt/u/it)}return s.dispose(),[2,b]}})})}function Ld(n,e){var t=e.left,s=e.top,a=e.left+e.right,u=e.top+e.bottom;return n.map(function(d){return is(is({},d),{x:(d.x-t)/(1-a),y:(d.y-s)/(1-u),z:d.z/(1-a)})})}function um(n,e,t){return(0,y.N_N)()==="webgl"?function(s,a,u){var d=u.combineWithPreviousRatio.toFixed(2),m={variableNames:["prevMask","newMask"],outputShape:s.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `.concat(d,`);

      setOutput(outputValue);
    }
`)},b=(0,y.y3$)();return(0,y.lub)(function(){var T=b.compileAndRun(m,[s,a]);return(0,y.SRH)().makeTensorFromDataId(T.dataId,T.shape,T.dtype)})}(n,e,t):(0,y.lub)(function(){var s=(0,y.luU)(e,.5),a=(0,y.h62)(s),u=(0,y.luU)(1,(0,y.LTh)(1,(0,y.dC7)(a,(0,y.IHx)(5.68842,(0,y.dC7)(a,(0,y.IHx)(-.748699,(0,y.dC7)(a,(0,y.IHx)(-57.8051,(0,y.dC7)(a,(0,y.IHx)(291.309,(0,y.dC7)(a,-624.717)))))))))));return(0,y.IHx)(e,(0,y.dC7)((0,y.luU)(n,e),(0,y.dC7)(u,t.combineWithPreviousRatio)))})}function lm(n,e,t){return zn(this,void 0,void 0,function(){var s,a,u,d,m;return jn(this,function(b){switch(b.label){case 0:return s=n[0],a=n[1],u=function(T,k,R){return(0,y.lub)(function(){var B,X,oe,ue;R.reverseOutputOrder?(X=(0,y.L9e)((0,y.tPi)(T,[0,R.boxCoordOffset+0],[-1,1])),B=(0,y.L9e)((0,y.tPi)(T,[0,R.boxCoordOffset+1],[-1,1])),ue=(0,y.L9e)((0,y.tPi)(T,[0,R.boxCoordOffset+2],[-1,1])),oe=(0,y.L9e)((0,y.tPi)(T,[0,R.boxCoordOffset+3],[-1,1]))):(B=(0,y.L9e)((0,y.tPi)(T,[0,R.boxCoordOffset+0],[-1,1])),X=(0,y.L9e)((0,y.tPi)(T,[0,R.boxCoordOffset+1],[-1,1])),oe=(0,y.L9e)((0,y.tPi)(T,[0,R.boxCoordOffset+2],[-1,1])),ue=(0,y.L9e)((0,y.tPi)(T,[0,R.boxCoordOffset+3],[-1,1]))),X=(0,y.IHx)((0,y.dC7)((0,y.hiC)(X,R.xScale),k.w),k.x),B=(0,y.IHx)((0,y.dC7)((0,y.hiC)(B,R.yScale),k.h),k.y),R.applyExponentialOnBoxSize?(oe=(0,y.dC7)((0,y.Qqt)((0,y.hiC)(oe,R.hScale)),k.h),ue=(0,y.dC7)((0,y.Qqt)((0,y.hiC)(ue,R.wScale)),k.w)):(oe=(0,y.dC7)((0,y.hiC)(oe,R.hScale),k.h),ue=(0,y.dC7)((0,y.hiC)(ue,R.wScale),k.h));var he=(0,y.luU)(B,(0,y.hiC)(oe,2)),Ue=(0,y.luU)(X,(0,y.hiC)(ue,2)),Xe=(0,y.IHx)(B,(0,y.hiC)(oe,2)),ot=(0,y.IHx)(X,(0,y.hiC)(ue,2)),it=(0,y.zoF)([(0,y.XLQ)(he,[R.numBoxes,1]),(0,y.XLQ)(Ue,[R.numBoxes,1]),(0,y.XLQ)(Xe,[R.numBoxes,1]),(0,y.XLQ)(ot,[R.numBoxes,1])],1);if(R.numKeypoints)for(var mt=0;mt<R.numKeypoints;++mt){var wt=R.keypointCoordOffset+mt*R.numValuesPerKeypoint,St=void 0,Mt=void 0;R.reverseOutputOrder?(St=(0,y.L9e)((0,y.tPi)(T,[0,wt],[-1,1])),Mt=(0,y.L9e)((0,y.tPi)(T,[0,wt+1],[-1,1]))):(Mt=(0,y.L9e)((0,y.tPi)(T,[0,wt],[-1,1])),St=(0,y.L9e)((0,y.tPi)(T,[0,wt+1],[-1,1])));var Bt=(0,y.IHx)((0,y.dC7)((0,y.hiC)(St,R.xScale),k.w),k.x),en=(0,y.IHx)((0,y.dC7)((0,y.hiC)(Mt,R.yScale),k.h),k.y);it=(0,y.zoF)([it,(0,y.XLQ)(Bt,[R.numBoxes,1]),(0,y.XLQ)(en,[R.numBoxes,1])],1)}return it})}(a,e,t),d=(0,y.lub)(function(){var T=s;return t.sigmoidScore?(t.scoreClippingThresh!=null&&(T=(0,y.iUl)(s,-t.scoreClippingThresh,t.scoreClippingThresh)),T=(0,y.XD2)(T)):T}),[4,cm(u,d,t)];case 1:return m=b.sent(),(0,y.B90)([u,d]),[2,m]}})})}function cm(n,e,t){return zn(this,void 0,void 0,function(){var s,a,u,d,m,b,T,k,R,B,X,oe;return jn(this,function(ue){switch(ue.label){case 0:return s=[],[4,n.data()];case 1:return a=ue.sent(),[4,e.data()];case 2:for(u=ue.sent(),d=0;d<t.numBoxes;++d)if(!(t.minScoreThresh!=null&&u[d]<t.minScoreThresh||(m=d*t.numCoords,b=dm(a[m+0],a[m+1],a[m+2],a[m+3],u[d],t.flipVertically,d),(T=b.locationData.relativeBoundingBox).width<0||T.height<0))){if(t.numKeypoints>0)for((k=b.locationData).relativeKeypoints=[],R=t.numKeypoints*t.numValuesPerKeypoint,B=0;B<R;B+=t.numValuesPerKeypoint)X=m+t.keypointCoordOffset+B,oe={x:a[X+0],y:t.flipVertically?1-a[X+1]:a[X+1]},k.relativeKeypoints.push(oe);s.push(b)}return[2,s]}})})}function dm(n,e,t,s,a,u,d){return{score:[a],ind:d,locationData:{relativeBoundingBox:{xMin:e,yMin:u?1-t:n,xMax:s,yMax:u?1-n:t,width:s-e,height:t-n}}}}function hm(n,e){return n==="none"?e:function(t){return 1/(1+Math.exp(-t))}(e)}function Ud(n,e,t,s){return zn(this,void 0,void 0,function(){var a,u,d,m,b,T,k,R;return jn(this,function(B){switch(B.label){case 0:return t=t||e.flipHorizontally||!1,s=s||e.flipVertically||!1,a=n.size,u=a/e.numLandmarks,[4,n.data()];case 1:for(d=B.sent(),m=[],b=0;b<e.numLandmarks;++b)T=b*u,(R={x:0,y:0}).x=t?e.inputImageWidth-d[T]:d[T],u>1&&(R.y=s?e.inputImageHeight-d[T+1]:d[T+1]),u>2&&(R.z=d[T+2]),u>3&&(R.score=hm(e.visibilityActivation,d[T+3])),m.push(R);for(k=0;k<m.length;++k)(R=m[k]).x=R.x/e.inputImageWidth,R.y=R.y/e.inputImageHeight,R.z=R.z/e.inputImageWidth/(e.normalizeZ||1);return[2,m]}})})}function i(n,e,t){var s=n.width,a=n.height,u=n.rotation;if(t.rotation==null&&t.rotationDegree==null||(u=function(k,R){return R.rotation!=null?k+=R.rotation:R.rotationDegree!=null&&(k+=Math.PI*R.rotationDegree/180),Rd(k)}(u,t)),u===0)n.xCenter=n.xCenter+s*t.shiftX,n.yCenter=n.yCenter+a*t.shiftY;else{var d=(e.width*s*t.shiftX*Math.cos(u)-e.height*a*t.shiftY*Math.sin(u))/e.width,m=(e.width*s*t.shiftX*Math.sin(u)+e.height*a*t.shiftY*Math.cos(u))/e.height;n.xCenter=n.xCenter+d,n.yCenter=n.yCenter+m}if(t.squareLong){var b=Math.max(s*e.width,a*e.height);s=b/e.width,a=b/e.height}else if(t.squareShort){var T=Math.min(s*e.width,a*e.height);s=T/e.width,a=T/e.height}return n.width=s*t.scaleX,n.height=a*t.scaleY,n}function r(n,e){return n.map(function(t){var s=is(is({},t),{x:t.x/e.width,y:t.y/e.height});return t.z!=null&&(t.z=t.z/e.width),s})}var o=function(){function n(e){this.alpha=e,this.initialized=!1}return n.prototype.apply=function(e,t){var s;return this.initialized?s=t==null?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(s=e,this.initialized=!0),this.rawValue=e,this.storedValue=s,s},n.prototype.applyWithAlpha=function(e,t,s){return this.alpha=t,this.apply(e,s)},n.prototype.hasLastRawValue=function(){return this.initialized},n.prototype.lastRawValue=function(){return this.rawValue},n.prototype.reset=function(){this.initialized=!1},n}(),l=function(){function n(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new o(this.getAlpha(this.minCutOff)),this.dx=new o(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return n.prototype.apply=function(e,t,s){if(e==null)return e;var a=Math.trunc(t);if(this.lastTimestamp>=a)return e;this.lastTimestamp!==0&&a!==0&&(this.frequency=1/(1e-6*(a-this.lastTimestamp))),this.lastTimestamp=a;var u=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*s*this.frequency:0,d=this.dx.applyWithAlpha(u,this.getAlpha(this.derivateCutOff)),m=this.minCutOff+this.beta*Math.abs(d),b=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(d):null;return this.x.applyWithAlpha(e,this.getAlpha(m),b)},n.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},n}(),c=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,s){var a=this;if(e==null)return this.reset(),null;this.initializeFiltersIfEmpty(e);var u=1;if(!this.config.disableValueScaling){if(s<this.config.minAllowedObjectScale)return Va([],e,!0);u=1/s}return e.map(function(d,m){var b=is(is({},d),{x:a.xFilters[m].apply(d.x,t,u),y:a.yFilters[m].apply(d.y,t,u)});return d.z!=null&&(b.z=a.zFilters[m].apply(d.z,t,u)),b})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(s){return new l(t.config)}),this.yFilters=e.map(function(s){return new l(t.config)}),this.zFilters=e.map(function(s){return new l(t.config)}))},n}(),f=function(){function n(e){this.config=e,this.window=[],this.lowPassFilter=new o(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return n.prototype.apply=function(e,t,s){if(e==null)return e;var a,u=Math.trunc(t);if(this.lastTimestamp>=u)return e;if(this.lastTimestamp===-1)a=1;else{for(var d=e*s-this.lastValue*this.lastValueScale,m=u-this.lastTimestamp,b=d,T=m,k=(1+this.window.length)*(1e6/30),R=0,B=this.window;R<B.length;R++){var X=B[R];if(T+X.duration>k)break;b+=X.distance,T+=X.duration}var oe=b/(1e-6*T);a=1-1/(1+this.config.velocityScale*Math.abs(oe)),this.window.unshift({distance:d,duration:m}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=s,this.lastTimestamp=u,this.lowPassFilter.applyWithAlpha(e,a)},n}(),g=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,s){var a=this;if(e==null)return this.reset(),null;var u=1;if(!this.config.disableValueScaling){if(s<this.config.minAllowedObjectScale)return Va([],e,!0);u=1/s}return this.initializeFiltersIfEmpty(e),e.map(function(d,m){var b=is(is({},d),{x:a.xFilters[m].apply(d.x,t,u),y:a.yFilters[m].apply(d.y,t,u)});return d.z!=null&&(b.z=a.zFilters[m].apply(d.z,t,u)),b})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(s){return new f(t.config)}),this.yFilters=e.map(function(s){return new f(t.config)}),this.zFilters=e.map(function(s){return new f(t.config)}))},n}(),C=function(){function n(e){if(e.velocityFilter!=null)this.keypointsFilter=new g(e.velocityFilter);else{if(e.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new c(e.oneEuroFilter)}}return n.prototype.apply=function(e,t,s,a,u){if(a===void 0&&(a=!1),e==null)return this.keypointsFilter.reset(),null;var d=u!=null?function(T,k){return(T.width*k.width+T.height*k.height)/2}(u,s):1,m=a?Bd(e,s):e,b=this.keypointsFilter.apply(m,t,d);return a?r(b,s):b},n}(),v=function(){function n(e){this.alpha=e.alpha}return n.prototype.apply=function(e){var t=this;if(e==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(m){return new o(t.alpha)}));for(var s=[],a=0;a<e.length;++a){var u=e[a],d=is({},u);d.score=this.visibilityFilters[a].apply(u.score),s.push(d)}return s},n}(),D={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},F={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},H={maxPoses:1,flipHorizontal:!1},Y={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},te=.3,ae={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},Ce={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},Le={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},be={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},Ge={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},Et={kernelSize:7,minConfidenceToRefine:.5},vt={alpha:.1},jt={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},En={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},gn={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},rn={activation:"none"},Gn={combineWithPreviousRatio:.7},_n=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return zn(this,void 0,void 0,function(){return jn(this,function(e){return[2,$d(this.mask)]})})},n.prototype.toImageData=function(){return zn(this,void 0,void 0,function(){return jn(this,function(e){return[2,Nd(this.mask)]})})},n.prototype.toTensor=function(){return zn(this,void 0,void 0,function(){return jn(this,function(e){return[2,this.mask]})})},n.prototype.getUnderlyingType=function(){return"tensor"},n}();function _s(n){return kd(n),"person"}var Ls=function(){function n(e,t,s,a,u,d){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=s,this.enableSegmentation=a,this.smoothSegmentation=u,this.modelType=d,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(R){R.reduceBoxesInLowestLayer==null&&(R.reduceBoxesInLowestLayer=!1),R.interpolatedScaleAspectRatio==null&&(R.interpolatedScaleAspectRatio=1),R.fixedAnchorSize==null&&(R.fixedAnchorSize=!1);for(var B=[],X=0;X<R.numLayers;){for(var oe=[],ue=[],he=[],Ue=[],Xe=X;Xe<R.strides.length&&R.strides[Xe]===R.strides[X];){var ot=sd(R.minScale,R.maxScale,Xe,R.strides.length);if(Xe===0&&R.reduceBoxesInLowestLayer)he.push(1),he.push(2),he.push(.5),Ue.push(.1),Ue.push(ot),Ue.push(ot);else{for(var it=0;it<R.aspectRatios.length;++it)he.push(R.aspectRatios[it]),Ue.push(ot);if(R.interpolatedScaleAspectRatio>0){var mt=Xe===R.strides.length-1?1:sd(R.minScale,R.maxScale,Xe+1,R.strides.length);Ue.push(Math.sqrt(ot*mt)),he.push(R.interpolatedScaleAspectRatio)}}Xe++}for(var wt=0;wt<he.length;++wt){var St=Math.sqrt(he[wt]);oe.push(Ue[wt]/St),ue.push(Ue[wt]*St)}var Mt=0,Bt=0;if(R.featureMapHeight.length>0)Mt=R.featureMapHeight[X],Bt=R.featureMapWidth[X];else{var en=R.strides[X];Mt=Math.ceil(R.inputSizeHeight/en),Bt=Math.ceil(R.inputSizeWidth/en)}for(var hn=0;hn<Mt;++hn)for(var Nn=0;Nn<Bt;++Nn)for(var vn=0;vn<oe.length;++vn){var On={xCenter:(Nn+R.anchorOffsetX)/Bt,yCenter:(hn+R.anchorOffsetY)/Mt,width:0,height:0};R.fixedAnchorSize?(On.width=1,On.height=1):(On.width=ue[vn],On.height=oe[vn]),B.push(On)}X=Xe}return B}(D);var m=(0,y.RRF)(this.anchors.map(function(R){return R.width})),b=(0,y.RRF)(this.anchors.map(function(R){return R.height})),T=(0,y.RRF)(this.anchors.map(function(R){return R.xCenter})),k=(0,y.RRF)(this.anchors.map(function(R){return R.yCenter}));this.anchorTensor={x:T,y:k,w:m,h:b},this.prevFilteredSegmentationMask=this.enableSegmentation?(0,y.odF)([],[0,0]):null}return n.prototype.estimatePoses=function(e,t,s){return zn(this,void 0,void 0,function(){var a,u,d,m,b,T,k,R,B,X,oe,ue,he,Ue,Xe,ot,it,mt,wt,St,Mt,Bt,en;return jn(this,function(hn){switch(hn.label){case 0:return a=function(Nn){var vn;if((vn=Nn==null?H:is({},Nn)).maxPoses==null&&(vn.maxPoses=1),vn.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(vn.maxPoses,". Should be > 0."));if(vn.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return vn}(t),e==null?(this.reset(),[2,[]]):(this.maxPoses=a.maxPoses,this.timestamp=s!=null?1e3*s:Od(e)?1e6*e.currentTime:null,u=Li(e),d=(0,y.lub)(function(){return(0,y.pju)(ed(e),"float32")}),(m=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(d)]);case 1:if((b=hn.sent()).length===0)return this.reset(),d.dispose(),[2,[]];T=b[0],m=this.poseDetectionToRoi(T,u),hn.label=2;case 2:return[4,this.poseLandmarksByRoi(m,d)];case 3:return k=hn.sent(),d.dispose(),k==null?(this.reset(),[2,[]]):(R=k.landmarks,B=k.auxiliaryLandmarks,X=k.poseScore,oe=k.worldLandmarks,ue=k.segmentationMask,he=this.poseLandmarkFiltering(R,B,oe,u),Ue=he.actualLandmarksFiltered,Xe=he.auxiliaryLandmarksFiltered,ot=he.actualWorldLandmarksFiltered,it=this.poseLandmarksToRoi(Xe,u),this.regionOfInterest=it,mt=this.smoothSegmentation&&ue!=null?this.poseSegmentationFiltering(ue):ue,(wt=Ue!=null?Bd(Ue,u):null)!=null&&wt.forEach(function(Nn,vn){Nn.name=Fi[vn]}),(St=ot)!=null&&St.forEach(function(Nn,vn){Nn.name=Fi[vn]}),Mt={score:X,keypoints:wt,keypoints3D:St},mt!==null&&(Bt=(0,y.lub)(function(){var Nn=(0,y.dt4)(mt,2),vn=(0,y.vku)(Nn,[[0,0],[0,0],[0,1]]);return(0,y.VdP)(vn,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||(0,y.B90)(mt),en={maskValueToLabel:_s,mask:new _n(Bt)},Mt.segmentation=en),[2,[Mt]])}})})},n.prototype.poseSegmentationFiltering=function(e){var t=this.prevFilteredSegmentationMask;return t.size===0?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=um(t,e,Gn),(0,y.B90)(e)),(0,y.B90)(t),this.prevFilteredSegmentationMask},n.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),(0,y.B90)([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},n.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&((0,y.B90)(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=(0,y.odF)([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},n.prototype.detectPose=function(e){return zn(this,void 0,void 0,function(){var t,s,a,u,d,m,b,T,k,R;return jn(this,function(B){switch(B.label){case 0:return t=pa(e,Ce),s=t.imageTensor,a=t.padding,u=this.detectorModel.predict(s),d=om(u),m=d.boxes,[4,lm([b=d.logits,m],this.anchorTensor,Y)];case 1:return(T=B.sent()).length===0?((0,y.B90)([s,u,b,m]),[2,T]):[4,am(T,this.maxPoses,te)];case 2:return k=B.sent(),R=function(X,oe){X===void 0&&(X=[]);for(var ue=oe.left,he=oe.top,Ue=oe.left+oe.right,Xe=oe.top+oe.bottom,ot=0;ot<X.length;ot++){var it=X[ot],mt=it.locationData.relativeBoundingBox,wt=(mt.xMin-ue)/(1-Ue),St=(mt.yMin-he)/(1-Xe),Mt=mt.width/(1-Ue),Bt=mt.height/(1-Xe);mt.xMin=wt,mt.yMin=St,mt.width=Mt,mt.height=Bt,mt.xMax=wt+Mt,mt.yMax=St+Bt;var en=it.locationData.relativeKeypoints;en&&en.forEach(function(hn){var Nn=(hn.x-ue)/(1-Ue),vn=(hn.y-he)/(1-Xe);hn.x=Nn,hn.y=vn})}return X}(k,a),(0,y.B90)([s,u,b,m]),[2,R]}})})},n.prototype.poseDetectionToRoi=function(e,t){return i(nd(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,ae)},n.prototype.poseLandmarksByRoi=function(e,t){return zn(this,void 0,void 0,function(){var s,a,u,d,m,b,T,k,R,B,X,oe,ue,he;return jn(this,function(Ue){switch(Ue.label){case 0:if(s=Li(t),a=pa(t,Le,e),u=a.imageTensor,d=a.padding,m=a.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return b=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&b.push("activation_segmentation"),T=this.landmarkModel.execute(u,b),[4,this.tensorsToPoseLandmarksAndSegmentation(T)];case 1:return(k=Ue.sent())==null?((0,y.B90)(T),(0,y.B90)(u),[2,null]):(R=k.landmarks,B=k.auxiliaryLandmarks,X=k.poseScore,oe=k.worldLandmarks,ue=k.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(s,e,d,m,R,B,oe,ue)]);case 2:return he=Ue.sent(),(0,y.B90)(T),(0,y.B90)(u),[2,is({poseScore:X},he)]}})})},n.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,t,s,a,u,d,m,b){return zn(this,void 0,void 0,function(){var T,k,R,B,X,oe;return jn(this,function(ue){return T=Ld(u,s),k=Ld(d,s),R=Ad(T,t),B=Ad(k,t),X=function(he,Ue){for(var Xe=[],ot=0,it=he;ot<it.length;ot++){var mt=it[ot],wt=mt.x,St=mt.y,Mt=Ue.rotation,Bt=Math.cos(Mt)*wt-Math.sin(Mt)*St,en=Math.sin(Mt)*wt+Math.cos(Mt)*St,hn=is({},mt);hn.x=Bt,hn.y=en,Xe.push(hn)}return Xe}(m,t),oe=null,this.enableSegmentation&&(oe=(0,y.lub)(function(){var he=b.shape,Ue=he[0],Xe=he[1],ot=function(wt){var St=_d(new Array(16).fill(0));St[0][0]=Rr(wt,0,0),St[1][0]=-Rr(wt,0,1),St[2][0]=Rr(wt,0,2),St[3][0]=-Rr(wt,0,3),St[0][2]=Rr(wt,2,0),St[1][2]=-Rr(wt,2,1),St[2][2]=Rr(wt,2,2),St[3][2]=-Rr(wt,2,3),St[0][1]=-Rr(wt,1,0),St[1][1]=Rr(wt,1,1),St[2][1]=-Rr(wt,1,2),St[3][1]=Rr(wt,1,3),St[0][3]=-Rr(wt,3,0),St[1][3]=Rr(wt,3,1),St[2][3]=-Rr(wt,3,2),St[3][3]=Rr(wt,3,3);for(var Mt=wt[0][0]*St[0][0]+wt[1][0]*St[0][1]+wt[2][0]*St[0][2]+wt[3][0]*St[0][3],Bt=0;Bt<St.length;Bt++)for(var en=0;en<St.length;en++)St[Bt][en]/=Mt;return St}(a),it=(0,y.odF)(Dd(ot,{width:Xe,height:Ue},e),[1,8]),mt=[1,Ue,Xe,1];return(0,y.L9e)(y.BHj.transform((0,y.XLQ)(b,mt),it,"bilinear","constant",0,[e.height,e.width]),[0,3])}),(0,y.B90)(b)),[2,{landmarks:R,auxiliaryLandmarks:B,worldLandmarks:X,segmentationMask:oe}]})})},n.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return zn(this,void 0,void 0,function(){var t,s,a,u,d,m,b,T,k,R,B,X,oe;return jn(this,function(ue){switch(ue.label){case 0:return t=e[0],s=e[1],a=e[2],u=e[3],d=this.enableSegmentation?e[4]:null,[4,s.data()];case 1:return(m=ue.sent()[0])<.5?[2,null]:[4,Ud(t,be)];case 2:return[4,im(ue.sent(),a,Et)];case 3:return b=ue.sent(),T=b.slice(0,33),k=b.slice(33,35),[4,Ud(u,Ge)];case 4:return R=ue.sent(),B=R.slice(0,33),X=function(he,Ue,Xe){Xe===void 0&&(Xe=!0);for(var ot=[],it=0;it<he.length;it++){var mt=is({},Ue[it]);Xe&&(mt.score=he[it].score),ot.push(mt)}return ot}(T,B,!0),oe=this.enableSegmentation?function(he,Ue,Xe){return(0,y.lub)(function(){var ot=(0,y.L9e)(he,[0]),it=ot.shape[2];if(it===1){var mt=ot;switch(Ue.activation){case"none":break;case"sigmoid":mt=(0,y.XD2)(mt);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(Ue.activation,")"))}var wt=Xe?y.BHj.resizeBilinear(mt,[Xe.height,Xe.width]):mt;return(0,y.L9e)(wt,[2])}throw new Error("Unsupported number of tensor channels ".concat(it))})}(d,rn):null,[2,{landmarks:T,auxiliaryLandmarks:k,poseScore:m,worldLandmarks:X,segmentationMask:oe}]}})})},n.prototype.poseLandmarksToRoi=function(e,t){return i(nd(Fd(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,ae)},n.prototype.poseLandmarkFiltering=function(e,t,s,a){var u,d,m;if(this.timestamp!=null&&this.enableSmoothing){var b=nd(Fd(t),a,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new v(vt)),u=this.visibilitySmoothingFilterActual.apply(e),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new v(vt)),d=this.visibilitySmoothingFilterAuxiliary.apply(t),m=this.visibilitySmoothingFilterActual.apply(s),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new C(jt)),u=this.landmarksSmoothingFilterActual.apply(u,this.timestamp,a,!0,b),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new C(En)),d=this.landmarksSmoothingFilterAuxiliary.apply(d,this.timestamp,a,!0,b),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new C(gn)),m=this.worldLandmarksSmoothingFilterActual.apply(s,this.timestamp)}else u=e,d=t,m=s;return{actualLandmarksFiltered:u,auxiliaryLandmarksFiltered:d,actualWorldLandmarksFiltered:m}},n}();function Zo(n){return zn(this,void 0,void 0,function(){var e,t,s,a,u,d;return jn(this,function(m){switch(m.label){case 0:return e=function(b){var T=is({},b??F);if(T.enableSmoothing==null&&(T.enableSmoothing=F.enableSmoothing),T.enableSegmentation==null&&(T.enableSegmentation=F.enableSegmentation),T.smoothSegmentation==null&&(T.smoothSegmentation=F.smoothSegmentation),T.modelType==null&&(T.modelType=F.modelType),T.detectorModelUrl==null&&(T.detectorModelUrl=F.detectorModelUrl),T.landmarkModelUrl==null)switch(T.modelType){case"lite":T.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":T.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:T.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return T}(n),t=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,s=typeof e.landmarkModelUrl=="string"&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([Oe(e.detectorModelUrl,{fromTFHub:t}),Oe(e.landmarkModelUrl,{fromTFHub:s})])];case 1:return a=m.sent(),u=a[0],d=a[1],[2,new Ls(u,d,e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}})})}var Xs,us,yo=function(){function n(e){(function(t){if(t.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(t.maxTracks));if(t.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(t.maxAge));if(t.keypointTrackerParams!==void 0){if(t.keypointTrackerParams.keypointConfidenceThreshold<0||t.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(t.keypointTrackerParams.keypointConfidenceThreshold));if(t.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(t.keypointTrackerParams.minNumberOfKeypoints));for(var s=0,a=t.keypointTrackerParams.keypointFalloff;s<a.length;s++){var u=a[s];if(u<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(u))}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return n.prototype.apply=function(e,t){this.filterOldTracks(t);var s=this.computeSimilarity(e);return this.assignTracks(e,s,t),this.updateTracks(t),e},n.prototype.getTracks=function(){return this.tracks.slice()},n.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},n.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter(function(s){return e-s.lastTimestamp<=t.maxAge})},n.prototype.assignTracks=function(e,t,s){for(var a=Array.from(Array(t[0].length).keys()),u=[],d=0,m=Array.from(Array(e.length).keys());d<m.length;d++){var b=m[d];if(a.length!==0){for(var T=-1,k=-1,R=0,B=a;R<B.length;R++){var X=B[R],oe=t[b][X];oe>=this.minSimilarity&&oe>k&&(T=X,k=oe)}if(T>=0){var ue=this.tracks[T];ue=Object.assign(ue,this.createTrack(e[b],s,ue.id)),e[b].id=ue.id;var he=a.indexOf(T);a.splice(he,1)}else u.push(b)}else u.push(b)}for(var Ue=0,Xe=u;Ue<Xe.length;Ue++){b=Xe[Ue];var ot=this.createTrack(e[b],s);this.tracks.push(ot),e[b].id=ot.id}},n.prototype.updateTracks=function(e){this.tracks.sort(function(t,s){return s.lastTimestamp-t.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},n.prototype.createTrack=function(e,t,s){var a={id:s||this.nextTrackID(),lastTimestamp:t,keypoints:Va([],e.keypoints,!0).map(function(u){return is({},u)})};return e.box!==void 0&&(a.box=is({},e.box)),a},n.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},n.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter(function(s){return!e.includes(s.id)})},n.prototype.reset=function(){this.tracks=[]},n}(),Mo=function(n){function e(t){return n.call(this,t)||this}return Td(e,n),e.prototype.computeSimilarity=function(t){var s=this;return t.length===0||this.tracks.length===0?[[]]:t.map(function(a){return s.tracks.map(function(u){return s.iou(a,u)})})},e.prototype.iou=function(t,s){var a=Math.max(t.box.xMin,s.box.xMin),u=Math.max(t.box.yMin,s.box.yMin),d=Math.min(t.box.xMax,s.box.xMax),m=Math.min(t.box.yMax,s.box.yMax);if(a>=d||u>=m)return 0;var b=(d-a)*(m-u);return b/(t.box.width*t.box.height+s.box.width*s.box.height-b)},e}(yo),Dr=function(n){function e(t){var s=n.call(this,t)||this;return s.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,s.keypointFalloff=t.keypointTrackerParams.keypointFalloff,s.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,s}return Td(e,n),e.prototype.computeSimilarity=function(t){if(t.length===0||this.tracks.length===0)return[[]];for(var s=[],a=0,u=t;a<u.length;a++){for(var d=u[a],m=[],b=0,T=this.tracks;b<T.length;b++){var k=T[b];m.push(this.oks(d,k))}s.push(m)}return s},e.prototype.oks=function(t,s){for(var a=this.area(s.keypoints)+1e-6,u=0,d=0,m=0;m<t.keypoints.length;++m){var b=t.keypoints[m],T=s.keypoints[m];if(!(b.score<this.keypointThreshold||T.score<this.keypointThreshold)){d+=1;var k=Math.pow(b.x-T.x,2)+Math.pow(b.y-T.y,2),R=2*this.keypointFalloff[m];u+=Math.exp(-1*k/(2*a*Math.pow(R,2)))}}return d<this.minNumKeyoints?0:u/d},e.prototype.area=function(t){var s=this,a=t.filter(function(b){return b.score>s.keypointThreshold}),u=Math.min.apply(Math,Va([1],a.map(function(b){return b.x}),!1)),d=Math.max.apply(Math,Va([0],a.map(function(b){return b.x}),!1)),m=Math.min.apply(Math,Va([1],a.map(function(b){return b.y}),!1));return(d-u)*(Math.max.apply(Math,Va([0],a.map(function(b){return b.y}),!1))-m)},e}(yo);function fa(n){switch(n){case us.BlazePose:return Fi.reduce(function(e,t,s){return e[t]=s,e},{});case us.PoseNet:case us.MoveNet:return Qo.reduce(function(e,t,s){return e[t]=s,e},{});default:throw new Error("Model ".concat(n," is not supported."))}}(function(n){n.Keypoint="keypoint",n.BoundingBox="boundingBox"})(Xs||(Xs={})),function(n){n.MoveNet="MoveNet",n.BlazePose="BlazePose",n.PoseNet="PoseNet"}(us||(us={}));var Ui=Object.freeze({__proto__:null,getKeypointIndexBySide:function(n){switch(n){case us.BlazePose:return Qf;case us.PoseNet:case us.MoveNet:return Zf;default:throw new Error("Model ".concat(n," is not supported."))}},getAdjacentPairs:function(n){switch(n){case us.BlazePose:return em;case us.PoseNet:case us.MoveNet:return Jf;default:throw new Error("Model ".concat(n," is not supported."))}},getKeypointIndexByName:fa}),za=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],Mi={modelType:"SinglePose.Lightning",enableSmoothing:!0},Du={},Md={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},Wi={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},rd={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function dg(n,e,t,s){for(var a={},u=0,d=Qo;u<d.length;u++){var m=d[u];a[m]=[e[t[m]].y*s.height,e[t[m]].x*s.width]}if(function(Xe,ot){return(Xe[ot.left_hip].score>.2||Xe[ot.right_hip].score>.2)&&(Xe[ot.left_shoulder].score>.2||Xe[ot.right_shoulder].score>.2)}(e,t)){var b=(a.left_hip[0]+a.right_hip[0])/2,T=(a.left_hip[1]+a.right_hip[1])/2,k=function(Xe,ot,it,mt,wt){for(var St=["left_shoulder","right_shoulder","left_hip","right_hip"],Mt=0,Bt=0,en=0;en<St.length;en++)(Qn=Math.abs(mt-it[St[en]][0]))>Mt&&(Mt=Qn),(ts=Math.abs(wt-it[St[en]][1]))>Bt&&(Bt=ts);for(var hn=0,Nn=0,vn=0,On=Object.keys(it);vn<On.length;vn++){var Qn,ts,xo=On[vn];Xe[ot[xo]].score<.2||((Qn=Math.abs(mt-it[xo][0]))>hn&&(hn=Qn),(ts=Math.abs(wt-it[xo][1]))>Nn&&(Nn=ts))}return[Mt,Bt,hn,Nn]}(e,t,a,b,T),R=k[0],B=k[1],X=k[2],oe=k[3],ue=Math.max(1.9*B,1.9*R,1.2*X,1.2*oe),he=[b-(ue=Math.min(ue,Math.max(T,s.width-T,b,s.height-b))),T-ue];if(ue>Math.max(s.width,s.height)/2)return pm(n==null,s);var Ue=2*ue;return{yMin:he[0]/s.height,xMin:he[1]/s.width,yMax:(he[0]+Ue)/s.height,xMax:(he[1]+Ue)/s.width,height:(he[0]+Ue)/s.height-he[0]/s.height,width:(he[1]+Ue)/s.width-he[1]/s.width}}return pm(n==null,s)}function pm(n,e){var t,s,a,u;return n?e.width>e.height?(t=1,s=e.height/e.width,a=0,u=(e.width/2-e.height/2)/e.width):(t=e.width/e.height,s=1,a=(e.height/2-e.width/2)/e.height,u=0):e.width>e.height?(t=e.width/e.height,s=1,a=(e.height/2-e.width/2)/e.height,u=0):(t=1,s=e.height/e.width,a=0,u=(e.width/2-e.height/2)/e.width),{yMin:a,xMin:u,yMax:a+t,xMax:u+s,height:t,width:s}}function hg(n){var e,t=n==null?Mi:is({},n);if(t.modelType==null)t.modelType="SinglePose.Lightning";else if(za.indexOf(t.modelType)<0)throw new Error("Invalid architecture ".concat(t.modelType,". ")+"Should be one of ".concat(za));if(t.enableSmoothing==null&&(t.enableSmoothing=!0),t.minPoseScore!=null&&(t.minPoseScore<0||t.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(t.multiPoseMaxDimension!=null&&(t.multiPoseMaxDimension%32!=0||t.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(t.modelType==="MultiPose.Lightning"&&t.enableTracking==null&&(t.enableTracking=!0),t.modelType==="MultiPose.Lightning"&&t.enableTracking===!0)if(t.trackerType==null&&(t.trackerType=Xs.BoundingBox),t.trackerType===Xs.Keypoint)t.trackerConfig!=null?t.trackerConfig=function(s){var a=Wm(Wi,s);return a.keypointTrackerParams=is({},Wi.keypointTrackerParams),s.keypointTrackerParams!=null&&(s.keypointTrackerParams.keypointConfidenceThreshold!=null&&(a.keypointTrackerParams.keypointConfidenceThreshold=s.keypointTrackerParams.keypointConfidenceThreshold),s.keypointTrackerParams.keypointFalloff!=null&&(a.keypointTrackerParams.keypointFalloff=s.keypointTrackerParams.keypointFalloff),s.keypointTrackerParams.minNumberOfKeypoints!=null&&(a.keypointTrackerParams.minNumberOfKeypoints=s.keypointTrackerParams.minNumberOfKeypoints)),a}(t.trackerConfig):t.trackerConfig=Wi;else{if(t.trackerType!==Xs.BoundingBox)throw new Error("Tracker type not supported by MoveNet");t.trackerConfig!=null?t.trackerConfig=(e=t.trackerConfig,Wm(rd,e)):t.trackerConfig=rd}return t}function Wm(n,e){var t={maxTracks:n.maxTracks,maxAge:n.maxAge,minSimilarity:n.minSimilarity};return e.maxTracks!=null&&(t.maxTracks=e.maxTracks),e.maxAge!=null&&(t.maxAge=e.maxAge),e.minSimilarity!=null&&(t.minSimilarity=e.minSimilarity),t}var pg=function(){function n(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=fa(us.MoveNet),t.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):t.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=t.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new c(Md),this.cropRegionFilterYMin=new o(.9),this.cropRegionFilterXMin=new o(.9),this.cropRegionFilterYMax=new o(.9),this.cropRegionFilterXMax=new o(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===Xs.Keypoint?this.tracker=new Dr(t.trackerConfig):t.trackerType===Xs.BoundingBox&&(this.tracker=new Mo(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return n.prototype.runSinglePersonPoseModel=function(e){return zn(this,void 0,void 0,function(){var t,s,a,u,d;return jn(this,function(m){switch(m.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==4||t.shape[0]!==1||t.shape[1]!==1||t.shape[2]!==17||t.shape[3]!==3)throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return(0,y.N_N)()==="webgpu"?[3,1]:(s=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:s=m.sent(),m.label=3;case 3:for(t.dispose(),a={keypoints:[],score:0},u=0,d=0;d<17;++d)a.keypoints[d]={y:s[3*d],x:s[3*d+1],score:s[3*d+2]},a.keypoints[d].score>.2&&(++u,a.score+=a.keypoints[d].score);return u>0&&(a.score/=u),[2,a]}})})},n.prototype.runMultiPersonPoseModel=function(e){return zn(this,void 0,void 0,function(){var t,s,a,u,d,m,b,T;return jn(this,function(k){switch(k.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==3||t.shape[0]!==1||t.shape[2]!==56)throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return(0,y.N_N)()==="webgpu"?[3,1]:(s=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:s=k.sent(),k.label=3;case 3:for(t.dispose(),a=[],u=s.length/56,d=0;d<u;++d)for(a[d]={keypoints:[]},m=56*d+51,a[d].box={yMin:s[m],xMin:s[m+1],yMax:s[m+2],xMax:s[m+3],width:s[m+3]-s[m+1],height:s[m+2]-s[m]},b=56*d+55,a[d].score=s[b],a[d].keypoints=[],T=0;T<17;++T)a[d].keypoints[T]={y:s[56*d+3*T],x:s[56*d+3*T+1],score:s[56*d+3*T+2]};return[2,a]}})})},n.prototype.estimatePoses=function(e,t,s){return t===void 0&&(t=Du),zn(this,void 0,void 0,function(){var a,u,d,m,b,T;return jn(this,function(k){switch(k.label){case 0:return t=function(R){return R==null?Du:is({},R)}(t),e==null?(this.reset(),[2,[]]):(s==null?Od(e)&&(s=1e6*e.currentTime):s*=1e3,a=ed(e),u=Li(a),d=(0,y.dt4)(a,0),e instanceof y.esB||a.dispose(),m=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(d,u,s)]);case 1:return m=k.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(d,u,s)];case 3:m=k.sent(),k.label=4;case 4:for(b=0;b<m.length;++b)for(T=0;T<m[b].keypoints.length;++T)m[b].keypoints[T].name=Qo[T],m[b].keypoints[T].y*=u.height,m[b].keypoints[T].x*=u.width;return[2,m]}})})},n.prototype.estimateSinglePose=function(e,t,s){return zn(this,void 0,void 0,function(){var a,u,d,m,b=this;return jn(this,function(T){switch(T.label){case 0:return this.cropRegion||(this.cropRegion=pm(this.cropRegion==null,t)),a=(0,y.lub)(function(){var k=(0,y.odF)([[b.cropRegion.yMin,b.cropRegion.xMin,b.cropRegion.yMax,b.cropRegion.xMax]]),R=(0,y.lls)([1],"int32"),B=[b.modelInputResolution.height,b.modelInputResolution.width];return(0,y.pju)(y.BHj.cropAndResize(e,k,R,B,"bilinear",0),"int32")}),e.dispose(),[4,this.runSinglePersonPoseModel(a)];case 1:if(u=T.sent(),a.dispose(),u.score<this.minPoseScore)return this.reset(),[2,[]];for(d=0;d<u.keypoints.length;++d)u.keypoints[d].y=this.cropRegion.yMin+u.keypoints[d].y*this.cropRegion.height,u.keypoints[d].x=this.cropRegion.xMin+u.keypoints[d].x*this.cropRegion.width;return s!=null&&this.enableSmoothing&&(u.keypoints=this.keypointFilter.apply(u.keypoints,s,1)),m=dg(this.cropRegion,u.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(m),[2,[u]]}})})},n.prototype.estimateMultiplePoses=function(e,t,s){return zn(this,void 0,void 0,function(){var a,u,d,m,b,T,k,R,B,X,oe,ue=this;return jn(this,function(he){switch(he.label){case 0:return t.width>t.height?(u=this.multiPoseMaxDimension,d=Math.round(this.multiPoseMaxDimension*t.height/t.width),a=y.BHj.resizeBilinear(e,[d,u]),b=u,T=32*Math.ceil(d/32),m=(0,y.vku)(a,[[0,0],[0,T-d],[0,0],[0,0]])):(u=Math.round(this.multiPoseMaxDimension*t.width/t.height),d=this.multiPoseMaxDimension,a=y.BHj.resizeBilinear(e,[d,u]),b=32*Math.ceil(u/32),T=d,m=(0,y.vku)(a,[[0,0],[0,0],[0,b-u],[0,0]])),a.dispose(),e.dispose(),k=(0,y.pju)(m,"int32"),m.dispose(),[4,this.runMultiPersonPoseModel(k)];case 1:for(R=he.sent(),k.dispose(),R=R.filter(function(Ue){return Ue.score>=ue.minPoseScore}),X=0;X<R.length;++X)for(B=0;B<R[X].keypoints.length;++B)R[X].keypoints[B].y*=T/d,R[X].keypoints[B].x*=b/u;if(this.enableTracking&&(this.tracker.apply(R,s),this.enableSmoothing)){for(X=0;X<R.length;++X)this.keypointFilterMap.has(R[X].id)||this.keypointFilterMap.set(R[X].id,new c(Md)),R[X].keypoints=this.keypointFilterMap.get(R[X].id).apply(R[X].keypoints,s,1);oe=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(Ue,Xe){oe.has(Xe)||ue.keypointFilterMap.delete(Xe)})}return[2,R]}})})},n.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),s=this.cropRegionFilterXMin.apply(e.xMin),a=this.cropRegionFilterYMax.apply(e.yMax),u=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:s,yMax:a,xMax:u,height:a-t,width:u-s}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},n.prototype.dispose=function(){this.moveNetModel.dispose()},n.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},n.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},n}();function fg(n){return n===void 0&&(n=Mi),zn(this,void 0,void 0,function(){var e,t,s,a;return jn(this,function(u){switch(u.label){case 0:return e=hg(n),s=!0,e.modelUrl?(s=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,Oe(e.modelUrl,{fromTFHub:s})]):[3,2];case 1:return t=u.sent(),[3,4];case 2:return a=void 0,e.modelType==="SinglePose.Lightning"?a="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":e.modelType==="SinglePose.Thunder"?a="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":e.modelType==="MultiPose.Lightning"&&(a="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,Oe(a,{fromTFHub:s})];case 3:t=u.sent(),u.label=4;case 4:return(0,y.N_N)()==="webgl"&&(0,y.OBj)().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new pg(t,e)]}})})}var Vm={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},zm=["MobileNetV1","ResNet50"],Gm={MobileNetV1:[8,16],ResNet50:[16]},mg=[8,16,32],Hm={MobileNetV1:[.5,.75,1],ResNet50:[1]},jm=[1,2,4],Km={maxPoses:1,flipHorizontal:!1},gg={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},yg=[-123.15,-115.9,-103.06];function fm(n){return Math.floor(n/2)}var xg=function(){function n(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return n.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},n.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},n.prototype.empty=function(){return this.numberOfElements===-1},n.prototype.size=function(){return this.numberOfElements+1},n.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},n.prototype.max=function(){return this.priorityQueue[0]},n.prototype.swim=function(e){for(;e>0&&this.less(fm(e),e);)this.exchange(e,fm(e)),e=fm(e)},n.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},n.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},n.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},n.prototype.exchange=function(e,t){var s=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=s},n}();function bg(n,e,t,s,a,u){for(var d=u.shape,m=d[0],b=d[1],T=!0,k=Math.max(t-a,0),R=Math.min(t+a+1,m),B=k;B<R;++B){for(var X=Math.max(s-a,0),oe=Math.min(s+a+1,b),ue=X;ue<oe;++ue)if(u.get(B,ue,n)>e){T=!1;break}if(!T)break}return T}function wg(n){return zn(this,void 0,void 0,function(){return jn(this,function(e){return[2,Promise.all(n.map(function(t){return t.buffer()}))]})})}function Xm(n,e,t,s){return{y:s.get(n,e,t),x:s.get(n,e,t+17)}}function Ym(n,e,t){var s=Xm(n.heatmapY,n.heatmapX,n.id,t),a=s.y,u=s.x;return{x:n.heatmapX*e+u,y:n.heatmapY*e+a}}function qm(n,e,t,s){var a=t.x,u=t.y;return n.some(function(d){var m,b,T,k,R,B,X=d.keypoints;return m=u,b=a,T=X[s].y,k=X[s].x,(R=T-m)*R+(B=k-b)*B<=e})}var Qm=Qo.reduce(function(n,e,t){return n[e]=t,n},{}),Zm=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(n){var e=n[0],t=n[1];return[Qm[e],Qm[t]]}),mm=Zm.map(function(n){return n[1]}),Jm=Zm.map(function(n){return n[0]});function eg(n,e,t){return n<e?e:n>t?t:n}function gm(n,e,t,s){return{y:eg(Math.round(n.y/e),0,t-1),x:eg(Math.round(n.x/e),0,s-1)}}function tg(n,e){return{x:n.x+e.x,y:n.y+e.y}}function ng(n,e,t,s,a,u,d,m){m===void 0&&(m=2);for(var b=s.shape,T=b[0],k=b[1],R={y:e.y,x:e.x},B=tg(R,function(Xe,ot,it){var mt=it.shape[2]/2;return{y:it.get(ot.y,ot.x,Xe),x:it.get(ot.y,ot.x,mt+Xe)}}(n,gm(R,u,T,k),d)),X=0;X<m;X++){var oe=gm(B,u,T,k),ue=Xm(oe.y,oe.x,t,a);B=tg({x:oe.x*u,y:oe.y*u},{x:ue.x,y:ue.y})}var he=gm(B,u,T,k),Ue=s.get(he.y,he.x,t);return{y:B.y,x:B.x,name:Qo[t],score:Ue}}function vg(n,e,t,s,a,u){var d=e.shape[2],m=mm.length,b=new Array(d),T=n.part,k=n.score,R=Ym(T,s,t);b[T.id]={score:k,name:Qo[T.id],y:R.y,x:R.x};for(var B=m-1;B>=0;--B){var X=mm[B],oe=Jm[B];b[X]&&!b[oe]&&(b[oe]=ng(B,b[X],oe,e,t,s,u))}for(B=0;B<m;++B)X=Jm[B],oe=mm[B],b[X]&&!b[oe]&&(b[oe]=ng(B,b[X],oe,e,t,s,a));return b}function Cg(n,e,t){return t.reduce(function(s,a,u){var d=a.y,m=a.x,b=a.score;return qm(n,e,{y:d,x:m},u)||(s+=b),s},0)/t.length}function Sg(n,e,t,s,a,u,d,m){return d===void 0&&(d=.5),m===void 0&&(m=20),zn(this,void 0,void 0,function(){var b,T,k,R,B,X,oe,ue,he,Ue,Xe,ot;return jn(this,function(it){switch(it.label){case 0:return[4,wg([n,e,t,s])];case 1:for(b=it.sent(),T=b[0],k=b[1],R=b[2],B=b[3],X=[],oe=function(mt,wt,St){for(var Mt=St.shape,Bt=Mt[0],en=Mt[1],hn=Mt[2],Nn=new xg(Bt*en*hn,function(xo){return xo.score}),vn=0;vn<Bt;++vn)for(var On=0;On<en;++On)for(var Qn=0;Qn<hn;++Qn){var ts=St.get(vn,On,Qn);ts<mt||bg(Qn,ts,vn,On,wt,St)&&Nn.enqueue({score:ts,part:{heatmapY:vn,heatmapX:On,id:Qn}})}return Nn}(d,1,T),ue=m*m;X.length<u&&!oe.empty();)he=oe.dequeue(),Ue=Ym(he.part,a,k),qm(X,ue,Ue,he.part.id)||(Xe=vg(he,T,k,a,R,B),ot=Cg(X,ue,Xe),X.push({keypoints:Xe,score:ot}));return[2,X]}})})}function sg(){for(var n,e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];switch(e.length){case 0:n="fn main() ";break;case 1:n="fn main(".concat(e[0]," : i32)");break;default:throw Error("Unreachable")}return n}var Ig=function(){function n(e){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=Gt(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return n.prototype.getUserCode=function(){return`
        `.concat(sg("index"),` {
          if (index < uniforms.size) {
            let y = B[index * 2];
            let x = B[index * 2 + 1];
            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;
            result[index] = A[outIndex];
          }
        }
        `)},n}();function Eg(n,e){if((0,y.y3$)()instanceof N)return function(t,s){var a=(0,y.y3$)(),u=new Ig(s.shape),d=a.runWebGPUProgram(u,[t,s],"float32");return(0,y.SRH)().makeTensorFromTensorInfo(d)}(n,e);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}var Tg=function(){function n(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,e.length!==2||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var t=[e[0],1];this.dispatchLayout=Gt(t),this.dispatch=Ut(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return n.prototype.getUserCode=function(){return`
    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {
      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;
      let outIndexX = outIndexY + uniforms.bShape.z;
      let outY = i32(B[outIndexY]);
      let outX = i32(B[outIndexX]);
      return vec2<i32>(outY, outX);
    }

    `.concat(sg("index"),` {
      if (index < uniforms.size) {
        let indexY = index * `).concat(this.supportedLastDimension,`;
        let indexX = indexY + 1;
        let heatmapY = A[indexY];
        let heatmapX = A[indexX];
        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);
        result[indexY] = f32(out[0]);
        result[indexX] = f32(out[1]);
      }
    }
    `)},n}();function $g(n,e){if((0,y.y3$)()instanceof N)return function(t,s){var a=(0,y.y3$)(),u=new Tg(t.shape),d=a.runWebGPUProgram(u,[t,s],"float32");return(0,y.SRH)().makeTensorFromTensorInfo(d)}(n,e);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}function rg(n){var e=n.shape,t=e[0],s=e[1],a=e[2];return(0,y.lub)(function(){var u,d,m=(0,y.XLQ)(n,[t*s,a]),b=(0,y.NqF)(m,0),T=(0,y.dt4)((0,y.hiC)(b,(0,y.iD$)(s,"int32")),1),k=(0,y.dt4)((u=b,d=s,(0,y.lub)(function(){var R=(0,y.hiC)(u,(0,y.iD$)(d,"int32"));return(0,y.luU)(u,(0,y.dC7)(R,(0,y.iD$)(d,"int32")))})),1);return(0,y.zoF)([T,k],1)})}function Ng(n,e,t){return(0,y.lub)(function(){var s=function(a,u){for(var d=[],m=0;m<Qo.length;m++){var b=a.get(m,0).valueOf(),T=a.get(m,1).valueOf(),k=kg(b,T,m,u),R=k.x,B=k.y;d.push(B),d.push(R)}return(0,y.odF)(d,[Qo.length,2])}(n,t);return(0,y.IHx)((0,y.pju)((0,y.dC7)(n.toTensor(),(0,y.iD$)(e,"int32")),"float32"),s)})}function kg(n,e,t,s){return{y:s.get(n,e,t),x:s.get(n,e,t+Qo.length)}}function Rg(n,e,t){return zn(this,void 0,void 0,function(){var s,a,u,d,m,b,T,k,R,B;return jn(this,function(X){switch(X.label){case 0:return s=0,a=rg(n),[4,Promise.all([n.buffer(),e.buffer(),a.buffer()])];case 1:return u=X.sent(),d=u[0],m=u[1],b=u[2],[4,(T=Ng(b,t,m)).buffer()];case 2:return k=X.sent(),R=Array.from(function(oe,ue){for(var he=ue.shape[0],Ue=new Float32Array(he),Xe=0;Xe<he;Xe++){var ot=ue.get(Xe,0),it=ue.get(Xe,1);Ue[Xe]=oe.get(ot,it,Xe)}return Ue}(d,b)),B=R.map(function(oe,ue){return s+=oe,{y:k.get(ue,0),x:k.get(ue,1),score:oe,name:Qo[ue]}}),a.dispose(),T.dispose(),[2,{keypoints:B,score:s/B.length}]}})})}function Dg(n,e,t){return zn(this,void 0,void 0,function(){var s,a,u;return jn(this,function(d){return s=rg(n),a=function(m,b,T){return(0,y.lub)(function(){var k=$g(m,T);return(0,y.IHx)((0,y.pju)((0,y.dC7)(m,(0,y.iD$)(b,"int32")),"float32"),k)})}(s,t,e),u=Eg(n,s),[2,[a,u]]})})}function og(n,e){return(n-1)%e==0}var ag="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",ig="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function ug(n,e){return function(t,s){return(t-1)%s==0}(n,e)?n:Math.floor(n/e)*e+1}var lg=function(){function n(e,t){this.posenetModel=e;var s=this.posenetModel.inputs[0].shape;y.D5U.assert(s[1]===-1&&s[2]===-1,function(){return"Input shape [".concat(s[1],", ").concat(s[2],"] ")+"must both be equal to or -1"});var a,u,d=(a=t.inputResolution,u=t.outputStride,{height:ug(a.height,u),width:ug(a.width,u)});(function(m){y.D5U.assert(mg.indexOf(m)>=0,function(){return"outputStride of ".concat(m," is invalid. ")+"It must be either 8 or 16."})})(t.outputStride),function(m,b){y.D5U.assert(og(m.height,b),function(){return"height of ".concat(m.height," is invalid for output stride ")+"".concat(b,".")}),y.D5U.assert(og(m.width,b),function(){return"width of ".concat(m.width," is invalid for output stride ")+"".concat(b,".")})}(d,t.outputStride),this.inputResolution=d,this.outputStride=t.outputStride,this.architecture=t.architecture}return n.prototype.estimatePoses=function(e,t){return t===void 0&&(t=Km),zn(this,void 0,void 0,function(){return jn(this,function(s){return[2,this.estimatePosesGPU(e,t,!1)]})})},n.prototype.estimatePosesGPU=function(e,t,s){return t===void 0&&(t=Km),s===void 0&&(s=!1),zn(this,void 0,void 0,function(){var a,u,d,m,b,T,k,R,B,X,oe,ue,he,Ue,Xe,ot,it,mt;return jn(this,function(wt){switch(wt.label){case 0:return a=function(St){var Mt=St;if(Mt.maxPoses==null&&(Mt.maxPoses=1),Mt.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(Mt.maxPoses,". Should be > 0."));if(Mt.maxPoses>1){if((Mt=is(is({},gg),Mt)).scoreThreshold<0||Mt.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(Mt.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(Mt.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(Mt.nmsRadius,"."))}return Mt}(t),e==null?[2,s?[[],[]]:[]]:(this.maxPoses=a.maxPoses,u=pa(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),d=u.imageTensor,m=u.padding,b=this.architecture==="ResNet50"?(0,y.IHx)(d,yg):Pd(d,[-1,1]),T=this.posenetModel.predict(b),this.architecture==="ResNet50"?(k=(0,y.L9e)(T[2],[0]),R=(0,y.L9e)(T[3],[0]),B=(0,y.L9e)(T[0],[0]),X=(0,y.L9e)(T[1],[0])):(k=(0,y.L9e)(T[0],[0]),R=(0,y.L9e)(T[1],[0]),B=(0,y.L9e)(T[2],[0]),X=(0,y.L9e)(T[3],[0])),oe=(0,y.XD2)(R),this.maxPoses!==1?[3,5]:s?[4,Dg(oe,k,this.outputStride)]:[3,2]);case 1:return he=wt.sent(),Xe=he[0],Ue=he[1],ue=[Xe,Ue],[3,4];case 2:return[4,Rg(oe,k,this.outputStride)];case 3:Xe=wt.sent(),ue=[Xe],wt.label=4;case 4:return[3,7];case 5:if(s)throw new Error("GPU renderer only supports single pose!");return[4,Sg(oe,k,B,X,this.outputStride,this.maxPoses,a.scoreThreshold,a.nmsRadius)];case 6:ue=wt.sent(),wt.label=7;case 7:if(s){if(a.flipHorizontal===!0)throw new Error("flipHorizontal is not supported!");ot=this.getCanvasInfo(Li(e),this.inputResolution,m)}else mt=Li(e),it=function(St,Mt,Bt,en){var hn=Mt.height,Nn=Mt.width,vn=hn/(Bt.height*(1-en.top-en.bottom)),On=Nn/(Bt.width*(1-en.left-en.right)),Qn=-en.top*Bt.height,ts=-en.left*Bt.width;if(On===1&&vn===1&&Qn===0&&ts===0)return St;for(var xo=0,Wo=St;xo<Wo.length;xo++)for(var Vo=0,ai=Wo[xo].keypoints;Vo<ai.length;Vo++){var Ga=ai[Vo];Ga.x=(Ga.x+ts)*On,Ga.y=(Ga.y+Qn)*vn}return St}(ue,mt,this.inputResolution,m),a.flipHorizontal&&(it=function(St,Mt){for(var Bt=0,en=St;Bt<en.length;Bt++)for(var hn=0,Nn=en[Bt].keypoints;hn<Nn.length;hn++){var vn=Nn[hn];vn.x=Mt.width-1-vn.x}return St}(it,mt));return d.dispose(),b.dispose(),(0,y.B90)(T),k.dispose(),R.dispose(),B.dispose(),X.dispose(),oe.dispose(),[2,s?[ue,ot]:it]}})})},n.prototype.getCanvasInfo=function(e,t,s){var a=e.height,u=e.width,d=a/(t.height*(1-s.top-s.bottom)),m=u/(t.width*(1-s.left-s.right)),b=-s.top*t.height;return[-s.left*t.width,b,m,d,e.width,e.height]},n.prototype.dispose=function(){this.posenetModel.dispose()},n.prototype.reset=function(){},n}();function _g(n){return n===void 0&&(n=Vm),zn(this,void 0,void 0,function(){var e,t,s,a,u;return jn(this,function(d){switch(d.label){case 0:return(e=function(k){var R=k||Vm;if(R.architecture==null&&(R.architecture="MobileNetV1"),zm.indexOf(R.architecture)<0)throw new Error("Invalid architecture ".concat(R.architecture,". ")+"Should be one of ".concat(zm));if(R.inputResolution==null&&(R.inputResolution={height:257,width:257}),R.outputStride==null&&(R.outputStride=16),Gm[R.architecture].indexOf(R.outputStride)<0)throw new Error("Invalid outputStride ".concat(R.outputStride,". ")+"Should be one of ".concat(Gm[R.architecture]," ")+"for architecture ".concat(R.architecture,"."));if(R.multiplier==null&&(R.multiplier=1),Hm[R.architecture].indexOf(R.multiplier)<0)throw new Error("Invalid multiplier ".concat(R.multiplier,". ")+"Should be one of ".concat(Hm[R.architecture]," ")+"for architecture ".concat(R.architecture,"."));if(R.quantBytes==null&&(R.quantBytes=4),jm.indexOf(R.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(R.quantBytes,". ")+"Should be one of ".concat(jm," ")+"for architecture ".concat(R.architecture,"."));if(R.architecture==="MobileNetV1"&&R.outputStride===32&&R.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return R}(n)).architecture!=="ResNet50"?[3,2]:(m=e.outputStride,b=e.quantBytes,T="model-stride".concat(m,".json"),t=b===4?ig+"float/"+T:ig+"quant".concat(b,"/")+T,[4,Oe(e.modelUrl||t)]);case 1:return s=d.sent(),[2,new lg(s,e)];case 2:return a=function(k,R,B){var X={1:"100",.75:"075",.5:"050"},oe="model-stride".concat(k,".json");return B===4?ag+"float/".concat(X[R],"/")+oe:ag+"quant".concat(B,"/").concat(X[R],"/")+oe}(e.outputStride,e.multiplier,e.quantBytes),[4,Oe(e.modelUrl||a)];case 3:return u=d.sent(),[2,new lg(u,e)]}var m,b,T})})}function Ag(n,e){return zn(this,void 0,void 0,function(){var t,s;return jn(this,function(a){switch(n){case us.PoseNet:return[2,_g(e)];case us.BlazePose:if(s=void 0,(t=e)!=null){if(t.runtime==="tfjs")return[2,Zo(e)];if(t.runtime==="mediapipe")return[2,rm(e)];s=t.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(s));case us.MoveNet:return[2,fg(e)];default:throw new Error("".concat(n," is not a supported model name."))}})})}var Fg=null,Bg=null},6821:function(Wt){Wt.exports=L;var dt=null;try{dt=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function L(re,G,Re){this.low=re|0,this.high=G|0,this.unsigned=!!Re}L.prototype.__isLong__,Object.defineProperty(L.prototype,"__isLong__",{value:!0});function p(re){return(re&&re.__isLong__)===!0}L.isLong=p;var ze={},Z={};function ie(re,G){var Re,Be,at;return G?(re>>>=0,(at=0<=re&&re<256)&&(Be=Z[re],Be)?Be:(Re=W(re,(re|0)<0?-1:0,!0),at&&(Z[re]=Re),Re)):(re|=0,(at=-128<=re&&re<128)&&(Be=ze[re],Be)?Be:(Re=W(re,re<0?-1:0,!1),at&&(ze[re]=Re),Re))}L.fromInt=ie;function P(re,G){if(isNaN(re))return G?ht:rt;if(G){if(re<0)return ht;if(re>=De)return y}else{if(re<=-Fe)return Qe;if(re+1>=Fe)return ve}return re<0?P(-re,G).neg():W(re%_|0,re/_|0,G)}L.fromNumber=P;function W(re,G,Re){return new L(re,G,Re)}L.fromBits=W;var pe=Math.pow;function ee(re,G,Re){if(re.length===0)throw Error("empty string");if(re==="NaN"||re==="Infinity"||re==="+Infinity"||re==="-Infinity")return rt;if(typeof G=="number"?(Re=G,G=!1):G=!!G,Re=Re||10,Re<2||36<Re)throw RangeError("radix");var Be;if((Be=re.indexOf("-"))>0)throw Error("interior hyphen");if(Be===0)return ee(re.substring(1),G,Re).neg();for(var at=P(pe(Re,8)),S=rt,nt=0;nt<re.length;nt+=8){var ne=Math.min(8,re.length-nt),Ne=parseInt(re.substring(nt,nt+ne),Re);if(ne<8){var Ve=P(pe(Re,ne));S=S.mul(Ve).add(P(Ne))}else S=S.mul(at),S=S.add(P(Ne))}return S.unsigned=G,S}L.fromString=ee;function we(re,G){return typeof re=="number"?P(re,G):typeof re=="string"?ee(re,G):W(re.low,re.high,typeof G=="boolean"?G:re.unsigned)}L.fromValue=we;var xe=65536,K=1<<24,_=xe*xe,De=_*_,Fe=De/2,Ke=ie(K),rt=ie(0);L.ZERO=rt;var ht=ie(0,!0);L.UZERO=ht;var Vt=ie(1);L.ONE=Vt;var on=ie(1,!0);L.UONE=on;var $t=ie(-1);L.NEG_ONE=$t;var ve=W(-1,2147483647,!1);L.MAX_VALUE=ve;var y=W(-1,-1,!0);L.MAX_UNSIGNED_VALUE=y;var Qe=W(0,-2147483648,!1);L.MIN_VALUE=Qe;var V=L.prototype;V.toInt=function(){return this.unsigned?this.low>>>0:this.low},V.toNumber=function(){return this.unsigned?(this.high>>>0)*_+(this.low>>>0):this.high*_+(this.low>>>0)},V.toString=function(G){if(G=G||10,G<2||36<G)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Qe)){var Re=P(G),Be=this.div(Re),at=Be.mul(Re).sub(this);return Be.toString(G)+at.toInt().toString(G)}else return"-"+this.neg().toString(G);for(var S=P(pe(G,6),this.unsigned),nt=this,ne="";;){var Ne=nt.div(S),Ve=nt.sub(Ne.mul(S)).toInt()>>>0,ce=Ve.toString(G);if(nt=Ne,nt.isZero())return ce+ne;for(;ce.length<6;)ce="0"+ce;ne=""+ce+ne}},V.getHighBits=function(){return this.high},V.getHighBitsUnsigned=function(){return this.high>>>0},V.getLowBits=function(){return this.low},V.getLowBitsUnsigned=function(){return this.low>>>0},V.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Qe)?64:this.neg().getNumBitsAbs();for(var G=this.high!=0?this.high:this.low,Re=31;Re>0&&(G&1<<Re)==0;Re--);return this.high!=0?Re+33:Re+1},V.isZero=function(){return this.high===0&&this.low===0},V.eqz=V.isZero,V.isNegative=function(){return!this.unsigned&&this.high<0},V.isPositive=function(){return this.unsigned||this.high>=0},V.isOdd=function(){return(this.low&1)===1},V.isEven=function(){return(this.low&1)===0},V.equals=function(G){return p(G)||(G=we(G)),this.unsigned!==G.unsigned&&this.high>>>31===1&&G.high>>>31===1?!1:this.high===G.high&&this.low===G.low},V.eq=V.equals,V.notEquals=function(G){return!this.eq(G)},V.neq=V.notEquals,V.ne=V.notEquals,V.lessThan=function(G){return this.comp(G)<0},V.lt=V.lessThan,V.lessThanOrEqual=function(G){return this.comp(G)<=0},V.lte=V.lessThanOrEqual,V.le=V.lessThanOrEqual,V.greaterThan=function(G){return this.comp(G)>0},V.gt=V.greaterThan,V.greaterThanOrEqual=function(G){return this.comp(G)>=0},V.gte=V.greaterThanOrEqual,V.ge=V.greaterThanOrEqual,V.compare=function(G){if(p(G)||(G=we(G)),this.eq(G))return 0;var Re=this.isNegative(),Be=G.isNegative();return Re&&!Be?-1:!Re&&Be?1:this.unsigned?G.high>>>0>this.high>>>0||G.high===this.high&&G.low>>>0>this.low>>>0?-1:1:this.sub(G).isNegative()?-1:1},V.comp=V.compare,V.negate=function(){return!this.unsigned&&this.eq(Qe)?Qe:this.not().add(Vt)},V.neg=V.negate,V.add=function(G){p(G)||(G=we(G));var Re=this.high>>>16,Be=this.high&65535,at=this.low>>>16,S=this.low&65535,nt=G.high>>>16,ne=G.high&65535,Ne=G.low>>>16,Ve=G.low&65535,ce=0,me=0,pt=0,ct=0;return ct+=S+Ve,pt+=ct>>>16,ct&=65535,pt+=at+Ne,me+=pt>>>16,pt&=65535,me+=Be+ne,ce+=me>>>16,me&=65535,ce+=Re+nt,ce&=65535,W(pt<<16|ct,ce<<16|me,this.unsigned)},V.subtract=function(G){return p(G)||(G=we(G)),this.add(G.neg())},V.sub=V.subtract,V.multiply=function(G){if(this.isZero())return rt;if(p(G)||(G=we(G)),dt){var Re=dt.mul(this.low,this.high,G.low,G.high);return W(Re,dt.get_high(),this.unsigned)}if(G.isZero())return rt;if(this.eq(Qe))return G.isOdd()?Qe:rt;if(G.eq(Qe))return this.isOdd()?Qe:rt;if(this.isNegative())return G.isNegative()?this.neg().mul(G.neg()):this.neg().mul(G).neg();if(G.isNegative())return this.mul(G.neg()).neg();if(this.lt(Ke)&&G.lt(Ke))return P(this.toNumber()*G.toNumber(),this.unsigned);var Be=this.high>>>16,at=this.high&65535,S=this.low>>>16,nt=this.low&65535,ne=G.high>>>16,Ne=G.high&65535,Ve=G.low>>>16,ce=G.low&65535,me=0,pt=0,ct=0,Lt=0;return Lt+=nt*ce,ct+=Lt>>>16,Lt&=65535,ct+=S*ce,pt+=ct>>>16,ct&=65535,ct+=nt*Ve,pt+=ct>>>16,ct&=65535,pt+=at*ce,me+=pt>>>16,pt&=65535,pt+=S*Ve,me+=pt>>>16,pt&=65535,pt+=nt*Ne,me+=pt>>>16,pt&=65535,me+=Be*ce+at*Ve+S*Ne+nt*ne,me&=65535,W(ct<<16|Lt,me<<16|pt,this.unsigned)},V.mul=V.multiply,V.divide=function(G){if(p(G)||(G=we(G)),G.isZero())throw Error("division by zero");if(dt){if(!this.unsigned&&this.high===-2147483648&&G.low===-1&&G.high===-1)return this;var Re=(this.unsigned?dt.div_u:dt.div_s)(this.low,this.high,G.low,G.high);return W(Re,dt.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?ht:rt;var Be,at,S;if(this.unsigned){if(G.unsigned||(G=G.toUnsigned()),G.gt(this))return ht;if(G.gt(this.shru(1)))return on;S=ht}else{if(this.eq(Qe)){if(G.eq(Vt)||G.eq($t))return Qe;if(G.eq(Qe))return Vt;var nt=this.shr(1);return Be=nt.div(G).shl(1),Be.eq(rt)?G.isNegative()?Vt:$t:(at=this.sub(G.mul(Be)),S=Be.add(at.div(G)),S)}else if(G.eq(Qe))return this.unsigned?ht:rt;if(this.isNegative())return G.isNegative()?this.neg().div(G.neg()):this.neg().div(G).neg();if(G.isNegative())return this.div(G.neg()).neg();S=rt}for(at=this;at.gte(G);){Be=Math.max(1,Math.floor(at.toNumber()/G.toNumber()));for(var ne=Math.ceil(Math.log(Be)/Math.LN2),Ne=ne<=48?1:pe(2,ne-48),Ve=P(Be),ce=Ve.mul(G);ce.isNegative()||ce.gt(at);)Be-=Ne,Ve=P(Be,this.unsigned),ce=Ve.mul(G);Ve.isZero()&&(Ve=Vt),S=S.add(Ve),at=at.sub(ce)}return S},V.div=V.divide,V.modulo=function(G){if(p(G)||(G=we(G)),dt){var Re=(this.unsigned?dt.rem_u:dt.rem_s)(this.low,this.high,G.low,G.high);return W(Re,dt.get_high(),this.unsigned)}return this.sub(this.div(G).mul(G))},V.mod=V.modulo,V.rem=V.modulo,V.not=function(){return W(~this.low,~this.high,this.unsigned)},V.and=function(G){return p(G)||(G=we(G)),W(this.low&G.low,this.high&G.high,this.unsigned)},V.or=function(G){return p(G)||(G=we(G)),W(this.low|G.low,this.high|G.high,this.unsigned)},V.xor=function(G){return p(G)||(G=we(G)),W(this.low^G.low,this.high^G.high,this.unsigned)},V.shiftLeft=function(G){return p(G)&&(G=G.toInt()),(G&=63)===0?this:G<32?W(this.low<<G,this.high<<G|this.low>>>32-G,this.unsigned):W(0,this.low<<G-32,this.unsigned)},V.shl=V.shiftLeft,V.shiftRight=function(G){return p(G)&&(G=G.toInt()),(G&=63)===0?this:G<32?W(this.low>>>G|this.high<<32-G,this.high>>G,this.unsigned):W(this.high>>G-32,this.high>=0?0:-1,this.unsigned)},V.shr=V.shiftRight,V.shiftRightUnsigned=function(G){if(p(G)&&(G=G.toInt()),G&=63,G===0)return this;var Re=this.high;if(G<32){var Be=this.low;return W(Be>>>G|Re<<32-G,Re>>>G,this.unsigned)}else return G===32?W(Re,0,this.unsigned):W(Re>>>G-32,0,this.unsigned)},V.shru=V.shiftRightUnsigned,V.shr_u=V.shiftRightUnsigned,V.toSigned=function(){return this.unsigned?W(this.low,this.high,!1):this},V.toUnsigned=function(){return this.unsigned?this:W(this.low,this.high,!0)},V.toBytes=function(G){return G?this.toBytesLE():this.toBytesBE()},V.toBytesLE=function(){var G=this.high,Re=this.low;return[Re&255,Re>>>8&255,Re>>>16&255,Re>>>24,G&255,G>>>8&255,G>>>16&255,G>>>24]},V.toBytesBE=function(){var G=this.high,Re=this.low;return[G>>>24,G>>>16&255,G>>>8&255,G&255,Re>>>24,Re>>>16&255,Re>>>8&255,Re&255]},L.fromBytes=function(G,Re,Be){return Be?L.fromBytesLE(G,Re):L.fromBytesBE(G,Re)},L.fromBytesLE=function(G,Re){return new L(G[0]|G[1]<<8|G[2]<<16|G[3]<<24,G[4]|G[5]<<8|G[6]<<16|G[7]<<24,Re)},L.fromBytesBE=function(G,Re){return new L(G[4]<<24|G[5]<<16|G[6]<<8|G[7],G[0]<<24|G[1]<<16|G[2]<<8|G[3],Re)}},6963:function(Wt,dt,L){var p=L(9680),ze=L(9598),Z=L(6508),ie=L(5839),P=L(6707),W=L(486),pe=L(912);pe.alea=p,pe.xor128=ze,pe.xorwow=Z,pe.xorshift7=ie,pe.xor4096=P,pe.tychei=W,Wt.exports=pe},9680:function(Wt,dt,L){Wt=L.nmd(Wt),function(p,ze,Z){function ie(ee){var we=this,xe=pe();we.next=function(){var K=2091639*we.s0+we.c*23283064365386963e-26;return we.s0=we.s1,we.s1=we.s2,we.s2=K-(we.c=K|0)},we.c=1,we.s0=xe(" "),we.s1=xe(" "),we.s2=xe(" "),we.s0-=xe(ee),we.s0<0&&(we.s0+=1),we.s1-=xe(ee),we.s1<0&&(we.s1+=1),we.s2-=xe(ee),we.s2<0&&(we.s2+=1),xe=null}function P(ee,we){return we.c=ee.c,we.s0=ee.s0,we.s1=ee.s1,we.s2=ee.s2,we}function W(ee,we){var xe=new ie(ee),K=we&&we.state,_=xe.next;return _.int32=function(){return xe.next()*4294967296|0},_.double=function(){return _()+(_()*2097152|0)*11102230246251565e-32},_.quick=_,K&&(typeof K=="object"&&P(K,xe),_.state=function(){return P(xe,{})}),_}function pe(){var ee=4022871197,we=function(xe){xe=String(xe);for(var K=0;K<xe.length;K++){ee+=xe.charCodeAt(K);var _=.02519603282416938*ee;ee=_>>>0,_-=ee,_*=ee,ee=_>>>0,_-=ee,ee+=_*4294967296}return(ee>>>0)*23283064365386963e-26};return we}ze&&ze.exports?ze.exports=W:Z&&Z.amd?Z(function(){return W}):this.alea=W}(this,Wt,typeof define=="function"&&define)},486:function(Wt,dt,L){Wt=L.nmd(Wt),function(p,ze,Z){function ie(pe){var ee=this,we="";ee.next=function(){var K=ee.b,_=ee.c,De=ee.d,Fe=ee.a;return K=K<<25^K>>>7^_,_=_-De|0,De=De<<24^De>>>8^Fe,Fe=Fe-K|0,ee.b=K=K<<20^K>>>12^_,ee.c=_=_-De|0,ee.d=De<<16^_>>>16^Fe,ee.a=Fe-K|0},ee.a=0,ee.b=0,ee.c=-1640531527,ee.d=1367130551,pe===Math.floor(pe)?(ee.a=pe/4294967296|0,ee.b=pe|0):we+=pe;for(var xe=0;xe<we.length+20;xe++)ee.b^=we.charCodeAt(xe)|0,ee.next()}function P(pe,ee){return ee.a=pe.a,ee.b=pe.b,ee.c=pe.c,ee.d=pe.d,ee}function W(pe,ee){var we=new ie(pe),xe=ee&&ee.state,K=function(){return(we.next()>>>0)/4294967296};return K.double=function(){do var _=we.next()>>>11,De=(we.next()>>>0)/4294967296,Fe=(_+De)/(1<<21);while(Fe===0);return Fe},K.int32=we.next,K.quick=K,xe&&(typeof xe=="object"&&P(xe,we),K.state=function(){return P(we,{})}),K}ze&&ze.exports?ze.exports=W:Z&&Z.amd?Z(function(){return W}):this.tychei=W}(this,Wt,typeof define=="function"&&define)},9598:function(Wt,dt,L){Wt=L.nmd(Wt),function(p,ze,Z){function ie(pe){var ee=this,we="";ee.x=0,ee.y=0,ee.z=0,ee.w=0,ee.next=function(){var K=ee.x^ee.x<<11;return ee.x=ee.y,ee.y=ee.z,ee.z=ee.w,ee.w^=ee.w>>>19^K^K>>>8},pe===(pe|0)?ee.x=pe:we+=pe;for(var xe=0;xe<we.length+64;xe++)ee.x^=we.charCodeAt(xe)|0,ee.next()}function P(pe,ee){return ee.x=pe.x,ee.y=pe.y,ee.z=pe.z,ee.w=pe.w,ee}function W(pe,ee){var we=new ie(pe),xe=ee&&ee.state,K=function(){return(we.next()>>>0)/4294967296};return K.double=function(){do var _=we.next()>>>11,De=(we.next()>>>0)/4294967296,Fe=(_+De)/(1<<21);while(Fe===0);return Fe},K.int32=we.next,K.quick=K,xe&&(typeof xe=="object"&&P(xe,we),K.state=function(){return P(we,{})}),K}ze&&ze.exports?ze.exports=W:Z&&Z.amd?Z(function(){return W}):this.xor128=W}(this,Wt,typeof define=="function"&&define)},6707:function(Wt,dt,L){Wt=L.nmd(Wt),function(p,ze,Z){function ie(pe){var ee=this;ee.next=function(){var xe=ee.w,K=ee.X,_=ee.i,De,Fe;return ee.w=xe=xe+1640531527|0,Fe=K[_+34&127],De=K[_=_+1&127],Fe^=Fe<<13,De^=De<<17,Fe^=Fe>>>15,De^=De>>>12,Fe=K[_]=Fe^De,ee.i=_,Fe+(xe^xe>>>16)|0};function we(xe,K){var _,De,Fe,Ke,rt,ht=[],Vt=128;for(K===(K|0)?(De=K,K=null):(K=K+"\0",De=0,Vt=Math.max(Vt,K.length)),Fe=0,Ke=-32;Ke<Vt;++Ke)K&&(De^=K.charCodeAt((Ke+32)%K.length)),Ke===0&&(rt=De),De^=De<<10,De^=De>>>15,De^=De<<4,De^=De>>>13,Ke>=0&&(rt=rt+1640531527|0,_=ht[Ke&127]^=De+rt,Fe=_==0?Fe+1:0);for(Fe>=128&&(ht[(K&&K.length||0)&127]=-1),Fe=127,Ke=4*128;Ke>0;--Ke)De=ht[Fe+34&127],_=ht[Fe=Fe+1&127],De^=De<<13,_^=_<<17,De^=De>>>15,_^=_>>>12,ht[Fe]=De^_;xe.w=rt,xe.X=ht,xe.i=Fe}we(ee,pe)}function P(pe,ee){return ee.i=pe.i,ee.w=pe.w,ee.X=pe.X.slice(),ee}function W(pe,ee){pe==null&&(pe=+new Date);var we=new ie(pe),xe=ee&&ee.state,K=function(){return(we.next()>>>0)/4294967296};return K.double=function(){do var _=we.next()>>>11,De=(we.next()>>>0)/4294967296,Fe=(_+De)/(1<<21);while(Fe===0);return Fe},K.int32=we.next,K.quick=K,xe&&(xe.X&&P(xe,we),K.state=function(){return P(we,{})}),K}ze&&ze.exports?ze.exports=W:Z&&Z.amd?Z(function(){return W}):this.xor4096=W}(this,Wt,typeof define=="function"&&define)},5839:function(Wt,dt,L){Wt=L.nmd(Wt),function(p,ze,Z){function ie(pe){var ee=this;ee.next=function(){var xe=ee.x,K=ee.i,_,De,Fe;return _=xe[K],_^=_>>>7,De=_^_<<24,_=xe[K+1&7],De^=_^_>>>10,_=xe[K+3&7],De^=_^_>>>3,_=xe[K+4&7],De^=_^_<<7,_=xe[K+7&7],_=_^_<<13,De^=_^_<<9,xe[K]=De,ee.i=K+1&7,De};function we(xe,K){var _,De,Fe=[];if(K===(K|0))De=Fe[0]=K;else for(K=""+K,_=0;_<K.length;++_)Fe[_&7]=Fe[_&7]<<15^K.charCodeAt(_)+Fe[_+1&7]<<13;for(;Fe.length<8;)Fe.push(0);for(_=0;_<8&&Fe[_]===0;++_);for(_==8?De=Fe[7]=-1:De=Fe[_],xe.x=Fe,xe.i=0,_=256;_>0;--_)xe.next()}we(ee,pe)}function P(pe,ee){return ee.x=pe.x.slice(),ee.i=pe.i,ee}function W(pe,ee){pe==null&&(pe=+new Date);var we=new ie(pe),xe=ee&&ee.state,K=function(){return(we.next()>>>0)/4294967296};return K.double=function(){do var _=we.next()>>>11,De=(we.next()>>>0)/4294967296,Fe=(_+De)/(1<<21);while(Fe===0);return Fe},K.int32=we.next,K.quick=K,xe&&(xe.x&&P(xe,we),K.state=function(){return P(we,{})}),K}ze&&ze.exports?ze.exports=W:Z&&Z.amd?Z(function(){return W}):this.xorshift7=W}(this,Wt,typeof define=="function"&&define)},6508:function(Wt,dt,L){Wt=L.nmd(Wt),function(p,ze,Z){function ie(pe){var ee=this,we="";ee.next=function(){var K=ee.x^ee.x>>>2;return ee.x=ee.y,ee.y=ee.z,ee.z=ee.w,ee.w=ee.v,(ee.d=ee.d+362437|0)+(ee.v=ee.v^ee.v<<4^(K^K<<1))|0},ee.x=0,ee.y=0,ee.z=0,ee.w=0,ee.v=0,pe===(pe|0)?ee.x=pe:we+=pe;for(var xe=0;xe<we.length+64;xe++)ee.x^=we.charCodeAt(xe)|0,xe==we.length&&(ee.d=ee.x<<10^ee.x>>>4),ee.next()}function P(pe,ee){return ee.x=pe.x,ee.y=pe.y,ee.z=pe.z,ee.w=pe.w,ee.v=pe.v,ee.d=pe.d,ee}function W(pe,ee){var we=new ie(pe),xe=ee&&ee.state,K=function(){return(we.next()>>>0)/4294967296};return K.double=function(){do var _=we.next()>>>11,De=(we.next()>>>0)/4294967296,Fe=(_+De)/(1<<21);while(Fe===0);return Fe},K.int32=we.next,K.quick=K,xe&&(typeof xe=="object"&&P(xe,we),K.state=function(){return P(we,{})}),K}ze&&ze.exports?ze.exports=W:Z&&Z.amd?Z(function(){return W}):this.xorwow=W}(this,Wt,typeof define=="function"&&define)},912:function(Wt,dt,L){(function(p,ze,Z){var ie=256,P=6,W=52,pe="random",ee=Z.pow(ie,P),we=Z.pow(2,W),xe=we*2,K=ie-1,_;function De($t,ve,y){var Qe=[];ve=ve==!0?{entropy:!0}:ve||{};var V=ht(rt(ve.entropy?[$t,on(ze)]:$t??Vt(),3),Qe),re=new Fe(Qe),G=function(){for(var Re=re.g(P),Be=ee,at=0;Re<we;)Re=(Re+at)*ie,Be*=ie,at=re.g(1);for(;Re>=xe;)Re/=2,Be/=2,at>>>=1;return(Re+at)/Be};return G.int32=function(){return re.g(4)|0},G.quick=function(){return re.g(4)/4294967296},G.double=G,ht(on(re.S),ze),(ve.pass||y||function(Re,Be,at,S){return S&&(S.S&&Ke(S,re),Re.state=function(){return Ke(re,{})}),at?(Z[pe]=Re,Be):Re})(G,V,"global"in ve?ve.global:this==Z,ve.state)}function Fe($t){var ve,y=$t.length,Qe=this,V=0,re=Qe.i=Qe.j=0,G=Qe.S=[];for(y||($t=[y++]);V<ie;)G[V]=V++;for(V=0;V<ie;V++)G[V]=G[re=K&re+$t[V%y]+(ve=G[V])],G[re]=ve;(Qe.g=function(Re){for(var Be,at=0,S=Qe.i,nt=Qe.j,ne=Qe.S;Re--;)Be=ne[S=K&S+1],at=at*ie+ne[K&(ne[S]=ne[nt=K&nt+Be])+(ne[nt]=Be)];return Qe.i=S,Qe.j=nt,at})(ie)}function Ke($t,ve){return ve.i=$t.i,ve.j=$t.j,ve.S=$t.S.slice(),ve}function rt($t,ve){var y=[],Qe=typeof $t,V;if(ve&&Qe=="object")for(V in $t)try{y.push(rt($t[V],ve-1))}catch{}return y.length?y:Qe=="string"?$t:$t+"\0"}function ht($t,ve){for(var y=$t+"",Qe,V=0;V<y.length;)ve[K&V]=K&(Qe^=ve[K&V]*19)+y.charCodeAt(V++);return on(ve)}function Vt(){try{var $t;return _&&($t=_.randomBytes)?$t=$t(ie):($t=new Uint8Array(ie),(p.crypto||p.msCrypto).getRandomValues($t)),on($t)}catch{var ve=p.navigator,y=ve&&ve.plugins;return[+new Date,p,y,p.screen,on(ze)]}}function on($t){return String.fromCharCode.apply(0,$t)}if(ht(Z.random(),ze),Wt.exports){Wt.exports=De;try{_=L(4487)}catch{}}else typeof define=="function"&&define.amd?define(function(){return De}):Z["seed"+pe]=De})(typeof self<"u"?self:this,[],Math)}}]);
